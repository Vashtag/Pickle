<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Pickle Brawl â€” Roguelike Pickleball Tournament</title>
<style>
  :root {
    --bg:#0a0a14; --court:#1a6a2a; --line:#e8e8d0; --net:#ccccaa;
    --p1:#49d0ff; --p2:#ff6b4a; --ball:#ffe033;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(10,10,20,0.92); --text:#e6edf3; --muted:#7a8a9a;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:var(--bg);color:var(--text);font-family:'Courier New',Courier,monospace;overflow:hidden;user-select:none;-webkit-user-select:none}
  canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges}
  #wrap{position:fixed;inset:0;display:grid;place-items:center;background:#000}
  #scanlines{position:fixed;inset:0;pointer-events:none;z-index:10;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.06) 2px,rgba(0,0,0,0.06) 4px)}
  #crt-glow{position:fixed;inset:0;pointer-events:none;z-index:9;box-shadow:inset 0 0 80px rgba(0,0,0,0.5),inset 0 0 160px rgba(0,0,0,0.3);border-radius:8px}
  .screen{position:fixed;inset:0;display:grid;place-items:center;z-index:20;background:rgba(0,0,0,0.85)}
  .card{background:var(--panel);border:2px solid rgba(255,255,255,0.1);border-radius:4px;padding:1.5rem;max-width:600px;width:min(600px,92vw);text-align:center}
  .card h1{font-size:1.8rem;margin-bottom:0.5rem;color:var(--accent);text-transform:uppercase;letter-spacing:3px;text-shadow:0 0 20px rgba(255,138,61,0.5)}
  .card h2{font-size:1.3rem;margin-bottom:0.5rem;color:var(--accent2);text-transform:uppercase;letter-spacing:2px}
  .card p{margin:0.4rem 0;font-size:0.85rem;color:var(--muted);line-height:1.5}
  .card .highlight{color:var(--ball);font-weight:bold}
  .btn{appearance:none;border:2px solid var(--accent);background:rgba(255,138,61,0.15);color:var(--accent);padding:0.6rem 1.4rem;font-family:inherit;font-size:1rem;font-weight:bold;text-transform:uppercase;letter-spacing:2px;cursor:pointer;border-radius:2px;transition:all 0.15s}
  .btn:hover{background:rgba(255,138,61,0.3);box-shadow:0 0 15px rgba(255,138,61,0.3)}
  .btn:active{transform:scale(0.97)}
  .upgrades{display:grid;grid-template-columns:repeat(3,1fr);gap:0.6rem;margin:1rem 0}
  .upgrade-card{border:2px solid rgba(255,255,255,0.1);border-radius:4px;padding:0.8rem 0.5rem;cursor:pointer;transition:all 0.15s;background:rgba(255,255,255,0.03)}
  .upgrade-card:hover{border-color:var(--accent);background:rgba(255,138,61,0.1);box-shadow:0 0 12px rgba(255,138,61,0.2)}
  .upgrade-card .icon{font-size:1.8rem;margin-bottom:0.3rem}
  .upgrade-card .name{font-size:0.8rem;font-weight:bold;color:var(--text);margin-bottom:0.2rem}
  .upgrade-card .desc{font-size:0.65rem;color:var(--muted)}
  .bracket{display:flex;gap:0.3rem;margin:0.8rem 0;justify-content:center;flex-wrap:wrap}
  .bracket-slot{width:28px;height:28px;border:2px solid rgba(255,255,255,0.15);border-radius:2px;display:grid;place-items:center;font-size:0.6rem;font-weight:bold}
  .bracket-slot.won{border-color:var(--accent3);color:var(--accent3);background:rgba(134,239,172,0.1)}
  .bracket-slot.current{border-color:var(--accent);color:var(--accent);background:rgba(255,138,61,0.15);animation:pulse 1s infinite}
  .bracket-slot.lost{border-color:#ff4444;color:#ff4444;background:rgba(255,68,68,0.1)}
  .bracket-slot.future{opacity:0.3}
  @keyframes pulse{0%,100%{box-shadow:0 0 4px rgba(255,138,61,0.3)}50%{box-shadow:0 0 12px rgba(255,138,61,0.6)}}
  .hud{position:fixed;top:0;left:0;right:0;pointer-events:none;z-index:15;padding:0.5rem 0.8rem;display:flex;justify-content:space-between;align-items:flex-start}
  .hud-left,.hud-right,.hud-center{display:flex;gap:0.4rem;align-items:center}
  .hud-center{position:absolute;left:50%;transform:translateX(-50%);top:0.5rem}
  .chip{background:rgba(10,10,20,0.8);border:1px solid rgba(255,255,255,0.1);border-radius:2px;padding:0.25rem 0.5rem;font-size:0.75rem}
  .chip .label{color:var(--muted);margin-right:0.3rem}
  .chip strong{color:var(--text)}
  .score-big{font-size:1.6rem;font-weight:bold;min-width:3ch;text-align:center}
  .score-p1{color:var(--p1)}
  .score-p2{color:var(--p2)}
  .slowmo-bar{position:fixed;bottom:0.6rem;left:50%;transform:translateX(-50%);width:min(200px,40vw);height:8px;border:1px solid rgba(255,255,255,0.15);border-radius:2px;z-index:15;background:rgba(0,0,0,0.5);overflow:hidden;display:none}
  .slowmo-fill{height:100%;background:linear-gradient(90deg,var(--accent2),var(--accent3));transition:width 0.1s}
  .match-result{position:fixed;inset:0;display:grid;place-items:center;z-index:25;background:rgba(0,0,0,0.8);display:none}
  .result-text{font-size:2.5rem;font-weight:bold;text-transform:uppercase;letter-spacing:4px;text-shadow:0 0 30px currentColor;animation:resultIn 0.5s ease-out}
  @keyframes resultIn{from{transform:scale(2);opacity:0}to{transform:scale(1);opacity:1}}
  .win-text{color:var(--accent3)}
  .lose-text{color:#ff4444}
  .opponent-intro{margin:0.8rem 0}
  .opponent-name{font-size:1.2rem;font-weight:bold;color:var(--p2);text-transform:uppercase;letter-spacing:2px}
  .opponent-title{font-size:0.7rem;color:var(--muted);font-style:italic}
  .opponent-stats{display:flex;gap:0.5rem;justify-content:center;margin-top:0.4rem;flex-wrap:wrap}
  .stat{font-size:0.65rem;color:var(--muted)}
  .stat-bar{display:inline-block;width:40px;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;vertical-align:middle;margin-left:0.2rem;overflow:hidden}
  .stat-fill{height:100%;background:var(--p2);border-radius:2px}
  .player-buffs{display:flex;gap:0.3rem;justify-content:center;margin:0.5rem 0;flex-wrap:wrap}
  .buff{font-size:0.6rem;padding:0.15rem 0.4rem;border:1px solid rgba(73,208,255,0.3);border-radius:2px;color:var(--accent2);background:rgba(73,208,255,0.08)}
  /* Crosshair */
</style>
</head>
<body>
<div id="wrap"><canvas id="game"></canvas></div>
<div id="scanlines"></div>
<div id="crt-glow"></div>

<!-- HUD -->
<div class="hud" id="hud" style="display:none">
  <div class="hud-left">
    <div class="chip"><span class="label">Round</span><strong id="hudRound">1</strong>/7</div>
    <div class="chip"><span class="label">Match</span><strong id="hudMatch">QF1</strong></div>
  </div>
  <div class="hud-center">
    <span class="score-big score-p1" id="scoreP1">0</span>
    <span class="chip" style="color:var(--muted)">-</span>
    <span class="score-big score-p2" id="scoreP2">0</span>
  </div>
  <div class="hud-right">
    <div class="chip"><span class="label">Serving</span><strong id="hudServe">YOU</strong></div>
  </div>
</div>
<div class="slowmo-bar" id="slowmoBar"><div class="slowmo-fill" id="slowmoFill" style="width:100%"></div></div>

<!-- Title Screen -->
<div id="screenTitle" class="screen">
  <div class="card">
    <h1>Pickle Brawl</h1>
    <p style="color:var(--accent);font-size:0.9rem;margin-bottom:0.6rem">ROGUELIKE PICKLEBALL TOURNAMENT</p>
    <p>Fight through a bracket of 7 increasingly ruthless opponents.<br/>
    Between matches, choose powerful upgrades.<br/>
    <span class="highlight">Lose once and it's all over.</span></p>
    <p style="margin-top:0.6rem;font-size:0.75rem">
      <strong>Controls:</strong> Move with WASD / Arrow Keys &bull; Click (or F) to swing<br/>
      Spacebar = activate Slow-Mo (when available)
    </p>
    <div style="margin-top:1rem"><button class="btn" id="btnStart">Enter Tournament</button></div>
  </div>
</div>

<!-- Pre-Match Screen -->
<div id="screenPreMatch" class="screen" style="display:none">
  <div class="card">
    <h2>Next Opponent</h2>
    <div class="opponent-intro">
      <div class="opponent-name" id="oppName">???</div>
      <div class="opponent-title" id="oppTitle"></div>
      <div class="opponent-stats" id="oppStats"></div>
    </div>
    <div class="bracket" id="bracketDisplay"></div>
    <div class="player-buffs" id="playerBuffs"></div>
    <p style="font-size:0.7rem;color:var(--muted);margin:0.5rem 0">First to <strong id="targetScore">5</strong> points wins</p>
    <div style="margin-top:0.8rem"><button class="btn" id="btnFight">Fight!</button></div>
  </div>
</div>

<!-- Upgrade Screen -->
<div id="screenUpgrade" class="screen" style="display:none">
  <div class="card">
    <h2>Victory! Choose an Upgrade</h2>
    <p style="font-size:0.75rem;color:var(--muted)">Pick one upgrade to carry into the next match</p>
    <div class="upgrades" id="upgradeGrid"></div>
  </div>
</div>

<!-- Game Over Screen -->
<div id="screenGameOver" class="screen" style="display:none">
  <div class="card">
    <h2 style="color:#ff4444">Tournament Over</h2>
    <p>You were eliminated in <strong id="goRound">Round 1</strong></p>
    <p>Opponents defeated: <strong id="goWins">0</strong></p>
    <p id="goMessage" style="color:var(--muted);margin-top:0.5rem"></p>
    <div style="margin-top:1rem"><button class="btn" id="btnRetry">Try Again</button></div>
  </div>
</div>

<!-- Champion Screen -->
<div id="screenChampion" class="screen" style="display:none">
  <div class="card">
    <h1 style="color:var(--accent3)">Champion!</h1>
    <p style="color:var(--accent3);font-size:1rem">You conquered the tournament!</p>
    <p style="margin-top:0.5rem">Upgrades collected: <strong id="champUpgrades">0</strong></p>
    <div class="player-buffs" id="champBuffs" style="margin:0.5rem 0"></div>
    <div style="margin-top:1rem"><button class="btn" id="btnNewRun">New Run</button></div>
  </div>
</div>

<!-- Match result flash -->
<div class="match-result" id="matchResult">
  <div class="result-text" id="resultText"></div>
</div>

<script>
(function(){
'use strict';

// ============================================================
// 3D COURT DIMENSIONS (meters, real pickleball proportions)
// Court is 6.1m wide x 13.4m long. Net at center (z=6.7m).
// Kitchen (no-volley) = 2.13m from net each side.
// Player stands at z~0.5 (near side), opponent at z~12.9 (far side).
// ============================================================
const CW = 6.1, CL = 13.4, NET_Z = 6.7, KITCHEN_D = 2.13;
const NET_H = 0.914; // net height in meters
const BALL_RADIUS = 0.037; // ~37mm

// Virtual canvas
const VW = 800, VH = 500;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ============================================================
// 2.5D top-down projection (orthographic court + fake height)
// ============================================================
const COURT_PAD = 44;
let courtScale = 1;
let courtOffsetX = 0;
let courtOffsetY = 0;

function worldToScreen(wx, wz) {
  return {
    x: courtOffsetX + (wx + CW / 2) * courtScale,
    y: courtOffsetY + wz * courtScale
  };
}

// ============================================================
// GAME STATE
// ============================================================
const screenTitle = document.getElementById('screenTitle');
const screenPreMatch = document.getElementById('screenPreMatch');
const screenUpgrade = document.getElementById('screenUpgrade');
const screenGameOver = document.getElementById('screenGameOver');
const screenChampion = document.getElementById('screenChampion');
const matchResultEl = document.getElementById('matchResult');
const hud = document.getElementById('hud');
const slowmoBar = document.getElementById('slowmoBar');

let run = null, matchState = null, upgrades = [];
let mouseClicked = false;
const input = { up:false, down:false, left:false, right:false };
let swingBuffer = 0;
const SWING_BUFFER_MAX = 0.18;
let lastTime = 0, clock = 0;
let gamePhase = 'title';

function inKitchen(z) { return Math.abs(z - NET_Z) <= KITCHEN_D; }

// ============================================================
// OPPONENT GENERATION
// ============================================================
const FIRST_NAMES = ['Crusher','Blitz','Shadow','Viper','Thunder','Spike','Ghost','Havoc','Fury','Ace','Phantom','Storm','Razor','Tank','Nova','Bolt','Fang','Hex','Jinx','Onyx'];
const LAST_NAMES = ['McSmash','Dinkerson','Paddleton','Volleysworth','Spinetti','Dropper','Slicer','Netburn','Courtside','Baseline'];
const TITLES = ['The Kitchen Dweller','Dink Master','Power Server','Spin Doctor','Net Ninja','The Lob King','Baseline Brawler','Drop Shot Artist','The Wall','Rally Machine','Speed Demon','Angle Grinder','The Finisher','Court Ghost','Paddle Fury'];

function seededRand(seed) {
  let s = seed | 0;
  return () => { s |= 0; s = s + 0x6D2B79F5 | 0; let t = Math.imul(s ^ s >>> 15, 1 | s); t ^= t + Math.imul(t ^ t >>> 7, 61 | t); return ((t ^ t >>> 14) >>> 0) / 4294967296; };
}

function genOpponent(round, seed) {
  const r = seededRand(seed);
  const diff = 0.25 + (round / 7) * 0.7;
  return {
    name: FIRST_NAMES[Math.floor(r() * FIRST_NAMES.length)] + ' ' + LAST_NAMES[Math.floor(r() * LAST_NAMES.length)],
    title: TITLES[Math.floor(r() * TITLES.length)],
    speed: 2.5 + diff * 3.5,       // lateral m/s
    reaction: 0.3 - diff * 0.2,     // seconds delay
    accuracy: 0.4 + diff * 0.5,     // 0-1
    aggression: 0.3 + r() * 0.5,
    spinSkill: diff * 0.8,
    reachRadius: 0.8 + diff * 0.3,  // how far they can lunge
    color: `hsl(${Math.floor(r()*360)}, 70%, 55%)`,
    seed
  };
}

// ============================================================
// UPGRADES
// ============================================================
const ALL_UPGRADES = [
  { id:'bigger_paddle', icon:'ðŸ“', name:'Mega Paddle', desc:'+35% reach radius', effect:s=>{s.reachMult*=1.35} },
  { id:'power_shots', icon:'ðŸ’¥', name:'Power Shots', desc:'+25% shot speed', effect:s=>{s.powerMult*=1.25} },
  { id:'slowmo', icon:'â³', name:'Slow-Mo', desc:'Spacebar slows time (3s)', effect:s=>{s.hasSlowmo=true;s.slowmoMax+=3} },
  { id:'speed_up', icon:'âš¡', name:'Quick Feet', desc:'+30% move speed', effect:s=>{s.speedMult*=1.3} },
  { id:'spin_master', icon:'ðŸŒ€', name:'Spin Master', desc:'Shots curve more', effect:s=>{s.spinPower+=0.5} },
  { id:'magnet', icon:'ðŸ§²', name:'Ball Magnet', desc:'Wider auto-hit zone', effect:s=>{s.reachMult*=1.2} },
  { id:'intimidate', icon:'ðŸ‘', name:'Intimidate', desc:'Opponent 15% slower', effect:s=>{s.oppDebuff*=0.85} },
  { id:'second_wind', icon:'ðŸ’¨', name:'Second Wind', desc:'+2 points needed to lose', effect:s=>{s.bonusHP+=2} },
  { id:'precise', icon:'ðŸŽ¯', name:'Precision', desc:'Better aim control', effect:s=>{s.aimMult*=1.3} },
  { id:'wall', icon:'ðŸ§±', name:'The Wall', desc:'Reach + speed boost', effect:s=>{s.reachMult*=1.15;s.speedMult*=1.15} },
  { id:'fire_serve', icon:'ðŸ”¥', name:'Fire Serve', desc:'Serves 40% faster', effect:s=>{s.serveMult*=1.4} },
  { id:'ghost_ball', icon:'ðŸ‘»', name:'Ghost Ball', desc:'Ball flickers for opponent', effect:s=>{s.ghostBall=true} },
];

function pickUpgradeChoices(existing) {
  const pool = ALL_UPGRADES.filter(u => {
    const count = existing.filter(e => e.id === u.id).length;
    if (u.id === 'slowmo' && count >= 1) return false;
    if (u.id === 'ghost_ball' && count >= 1) return false;
    if (u.id === 'second_wind' && count >= 2) return false;
    if (count >= 3) return false;
    return true;
  });
  for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }
  return pool.slice(0, 3);
}

function computePlayerStats(list) {
  const s = { reachMult:1, powerMult:1, speedMult:1, spinPower:0, oppDebuff:1, bonusHP:0, aimMult:1, serveMult:1, hasSlowmo:false, slowmoMax:0, ghostBall:false };
  for (const u of list) { const d = ALL_UPGRADES.find(a => a.id === u.id); if (d) d.effect(s); }
  return s;
}

// ============================================================
// AUDIO
// ============================================================
const Sfx = (() => {
  let actx = null, master = null;
  function ensure() { if (actx) return; actx = new (window.AudioContext || window.webkitAudioContext)(); master = actx.createGain(); master.gain.value = 0.18; master.connect(actx.destination); }
  function play(freq, dur, type='square', vol=0.5) { if (!actx) return; const o = actx.createOscillator(); o.type = type; const g = actx.createGain(); o.frequency.setValueAtTime(freq, actx.currentTime); g.gain.setValueAtTime(vol, actx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur); o.connect(g); g.connect(master); o.start(); o.stop(actx.currentTime + dur + 0.02); }
  return {
    unlock() { ensure(); },
    hit() { play(660, 0.06, 'square', 0.35); play(990, 0.04, 'triangle', 0.2); },
    bounce() { play(280, 0.05, 'triangle', 0.25); },
    net() { play(150, 0.15, 'sawtooth', 0.2); },
    score() { play(880, 0.12, 'square', 0.4); setTimeout(() => play(1100, 0.15, 'square', 0.35), 80); },
    lose() { play(200, 0.3, 'sawtooth', 0.35); setTimeout(() => play(150, 0.35, 'sawtooth', 0.25), 120); },
    win() { play(660, 0.1, 'square', 0.35); setTimeout(() => play(880, 0.1, 'square', 0.35), 80); setTimeout(() => play(1100, 0.12, 'square', 0.4), 160); },
    serve() { play(440, 0.08, 'triangle', 0.3); },
    upgrade() { play(523, 0.08, 'square', 0.3); setTimeout(() => play(659, 0.08, 'square', 0.3), 70); setTimeout(() => play(784, 0.12, 'square', 0.35), 140); },
    slowmo() { play(180, 0.5, 'sine', 0.2); },
    swing() { play(300, 0.04, 'sawtooth', 0.15); }
  };
})();

// ============================================================
// MATCH STATE
// Ball: 3D position (x across court, y up, z depth along court)
// Player at z~0.5, opponent at z~12.9
// ============================================================
const WIN_SCORE_BASE = 5;
const GRAVITY = 9.8;
const BALL_SPEED_BASE = 9; // m/s base shot speed
const SERVE_SPEED = 7;

function createMatch(opp, stats, roundIdx) {
  const winScore = WIN_SCORE_BASE + Math.floor(roundIdx / 3);
  return {
    opp, stats, winScore,
    loseScore: winScore + stats.bonusHP,
    p1Score: 0, p2Score: 0,

    // Player position (x lateral on near side)
    player: { x: 0, z: 1.2, reachR: 0.9 * stats.reachMult, speed: 4.5 * stats.speedMult },

    // Opponent position (x lateral on far side)
    enemy: { x: 0, z: CL - 1.2, targetX: 0, targetZ: CL - 1.2, reactionTimer: 0, reachR: opp.reachRadius * (opp.accuracy * 0.5 + 0.7), speed: opp.speed * stats.oppDebuff, swingAnim: 0 },

    // Ball 3D
    ball: {
      x: 0, y: 1.0, z: 1.0,
      vx: 0, vy: 0, vz: 0,
      active: false, bounced: false, // must bounce once per side in pickleball
      lastHitBy: 'none', // 'p1' or 'p2'
      trail: [], ghost: 1, spin: 0
    },

    // Serve
    serving: 'p1',
    serveTimer: 1.0,
    serveReady: false,
    autoServeTimer: 0,

    // Slow-mo
    slowmoCharge: stats.hasSlowmo ? stats.slowmoMax : 0,
    slowmoActive: false,
    slowmoMax: stats.slowmoMax,

    // Particles (3D)
    particles: [],

    // Point flash
    pointFlash: 0, pointText: '',

    // Rally
    rallyCount: 0,

    // Player swing animation
    playerSwingAnim: 0,

    // State: 'serving', 'play', 'point-pause'
    playState: 'serving'
  };
}

function resetBall(m) {
  const isP1 = m.serving === 'p1';
  m.ball.x = isP1 ? m.player.x : m.enemy.x;
  m.ball.y = 1.0;
  m.ball.z = isP1 ? m.player.z + 0.35 : m.enemy.z - 0.35;
  m.ball.vx = 0; m.ball.vy = 0; m.ball.vz = 0;
  m.ball.active = false; m.ball.bounced = false;
  m.ball.lastHitBy = 'none'; m.ball.trail = []; m.ball.spin = 0;
  m.serveTimer = 0.8;
  m.serveReady = false;
  m.autoServeTimer = 0;
  m.rallyCount = 0;
  m.playState = 'serving';
}

function serveBall(m) {
  const isP1 = m.serving === 'p1';
  const speed = SERVE_SPEED * (isP1 ? m.stats.serveMult : 1);
  const dir = isP1 ? 1 : -1;
  // Serve diagonally across the court
  const lateralAim = (Math.random() - 0.5) * 1.5;
  m.ball.x = isP1 ? m.player.x : m.enemy.x;
  m.ball.y = 1.3;
  m.ball.z = isP1 ? m.player.z + 0.35 : m.enemy.z - 0.35;
  m.ball.vx = lateralAim;
  m.ball.vy = 2.5; // slight arc up
  m.ball.vz = dir * speed;
  m.ball.active = true;
  m.ball.bounced = false;
  m.ball.lastHitBy = isP1 ? 'p1' : 'p2';
  m.ball.spin = 0;
  m.playState = 'play';
  Sfx.serve();
}

// ============================================================
// PHYSICS
// ============================================================
function updateMatch(m, dt) {
  if (m.playState === 'point-pause') {
    m.pointFlash -= dt;
    if (m.pointFlash <= 0) m.pointFlash = 0;
    updateParticles(m, dt);
    return;
  }

  swingBuffer = Math.max(0, swingBuffer - dt);

  // Slow-mo
  let timeScale = 1;
  if (m.slowmoActive && m.slowmoCharge > 0) {
    timeScale = 0.3;
    m.slowmoCharge -= dt;
    if (m.slowmoCharge <= 0) { m.slowmoCharge = 0; m.slowmoActive = false; }
  } else if (m.stats.hasSlowmo && !m.slowmoActive && m.slowmoCharge < m.slowmoMax) {
    m.slowmoCharge += dt * 0.4;
    if (m.slowmoCharge > m.slowmoMax) m.slowmoCharge = m.slowmoMax;
  }
  if (m.stats.hasSlowmo) {
    slowmoBar.style.display = 'block';
    document.getElementById('slowmoFill').style.width = ((m.slowmoCharge / m.slowmoMax) * 100) + '%';
  }
  const sDt = dt * timeScale;

  // Serve logic
  if (m.playState === 'serving') {
    m.serveTimer -= sDt;
    if (m.serveTimer <= 0 && !m.serveReady) {
      m.serveReady = true;
      m.autoServeTimer = 0;
    }
    if (m.serveReady) {
      if (m.serving === 'p1') {
        m.autoServeTimer += sDt;
        // Auto-serve on click or after 2s
        if (mouseClicked || swingBuffer > 0 || m.autoServeTimer > 2.0) {
          mouseClicked = false;
          swingBuffer = 0;
          serveBall(m);
        }
      } else {
        m.autoServeTimer += sDt;
        if (m.autoServeTimer > 0.4 + Math.random() * 0.3) {
          serveBall(m);
        }
      }
    }
  }

  // Player movement: 2D movement on own side (WASD/Arrows)
  {
    const moveX = (input.right ? 1 : 0) - (input.left ? 1 : 0);
    const moveZ = (input.down ? 1 : 0) - (input.up ? 1 : 0);
    const len = Math.hypot(moveX, moveZ) || 1;
    m.player.x += (moveX / len) * m.player.speed * sDt;
    m.player.z += (moveZ / len) * m.player.speed * sDt;
    m.player.x = clamp(m.player.x, -CW / 2, CW / 2);
    m.player.z = clamp(m.player.z, 0.45, NET_Z - 0.2);
  }

  // Opponent AI
  updateEnemyAI(m, sDt);

  // Swing anims
  if (m.playerSwingAnim > 0) m.playerSwingAnim -= sDt * 4;
  if (m.enemy.swingAnim > 0) m.enemy.swingAnim -= sDt * 4;

  if (!m.ball.active) { updateParticles(m, sDt); return; }

  // Ball physics
  m.ball.vy -= GRAVITY * sDt;
  // Apply spin as lateral curve
  m.ball.vx += m.ball.spin * 3 * sDt;
  m.ball.spin *= (1 - 1.5 * sDt);

  m.ball.x += m.ball.vx * sDt;
  m.ball.y += m.ball.vy * sDt;
  m.ball.z += m.ball.vz * sDt;

  // Ghost ball flicker (opponent sees it flickering, visually we show it)
  m.ball.ghost = m.stats.ghostBall ? (Math.sin(clock * 18) > 0.2 ? 1 : 0.2) : 1;

  // Trail
  m.ball.trail.push({ x: m.ball.x, y: m.ball.y, z: m.ball.z, t: 1 });
  if (m.ball.trail.length > 15) m.ball.trail.shift();
  for (const tr of m.ball.trail) tr.t -= sDt * 4;

  // Ground bounce
  if (m.ball.y <= BALL_RADIUS) {
    m.ball.y = BALL_RADIUS;
    if (!m.ball.bounced) {
      m.ball.bounced = true;
      m.ball.vy = Math.abs(m.ball.vy) * 0.55; // damped bounce
      Sfx.bounce();
      spawnParticles(m, m.ball.x, 0.05, m.ball.z, 4, '#86efac');
    } else {
      // Second bounce = point!
      m.ball.vy = Math.abs(m.ball.vy) * 0.3;
      Sfx.bounce();
      // Determine who scores
      if (m.ball.z > NET_Z) {
        // Bounced on opponent's side twice = player scores
        scorePoint(m, 'p1');
      } else {
        // Bounced on player's side twice = opponent scores
        scorePoint(m, 'p2');
      }
      updateParticles(m, sDt);
      return;
    }
  }

  // Side walls (out of bounds laterally)
  if (Math.abs(m.ball.x) > CW / 2 + 0.5) {
    // Out of bounds - point for the other side
    if (m.ball.lastHitBy === 'p1') { scorePoint(m, 'p2'); }
    else { scorePoint(m, 'p1'); }
    updateParticles(m, sDt);
    return;
  }

  // Out of bounds depth (past baseline)
  if (m.ball.z < -0.5) {
    scorePoint(m, 'p2');
    updateParticles(m, sDt);
    return;
  }
  if (m.ball.z > CL + 0.5) {
    scorePoint(m, 'p1');
    updateParticles(m, sDt);
    return;
  }

  // Net collision: ball crossing net plane
  if (m.ball.vz > 0 && m.ball.z >= NET_Z - 0.05 && m.ball.z <= NET_Z + 0.15 && m.ball.y < NET_H) {
    // Hit the net going forward
    m.ball.vz *= -0.3;
    m.ball.vy = Math.abs(m.ball.vy) * 0.2 + 0.5;
    m.ball.z = NET_Z - 0.06;
    Sfx.net();
    spawnParticles(m, m.ball.x, m.ball.y, NET_Z, 6, '#ccccaa');
  }
  if (m.ball.vz < 0 && m.ball.z <= NET_Z + 0.05 && m.ball.z >= NET_Z - 0.15 && m.ball.y < NET_H) {
    m.ball.vz *= -0.3;
    m.ball.vy = Math.abs(m.ball.vy) * 0.2 + 0.5;
    m.ball.z = NET_Z + 0.06;
    Sfx.net();
    spawnParticles(m, m.ball.x, m.ball.y, NET_Z, 6, '#ccccaa');
  }

  // Player hit: ball is on player's side, moving toward player, close enough
  if (m.ball.lastHitBy !== 'p1' && m.ball.z < NET_Z && m.ball.z < 3.0 && m.ball.y < 2.0) {
    const dx = m.ball.x - m.player.x;
    const dz = m.ball.z - m.player.z;
    const dist = Math.max(0.001, Math.sqrt(dx * dx + dz * dz));
    // Auto-hit if close, or click-hit with larger radius
    const swingNow = mouseClicked || swingBuffer > 0;
    const hitR = m.player.reachR * (swingNow ? 1.3 : 0.95);
    if (dist < hitR && m.ball.y < 1.8) {
      playerHit(m);
      mouseClicked = false;
      swingBuffer = 0;
    }
  }

  // Enemy hit: ball on opponent's side
  if (m.ball.lastHitBy !== 'p2' && m.ball.z > NET_Z && m.ball.z > CL - 3.5 && m.ball.y < 2.0) {
    const dx = m.ball.x - m.enemy.x;
    const dz = m.ball.z - m.enemy.z;
    const dist = Math.max(0.001, Math.sqrt(dx * dx + dz * dz));
    if (dist < m.enemy.reachR && m.ball.y < 1.8) {
      enemyHit(m);
    }
  }

  // Air drag (very slight)
  const spd = Math.sqrt(m.ball.vx * m.ball.vx + m.ball.vy * m.ball.vy + m.ball.vz * m.ball.vz);
  if (spd > 0.1) {
    const drag = 0.015 * spd;
    const ratio = Math.max(0, 1 - drag * sDt);
    m.ball.vx *= ratio; m.ball.vz *= ratio;
  }

  updateParticles(m, sDt);
}

function playerHit(m) {
  if (!m.ball.bounced && inKitchen(m.player.z)) {
    scorePoint(m, 'p2');
    return;
  }
  m.playerSwingAnim = 1;
  m.ball.lastHitBy = 'p1';
  m.ball.bounced = false;
  m.rallyCount++;
  Sfx.hit();

  // Aim in 2.5D: movement direction biases shot placement.
  const moveX = (input.right ? 1 : 0) - (input.left ? 1 : 0);
  const moveZ = (input.down ? 1 : 0) - (input.up ? 1 : 0);
  const aimDepth = clamp(0.7 - (moveZ * 0.25), 0.15, 0.95);
  const targetZ = NET_Z + 0.9 + aimDepth * (CL - NET_Z - 1.4);
  const aimLateral = clamp((m.player.x / (CW / 2)) * 0.45 + moveX * 0.35, -1, 1) * m.stats.aimMult;
  const targetX = aimLateral * CW * 0.48;

  const speed = BALL_SPEED_BASE * m.stats.powerMult * (0.9 + m.rallyCount * 0.015);
  const dx = targetX - m.ball.x;
  const dz = targetZ - m.ball.z;
  const dist = Math.max(0.001, Math.sqrt(dx * dx + dz * dz));
  const arc = 2.5 + (1 - aimDepth) * 2.0; // higher arc for drop shots

  m.ball.vx = (dx / dist) * speed * 0.35;
  m.ball.vz = (dz / dist) * speed;
  m.ball.vy = arc;

  // Apply spin upgrade
  if (m.stats.spinPower > 0) {
    m.ball.spin = aimLateral * m.stats.spinPower * 2;
  }

  spawnParticles(m, m.ball.x, m.ball.y, m.ball.z, 5, '#49d0ff');
}

function enemyHit(m) {
  if (!m.ball.bounced && inKitchen(m.enemy.z)) {
    scorePoint(m, 'p1');
    return;
  }
  m.enemy.swingAnim = 1;
  m.ball.lastHitBy = 'p2';
  m.ball.bounced = false;
  m.rallyCount++;
  Sfx.hit();

  const opp = m.opp;
  // AI aim: target a spot on player's side
  const targetZ = 0.55 + Math.random() * (NET_Z - 1.1);
  const targetX = (Math.random() - 0.5) * CW * opp.accuracy;
  const speed = BALL_SPEED_BASE * (0.8 + opp.aggression * 0.4) * (0.9 + m.rallyCount * 0.01);

  const dx = targetX - m.ball.x;
  const dz = targetZ - m.ball.z;
  const dist = Math.max(0.001, Math.sqrt(dx * dx + dz * dz));
  const arc = 2.0 + Math.random() * 2.0;

  m.ball.vx = (dx / dist) * speed * 0.35;
  m.ball.vz = (dz / dist) * speed;
  m.ball.vy = arc;

  if (opp.spinSkill > 0.3) {
    m.ball.spin = (Math.random() - 0.5) * opp.spinSkill;
  }

  // Ghost ball debuff: AI sometimes misjudges
  if (m.stats.ghostBall && Math.random() < 0.15) {
    m.ball.vx += (Math.random() - 0.5) * 2;
  }

  spawnParticles(m, m.ball.x, m.ball.y, m.ball.z, 5, m.opp.color);
}

function updateEnemyAI(m, dt) {
  const opp = m.opp;
  const e = m.enemy;

  let targetX = 0;
  let targetZ = CL - 1.2;
  if (m.ball.active && m.ball.vz > 0) {
    // Ball coming toward opponent - predict intercept
    const timeToArrive = Math.max(0.1, (e.z - m.ball.z) / Math.max(0.1, m.ball.vz));
    targetX = m.ball.x + m.ball.vx * timeToArrive;
    targetZ = clamp(m.ball.z + m.ball.vz * timeToArrive, NET_Z + 0.25, CL - 0.35);
    targetX += (Math.random() - 0.5) * (1 - opp.accuracy) * 2.5;
  } else if (m.ball.active && m.ball.vz < 0) {
    targetX = (Math.random() - 0.5) * 1.0;
    targetZ = CL - 1.1 + (Math.random() - 0.5) * 0.5;
  }

  e.reactionTimer -= dt;
  if (e.reactionTimer <= 0) {
    e.targetX = targetX;
    e.targetZ = targetZ;
    e.reactionTimer = opp.reaction * (0.7 + Math.random() * 0.6);
  }

  const maxMove = e.speed * dt;
  const dx = e.targetX - e.x;
  const dz = e.targetZ - e.z;
  const len = Math.hypot(dx, dz);
  if (len > 0.001) {
    const step = Math.min(maxMove, len);
    e.x += (dx / len) * step;
    e.z += (dz / len) * step;
  }
  e.x = clamp(e.x, -CW / 2, CW / 2);
  e.z = clamp(e.z, NET_Z + 0.2, CL - 0.2);
}

// ============================================================
// PARTICLES (3D)
// ============================================================
function spawnParticles(m, x, y, z, count, color) {
  for (let i = 0; i < count; i++) {
    m.particles.push({
      x, y: y + 0.05, z,
      vx: (Math.random() - 0.5) * 2,
      vy: Math.random() * 2 + 0.5,
      vz: (Math.random() - 0.5) * 2,
      life: 0.3 + Math.random() * 0.3,
      color
    });
  }
}

function updateParticles(m, dt) {
  for (let i = m.particles.length - 1; i >= 0; i--) {
    const p = m.particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt; p.z += p.vz * dt;
    p.vy -= 6 * dt;
    p.life -= dt;
    if (p.life <= 0) m.particles.splice(i, 1);
  }
}

// ============================================================
// SCORING
// ============================================================
function scorePoint(m, who) {
  m.ball.active = false;
  m.playState = 'point-pause';
  if (who === 'p1') {
    m.p1Score++;
    m.pointText = 'POINT!';
    Sfx.score();
  } else {
    m.p2Score++;
    m.pointText = 'FAULT';
    Sfx.lose();
  }
  m.pointFlash = 1.5;
  document.getElementById('scoreP1').textContent = m.p1Score;
  document.getElementById('scoreP2').textContent = m.p2Score;

  spawnParticles(m, m.ball.x, m.ball.y, m.ball.z, 10, who === 'p1' ? '#49d0ff' : '#ff6b4a');

  if (m.p1Score >= m.winScore) {
    setTimeout(() => endMatch(true), 1200);
    return;
  }
  if (m.p2Score >= m.loseScore) {
    setTimeout(() => endMatch(false), 1200);
    return;
  }

  m.serving = m.serving === 'p1' ? 'p2' : 'p1';
  document.getElementById('hudServe').textContent = m.serving === 'p1' ? 'YOU' : 'OPP';
  setTimeout(() => resetBall(m), 1000);
}

// ============================================================
// RENDERING - 2.5D top-down
// ============================================================
function drawGame(m) {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.scale(canvas.width / VW, canvas.height / VH);

  const bg = ctx.createLinearGradient(0, 0, 0, VH);
  bg.addColorStop(0, '#0a1424');
  bg.addColorStop(1, '#05080f');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, VW, VH);

  drawCourtSurface();
  drawNet();

  if (m) {
    drawOpponent(m);

    for (const tr of m.ball.trail) {
      if (tr.t <= 0) continue;
      const pt = worldToScreen(tr.x, tr.z);
      const trY = pt.y - tr.y * 18;
      ctx.globalAlpha = tr.t * 0.25 * (m.ball.ghost || 1);
      ctx.fillStyle = '#ffe033';
      const r = clamp((BALL_RADIUS * 85 + tr.y * 2) * tr.t, 1, 10);
      ctx.beginPath(); ctx.arc(pt.x, trY, r, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    if (m.ball.active || m.serveReady) {
      drawBallShadow(m);
      const bp = worldToScreen(m.ball.x, m.ball.z);
      const by = bp.y - m.ball.y * 18;
      const br = clamp(BALL_RADIUS * 90 + m.ball.y * 2, 3, 12);
      ctx.globalAlpha = m.ball.ghost;
      ctx.shadowColor = '#ffe033';
      ctx.shadowBlur = 10;
      ctx.fillStyle = '#ffe033';
      ctx.beginPath(); ctx.arc(bp.x, by, br, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }

    drawPlayerPaddle(m);

    for (const p of m.particles) {
      const pp = worldToScreen(p.x, p.z);
      ctx.globalAlpha = clamp(p.life / 0.3, 0, 1);
      ctx.fillStyle = p.color;
      const sz = clamp(2 + p.y * 2, 1, 6);
      ctx.fillRect(pp.x - sz / 2, pp.y - p.y * 10 - sz / 2, sz, sz);
    }
    ctx.globalAlpha = 1;
  }

  if (m && m.slowmoActive && m.slowmoCharge > 0) {
    ctx.fillStyle = 'rgba(73,208,255,0.08)';
    ctx.fillRect(0, 0, VW, VH);
  }

  if (m && m.pointFlash > 0) {
    ctx.globalAlpha = Math.min(1, m.pointFlash);
    ctx.fillStyle = m.pointText === 'POINT!' ? '#49d0ff' : '#ff6b4a';
    ctx.font = 'bold 40px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(m.pointText, VW / 2, VH * 0.35);
    ctx.globalAlpha = 1;
  }

  if (m && m.rallyCount > 3 && m.ball.active) {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.font = '12px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('RALLY x' + m.rallyCount, VW / 2, 36);
  }

  if (m && m.playState === 'serving' && m.serveReady && m.serving === 'p1') {
    ctx.globalAlpha = 0.6 + Math.sin(clock * 6) * 0.3;
    ctx.fillStyle = '#49d0ff';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CLICK TO SERVE', VW / 2, VH * 0.9);
    ctx.globalAlpha = 1;
  }

  // CRT tint + vignette to preserve retro vibe
  const crtTint = ctx.createLinearGradient(0, 0, VW, VH);
  crtTint.addColorStop(0, 'rgba(73,208,255,0.04)');
  crtTint.addColorStop(0.5, 'rgba(255,138,61,0.02)');
  crtTint.addColorStop(1, 'rgba(134,239,172,0.04)');
  ctx.fillStyle = crtTint;
  ctx.fillRect(0, 0, VW, VH);

  const vig = ctx.createRadialGradient(VW / 2, VH / 2, VW * 0.2, VW / 2, VH / 2, VW * 0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, VW, VH);

  ctx.restore();
}

function drawCourtSurface() {
  const w = CW * courtScale;
  const h = CL * courtScale;
  ctx.fillStyle = '#195f2a';
  ctx.fillRect(courtOffsetX, courtOffsetY, w, h);

  // Kitchen zones
  ctx.fillStyle = 'rgba(255,138,61,0.10)';
  const nearY = courtOffsetY + (NET_Z - KITCHEN_D) * courtScale;
  const farY = courtOffsetY + NET_Z * courtScale;
  ctx.fillRect(courtOffsetX, nearY, w, KITCHEN_D * courtScale);
  ctx.fillRect(courtOffsetX, farY, w, KITCHEN_D * courtScale);

  ctx.strokeStyle = 'rgba(232,232,208,0.55)';
  ctx.lineWidth = 2;
  ctx.strokeRect(courtOffsetX, courtOffsetY, w, h);

  const centerX = courtOffsetX + w / 2;
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = 'rgba(232,232,208,0.25)';
  ctx.beginPath(); ctx.moveTo(centerX, courtOffsetY); ctx.lineTo(centerX, courtOffsetY + h); ctx.stroke();
  ctx.setLineDash([]);

  ctx.strokeStyle = 'rgba(255,138,61,0.45)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(courtOffsetX, nearY); ctx.lineTo(courtOffsetX + w, nearY);
  ctx.moveTo(courtOffsetX, farY + KITCHEN_D * courtScale); ctx.lineTo(courtOffsetX + w, farY + KITCHEN_D * courtScale);
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.font = '10px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('KITCHEN', centerX, nearY + 14);
  ctx.fillText('KITCHEN', centerX, farY + 14);
}

function drawNet() {
  const y = courtOffsetY + NET_Z * courtScale;
  ctx.strokeStyle = 'rgba(220,220,200,0.75)';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(courtOffsetX, y); ctx.lineTo(courtOffsetX + CW * courtScale, y); ctx.stroke();
}

function drawOpponent(m) {
  const e = m.enemy;
  const p = worldToScreen(e.x, e.z);
  const swing = e.swingAnim > 0 ? Math.sin(e.swingAnim * Math.PI) : 0;

  ctx.fillStyle = m.opp.color;
  ctx.beginPath(); ctx.arc(p.x, p.y, 11, 0, Math.PI * 2); ctx.fill();

  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(shoulder.x + 2, shoulder.y + 2);
  ctx.lineTo(shoulder.x + 14 + swing * 7, shoulder.y - 6 - swing * 7);
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(m.opp.name.split(' ')[0], head.x, head.y - 12);
}

function drawBallShadow(m) {
  const sp = worldToScreen(m.ball.x, m.ball.z, 0);
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = '#000';
  const sr = clamp(8 - m.ball.y * 0.8, 2, 9);
  ctx.beginPath(); ctx.ellipse(sp.x, sp.y, sr, sr * 0.55, 0, 0, Math.PI * 2); ctx.fill();
  ctx.moveTo(p.x + 6, p.y - 2);
  ctx.lineTo(p.x + 15 + swing * 8, p.y - 14);
  ctx.stroke();

  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(m.opp.name.split(' ')[0], p.x, p.y - 16);
}

function drawBallShadow(m) {
  const sp = worldToScreen(m.ball.x, m.ball.z);
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = '#000';
  const sr = clamp(7 - m.ball.y * 0.8, 2, 8);
  ctx.beginPath(); ctx.ellipse(sp.x, sp.y, sr, sr * 0.65, 0, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;
}

function drawPlayerPaddle(m) {
  const p = worldToScreen(m.player.x, m.player.z);
  const swing = m.playerSwingAnim > 0 ? Math.sin(m.playerSwingAnim * Math.PI) : 0;
  const r = 12 * m.stats.reachMult;

  ctx.fillStyle = '#49d0ff';
  ctx.shadowColor = '#49d0ff';
  ctx.shadowBlur = swing > 0.3 ? 10 : 3;
  ctx.beginPath(); ctx.arc(p.x, p.y, r + swing * 4, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;

  ctx.strokeStyle = '#8B6914';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(bodyTop.x - 1, bodyTop.y + 1);
  ctx.lineTo(bodyTop.x + 16 + swing * 8, bodyTop.y - 8 - swing * 8);
  ctx.stroke();
}

// ============================================================
// MATCH FLOW & SCREENS (same as before)
// ============================================================
function endMatch(won) {
  gamePhase = 'match-over';
  if (won) {
    run.bracket[run.currentRound] = 'won';
    Sfx.win();
    showMatchResult('YOU WIN!', true);
    setTimeout(() => { matchResultEl.style.display = 'none'; run.currentRound++; if (run.currentRound >= 7) showChampion(); else showUpgradeScreen(); }, 1800);
  } else {
    run.bracket[run.currentRound] = 'lost';
    Sfx.lose();
    showMatchResult('DEFEATED', false);
    setTimeout(() => { matchResultEl.style.display = 'none'; showGameOver(); }, 2000);
  }
}

function showMatchResult(text, isWin) {
  document.getElementById('resultText').textContent = text;
  document.getElementById('resultText').className = 'result-text ' + (isWin ? 'win-text' : 'lose-text');
  matchResultEl.style.display = 'grid';
}

function hideAllScreens() {
  screenTitle.style.display = 'none'; screenPreMatch.style.display = 'none';
  screenUpgrade.style.display = 'none'; screenGameOver.style.display = 'none';
  screenChampion.style.display = 'none'; matchResultEl.style.display = 'none';
  hud.style.display = 'none'; slowmoBar.style.display = 'none';
}

function startNewRun() {
  Sfx.unlock();
  run = { currentRound: 0, opponents: [], bracket: Array(7).fill('future'), seed: Math.floor(Math.random() * 1e9) };
  upgrades = [];
  for (let i = 0; i < 7; i++) run.opponents.push(genOpponent(i, run.seed + i * 777));
  run.bracket[0] = 'current';
  showPreMatch();
}

function showPreMatch() {
  hideAllScreens(); gamePhase = 'prematch';
  screenPreMatch.style.display = 'grid';
  const opp = run.opponents[run.currentRound];
  document.getElementById('oppName').textContent = opp.name;
  document.getElementById('oppTitle').textContent = '"' + opp.title + '"';
  const statsEl = document.getElementById('oppStats');
  statsEl.innerHTML = '';
  [{name:'SPD',val:opp.speed/6},{name:'ACC',val:opp.accuracy},{name:'AGR',val:opp.aggression},{name:'SPN',val:opp.spinSkill}].forEach(s => {
    const div = document.createElement('div'); div.className = 'stat';
    div.innerHTML = s.name + ' <span class="stat-bar"><span class="stat-fill" style="width:' + Math.round(clamp(s.val,0,1)*100) + '%"></span></span>';
    statsEl.appendChild(div);
  });
  const bracketEl = document.getElementById('bracketDisplay');
  bracketEl.innerHTML = '';
  ['QF1','QF2','QF3','QF4','SF1','SF2','F'].forEach((lbl, i) => {
    const div = document.createElement('div');
    div.className = 'bracket-slot ' + (i === run.currentRound ? 'current' : run.bracket[i]);
    div.textContent = lbl; bracketEl.appendChild(div);
  });
  const buffsEl = document.getElementById('playerBuffs');
  buffsEl.innerHTML = '';
  if (!upgrades.length) buffsEl.innerHTML = '<span style="font-size:0.65rem;color:var(--muted)">No upgrades yet</span>';
  else upgrades.forEach(u => { const sp = document.createElement('span'); sp.className = 'buff'; sp.textContent = u.icon + ' ' + u.name; buffsEl.appendChild(sp); });
  document.getElementById('targetScore').textContent = WIN_SCORE_BASE + Math.floor(run.currentRound / 3);
  document.getElementById('hudRound').textContent = run.currentRound + 1;
  document.getElementById('hudMatch').textContent = ['QF1','QF2','QF3','QF4','SF1','SF2','F'][run.currentRound];
}

function startMatch() {
  hideAllScreens(); hud.style.display = 'flex';
  gamePhase = 'playing';
  const opp = run.opponents[run.currentRound];
  const stats = computePlayerStats(upgrades);
  matchState = createMatch(opp, stats, run.currentRound);
  document.getElementById('scoreP1').textContent = '0';
  document.getElementById('scoreP2').textContent = '0';
  document.getElementById('hudServe').textContent = 'YOU';
  resetBall(matchState);
}

function showUpgradeScreen() {
  hideAllScreens(); gamePhase = 'upgrading'; screenUpgrade.style.display = 'grid';
  const choices = pickUpgradeChoices(upgrades);
  const grid = document.getElementById('upgradeGrid'); grid.innerHTML = '';
  choices.forEach(c => {
    const div = document.createElement('div'); div.className = 'upgrade-card';
    div.innerHTML = '<div class="icon">' + c.icon + '</div><div class="name">' + c.name + '</div><div class="desc">' + c.desc + '</div>';
    div.addEventListener('click', () => { Sfx.upgrade(); upgrades.push({id:c.id,icon:c.icon,name:c.name}); run.bracket[run.currentRound]='current'; showPreMatch(); });
    grid.appendChild(div);
  });
}

function showGameOver() {
  hideAllScreens(); gamePhase = 'gameover'; screenGameOver.style.display = 'grid';
  const rn = ['Quarter-Final 1','Quarter-Final 2','Quarter-Final 3','Quarter-Final 4','Semi-Final 1','Semi-Final 2','Grand Final'];
  document.getElementById('goRound').textContent = rn[run.currentRound];
  document.getElementById('goWins').textContent = run.currentRound;
  const msgs = ['The kitchen claimed another soul...','Your paddle wasn\'t ready.','Dink harder next time.','The tournament continues without you.','Every champion starts with defeat.','The court remembers all.'];
  document.getElementById('goMessage').textContent = msgs[Math.floor(Math.random() * msgs.length)];
}

function showChampion() {
  hideAllScreens(); gamePhase = 'champion'; screenChampion.style.display = 'grid';
  document.getElementById('champUpgrades').textContent = upgrades.length;
  const buffsEl = document.getElementById('champBuffs'); buffsEl.innerHTML = '';
  upgrades.forEach(u => { const sp = document.createElement('span'); sp.className = 'buff'; sp.textContent = u.icon + ' ' + u.name; buffsEl.appendChild(sp); });
}

// ============================================================
// INPUT
// ============================================================
canvas.addEventListener('mousedown', e => { mouseClicked = true; swingBuffer = SWING_BUFFER_MAX; e.preventDefault(); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); }, { passive: false });
canvas.addEventListener('touchstart', e => { e.preventDefault(); mouseClicked = true; swingBuffer = SWING_BUFFER_MAX; }, { passive: false });

window.addEventListener('keydown', e => {
  if (e.code === 'ArrowUp' || e.code === 'KeyW') input.up = true;
  if (e.code === 'ArrowDown' || e.code === 'KeyS') input.down = true;
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = true;
  if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = true;
  if (e.code === 'KeyF') swingBuffer = SWING_BUFFER_MAX;

  if (e.code === 'Space' && matchState && matchState.stats.hasSlowmo && gamePhase === 'playing') {
    if (matchState.slowmoCharge > 0.5) { matchState.slowmoActive = true; Sfx.slowmo(); }
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => {
  if (e.code === 'ArrowUp' || e.code === 'KeyW') input.up = false;
  if (e.code === 'ArrowDown' || e.code === 'KeyS') input.down = false;
  if (e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
  if (e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
  if (e.code === 'Space' && matchState) matchState.slowmoActive = false;
});

// ============================================================
// BUTTON WIRING
// ============================================================
document.getElementById('btnStart').addEventListener('click', startNewRun);
document.getElementById('btnFight').addEventListener('click', startMatch);
document.getElementById('btnRetry').addEventListener('click', startNewRun);
document.getElementById('btnNewRun').addEventListener('click', startNewRun);

// ============================================================
// RESIZE
// ============================================================
function resize() {
  const w = window.innerWidth, h = window.innerHeight;
  const aspect = VW / VH;
  let cw, ch;
  if (w / h > aspect) { ch = h; cw = h * aspect; } else { cw = w; ch = w / aspect; }
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  canvas.width = Math.floor(cw * dpr); canvas.height = Math.floor(ch * dpr);
  canvas.style.width = cw + 'px'; canvas.style.height = ch + 'px';
  courtScale = (VW - COURT_PAD * 2) / CL;
  heightScale = courtScale * 0.95;
  courtOffsetX = (VW - CL * courtScale) / 2;
  sideBaseY = VH - COURT_PAD;
}
window.addEventListener('resize', resize, { passive: true }); resize();

// ============================================================
// UTILS
// ============================================================
function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }

// ============================================================
// MAIN LOOP
// ============================================================
function loop(t) {
  const now = t / 1000;
  const dt = Math.min(0.05, lastTime ? now - lastTime : 0.016);
  lastTime = now; clock += dt;

  if (gamePhase === 'playing' && matchState) {
    updateMatch(matchState, dt);
    drawGame(matchState);
  } else {
    drawGame(null);
  }

  mouseClicked = false; // consume click each frame
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
