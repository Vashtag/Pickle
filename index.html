<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Dusk Drive ‚Äî Disc Golf FP (silhouette, no-GPU)</title>
<style>
  :root{
    /* dusk palette (you can swap per-biome later) */
    --bg1:#a54720; --bg2:#f38e41; --bg3:#ffe6ba; --water:#30160f;
    --fg:#050607; --text:#e6edf3; --muted:#a9b1ba;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(5,6,7,.65); --panel-blur:8px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg3),var(--bg2) 55%,var(--bg1));color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  /* HUD */
  .hud{position:fixed;inset:0;pointer-events:none}
  .row{display:flex;gap:.5rem;align-items:center}
  .topbar{position:absolute;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:.6rem .8rem}
  .chip{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:.4rem .7rem;font-size:.9rem;display:flex;gap:.6rem;align-items:center}
  .chip .label{opacity:.8}
  .chip strong{font-weight:700}
  .wind{gap:.4rem}
  .wind .arrow{width:14px;height:14px;transform-origin:center;display:inline-block}
  .wind .arrow::before{content:"";display:block;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:12px solid var(--accent2);transform:translateY(-2px)}

  .bottombar{position:absolute;left:0;right:0;bottom:0;display:flex;justify-content:center;padding:.7rem}
  .panel{pointer-events:auto;background:var(--panel);backdrop-filter:blur(var(--panel-blur));border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:.55rem .7rem}
  .controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;justify-content:center;max-width:min(1100px,96vw)}
  button.btn{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:.55rem .7rem;border-radius:10px;font-weight:600;letter-spacing:.3px;cursor:pointer}
  button.btn:active{transform:translateY(1px)}
  button.btn[aria-pressed="true"], .seg button[aria-pressed="true"]{outline:2px solid var(--accent);background:rgba(255,138,61,.18)}
  .seg{display:flex;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:12px;overflow:hidden}
  .seg button{border:0;border-right:1px solid rgba(255,255,255,.06);background:transparent;padding:.5rem .7rem;color:var(--text);font-weight:600}
  .seg button:last-child{border-right:0}

  .powermeter{position:absolute;left:50%;bottom:78px;transform:translateX(-50%);width:min(620px,92vw);height:12px;border-radius:999px;background:rgba(255,255,255,.07);overflow:hidden;border:1px solid rgba(255,255,255,.08);display:none}
  .powermeter .fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent3),var(--accent));box-shadow:0 0 12px rgba(255,138,61,.25) inset}
  .powermeter[data-on="1"]{display:block}

  /* Screens */
  .screen{position:fixed;inset:0;background:linear-gradient(180deg,rgba(10,10,10,.72),rgba(10,10,10,.6));display:grid;place-items:center;z-index:2}
  .card{background:var(--panel);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:1rem 1.2rem;max-width:720px;width:min(720px,92vw);text-align:center}
  h1,h2{margin:.2rem 0 .6rem 0}
  h1{font-size:1.6rem}
  .sub{opacity:.85;margin:.3rem 0 1rem 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.6rem;margin-top:.4rem}
  .tag{display:inline-flex;gap:.45rem;align-items:center;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .small{font-size:.9rem;color:var(--muted)}
  #landscapeHint{position:fixed;inset:auto 0 0 0;display:none;justify-content:center}
  #landscapeHint .card{margin:0 auto 12px auto}
  @media (orientation:portrait){ #landscapeHint{display:flex} }

  /* Crosshair */
  .reticle{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:24px;height:24px;border-radius:999px;border:2px solid rgba(255,255,255,.25);box-shadow:0 0 0 2px rgba(0,0,0,.2) inset;pointer-events:none}
  .reticle::after{content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:3px;height:3px;border-radius:50%;background:rgba(255,255,255,.85)}
</style>
</head>
<body>
  <div id="wrap"><canvas id="game" aria-label="Dusk Drive FP game canvas"></canvas></div>
  <div class="reticle" id="reticle" hidden></div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="topbar">
      <div class="row">
        <div class="chip"><span class="label">Hole</span> <strong id="holeNum">1</strong>/<span id="holesTotal">3</span></div>
        <div class="chip"><span class="label">Par</span> <strong id="parLabel">3</strong></div>
        <div class="chip"><span class="label">Strokes</span> <strong id="strokes">0</strong></div>
      </div>
      <div class="row">
        <div class="chip wind"><span class="label">Wind</span> <span id="windVal">0</span><span class="arrow" id="windArrow"></span></div>
        <button class="btn" id="btnSettings" title="Settings" aria-label="Settings">‚öôÔ∏è</button>
      </div>
    </div>

    <div class="bottombar">
      <div class="panel controls">
        <div class="seg" id="clubSeg" role="group" aria-label="Disc select"></div>
        <div class="seg" id="spinSeg" role="group" aria-label="Release angle">
          <button class="btn" data-spin="-1" aria-pressed="false" title="Hyzer (‚àí15¬∞)">Hyzer</button>
          <button class="btn" data-spin="0"  aria-pressed="true"  title="Flat (0¬∞)">Flat</button>
          <button class="btn" data-spin="1"  aria-pressed="false" title="Anhyzer (+15¬∞)">Anhy</button>
        </div>
        <div class="seg" id="handSeg" role="group" aria-label="Throw style">
          <button class="btn" data-hand="RHBH" aria-pressed="true"  title="Right-hand backhand">RHBH</button>
          <button class="btn" data-hand="LHBH" aria-pressed="false" title="Left-hand backhand">LHBH</button>
        </div>
        <button class="btn" id="btnNewRound" title="Restart round">‚Üª Round</button>
      </div>
    </div>

    <div class="powermeter" id="powermeter" aria-hidden="true"><div class="fill" id="powerfill"></div></div>
  </div>

  <!-- Screens -->
  <div id="screenIntro" class="screen" role="dialog" aria-modal="true">
    <div class="card">
      <h1>ü•è Dusk Drive ‚Äî First-Person Disc Golf</h1>
      <div class="sub">Drag to aim (yaw/pitch), hold to charge, release to throw. Minimal silhouette world. No GPU needed.</div>
      <div class="grid">
        <div class="tag">Drivers ‚Ä¢ Mids ‚Ä¢ Putters</div>
        <div class="tag">Lift ‚Ä¢ Drag ‚Ä¢ Turn/Fade</div>
        <div class="tag">Vertical Wind & Geyser</div>
        <div class="tag">Silhouette Landmarks</div>
      </div>
      <p class="small" style="margin-top:.7rem">Tip: keep the aim line just above the horizon for long pushes.</p>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlay">Start Round</button></div>
    </div>
  </div>

  <div id="screenSummary" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Round Complete</h2>
      <p class="sub">Total strokes: <strong id="sumStrokes">0</strong> ‚Ä¢ Par: <strong id="sumPar">0</strong> ‚Ä¢ Score: <strong id="sumScore">E</strong></p>
      <div class="grid" id="holeBreakdown"></div>
      <div style="margin-top:.7rem"><button class="btn" id="btnPlayAgain">Play Again</button></div>
    </div>
  </div>

  <div id="screenSettings" class="screen" style="display:none" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Settings</h2>
      <div class="grid">
        <label class="chip" style="justify-content:space-between">
          <span>Reduced motion</span>
          <input type="checkbox" id="chkReduced" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Audio (ambience & SFX)</span>
          <input type="checkbox" id="chkAudio" />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Wind (toggle)</span>
          <input type="checkbox" id="chkWind" checked />
        </label>
        <label class="chip" style="justify-content:space-between">
          <span>Camera: true first-person</span>
          <input type="checkbox" id="chkFirstPerson" />
        </label>
      </div>
      <p class="small" style="margin-top:.7rem">Accents: <span style="color:var(--accent)">primary</span> ‚Ä¢ <span style="color:var(--accent2)">secondary</span> ‚Ä¢ <span style="color:var(--accent3)">tertiary</span></p>
      <div style="margin-top:.7rem"><button class="btn" id="btnCloseSettings">Close</button></div>
    </div>
  </div>

  <div id="landscapeHint"><div class="card small">For best experience, rotate to landscape.</div></div>

<script>
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ===== UI
  const elHole = document.getElementById('holeNum');
  const elHolesTotal = document.getElementById('holesTotal');
  const elPar = document.getElementById('parLabel');
  const elStrokes = document.getElementById('strokes');
  const elWindVal = document.getElementById('windVal');
  const elWindArrow = document.getElementById('windArrow');
  const elPowermeter = document.getElementById('powermeter');
  const elPowerfill = document.getElementById('powerfill');
  const clubSeg = document.getElementById('clubSeg');
  const spinSeg = document.getElementById('spinSeg');
  const handSeg = document.getElementById('handSeg');
  const reticle = document.getElementById('reticle');

  const screenIntro = document.getElementById('screenIntro');
  const screenSummary = document.getElementById('screenSummary');
  const screenSettings = document.getElementById('screenSettings');
  const btnPlay = document.getElementById('btnPlay');
  const btnPlayAgain = document.getElementById('btnPlayAgain');
  const btnNewRound = document.getElementById('btnNewRound');
  const btnSettings = document.getElementById('btnSettings');
  const btnCloseSettings = document.getElementById('btnCloseSettings');
  const chkReduced = document.getElementById('chkReduced');
  const chkAudio = document.getElementById('chkAudio');
  const chkWind = document.getElementById('chkWind');
  const chkFirstPerson = document.getElementById('chkFirstPerson');

  const sumStrokes = document.getElementById('sumStrokes');
  const sumPar = document.getElementById('sumPar');
  const sumScore = document.getElementById('sumScore');
  const holeBreakdown = document.getElementById('holeBreakdown');

  // ===== Config
  const DPR_MAX = 2;
  let DPR = Math.max(1, Math.min(DPR_MAX, window.devicePixelRatio || 1));
  const HOLES_PER_ROUND = 3; elHolesTotal.textContent = HOLES_PER_ROUND;

  // Discs (higher speed ~ farther; turn negative curves right for RHBH)
  const DISCS = [
    { id:'DRV', name:'Driver',  speed:1.00, glide:1.05, turn:-2.2, fade:2.2 },
    { id:'MID', name:'Mid',     speed:0.85, glide:1.10, turn:-1.2, fade:1.5 },
    { id:'PUT', name:'Putter',  speed:0.70, glide:1.00, turn:-0.3, fade:0.9 }
  ];
  let currentDisc = DISCS[0];

  // Physics scaling (tuned for eye-pleasing arcs on 2D canvas)
  const G = 28;                // gravity
  const DRAG_K = 0.015;        // quadratic drag
  const LIFT_K = 0.050;        // lift factor (scaled by AoA)
  const VREF   = 45;           // reference speed for turn/fade blending
  const SPIN_DECAY = 0.35;     // how quickly turn -> fade over flight

  // Wind (vertical-only for simplicity; UI shows up or down)
  let windOn = true;
  let windLift = 0;            // -1..+1
  const WIND_LIFT_SCALE = 0.45;

  // Release/handedness
  let releaseMode = 0;         // -1 hyzer, 0 flat, +1 anhyzer
  let hand = 'RHBH';

  // Camera & projection
  let canvasW=0, canvasH=0, CX=0, CY=0;
  const FOV_DEG = 72;
  let focal = 600;             // computed on resize
  let firstPersonHard = false; // true = camera exactly on disc; false = gentle chase

  // World / hole
  let holeIndex=0;
  let roundData=null;
  let hole=null;

  // Aim/meter state
  let aiming=false, aimYaw=0, aimPitch=0, meter=0, meterDir=1, meterOn=false;
  let mousePX=0, mousePY=0;

  // Disc state
  const disc = {
    p:{x:0,y:1.5,z:0}, v:{x:0,y:0,z:0},
    r:0.10, // 10 cm radius visual cue
    atRest:true, onGround:true, lastSafe:{x:0,y:1.5,z:0},
    spin0:20, spin:20, bank:0, orientYaw:0, orientPitch:0
  };
  let strokes=0;

  // Scene props
  const objects=[]; // {type, x,y,z, ...}
  const waters=[];  // {x,z,r}
  let geyser=null;  // {x,z,rx,height,strength,phase,speed}

  // Audio (minimal ambience + SFX)
  const AudioMini = (()=>{ let ctx=null, master=null, windG=null, on=false;
    function init(){ if(on) return; ctx = new (window.AudioContext||window.webkitAudioContext)();
      master = ctx.createGain(); master.gain.value=0.16; master.connect(ctx.destination);
      // low warm hum
      const o1 = ctx.createOscillator(); o1.type='sine'; o1.frequency.value=120;
      const o2 = ctx.createOscillator(); o2.type='sine'; o2.frequency.value=240; o2.detune.value=-7;
      const g = ctx.createGain(); g.gain.value=0.05; o1.connect(g); o2.connect(g); g.connect(master); o1.start(); o2.start();
      // wind noise
      const nbuf = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
      const data = nbuf.getChannelData(0); for(let i=0;i<data.length;i++){data[i]=(Math.random()*2-1)*0.6;}
      const nsrc=ctx.createBufferSource(); nsrc.buffer=nbuf; nsrc.loop=true;
      const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=420;
      windG = ctx.createGain(); windG.gain.value=0.05;
      nsrc.connect(lp); lp.connect(windG); windG.connect(master); nsrc.start(); on=true; if(!windOn) windG.gain.value=0;
    }
    return { setEnabled(v){ if(v) init(); else if(master){ master.gain.value=0; } }, setWind(v){ if(windG){ windG.gain.value = v? 0.05 : 0; } }})();
  const Sfx = (()=>{ let enabled=false, unlocked=false; const throws=[],chains=[];
    function mk(p,vol=1){ const a=new Audio(p); a.preload='auto'; a.volume=vol; return a; }
    function preload(){ if(throws.length) return; for(let i=1;i<=7;i++) throws.push(mk(`./audio/throw${i}.mp3`,0.9));
      for(let i=1;i<=4;i++) chains.push(mk(`./audio/chain${i}.mp3`,1.0)); }
    function init(){ preload(); unlocked=true; }
    function setEnabled(v){ enabled=!!v; if(!enabled){ [...throws,...chains].forEach(a=>{try{a.pause();a.currentTime=0;}catch{}}); } }
    function play(arr,vol=1, rmin=0.98,rmax=1.02){ if(!enabled||!unlocked||!arr.length) return; const i=(Math.random()*arr.length)|0; const src=arr[i].src||arr[i].currentSrc; const a=new Audio(src); a.preload='auto'; a.volume=vol; a.playbackRate=rmin+Math.random()*(rmax-rmin); a.play().catch(()=>{}); }
    return { init, setEnabled, playThrow(){play(throws,0.9,0.97,1.06)}, playChain(){play(chains,1.0,0.96,1.04)} };
  })();

  // ===== Helpers
  const TAU = Math.PI*2;
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const ease=(t)=>t*t*(3-2*t);
  function rand(seed){ let x=seed|0; return ()=>{ x|=0; x ^= x>>>16; x = Math.imul(x, 0x7feb352d); x ^= x>>>15; x = Math.imul(x, 0x846ca68b); x ^= x>>>16; return (x>>>0)/4294967295; }; }

  // ===== Hole generation (simple forward fairway with decor)
  function genHole(){
    const r = rand((Math.random()*1e9)|0);
    const dist = 110 + r()*80;                // meters to basket
    const par  = dist>170?5: (dist>130?4:3);
    const leftSpan = 25, rightSpan = 25;      // fairway half-widths visually
    objects.length = 0; waters.length = 0; geyser = null;

    // Water patches (0‚Äì2 shallow pools)
    const waterN = (r()<0.6)?1:0;
    for(let i=0;i<waterN;i++){
      const wz = dist*(0.35 + r()*0.25);
      const wx = (r()<0.5? -1:1) * (8 + r()*18);
      const rr = 6 + r()*10;
      waters.push({x:wx,z:wz,r:rr});
    }

    // Landmarks: a few trees and one windmill
    const treeN = 10 + (r()*8|0);
    for(let i=0;i<treeN;i++){
      const tz = r()*dist*0.95 + 10;
      const side = (r()<0.5?-1:1);
      const tx = side*(12 + r()*28);
      const h  = 6 + r()*10;
      objects.push({type:'tree', x:tx, y:0, z:tz, h});
    }
    if(r()<0.9){
      const wz = dist*(0.6 + r()*0.25);
      const wx = (r()<0.5? -1:1) * (20 + r()*24);
      objects.push({type:'windmill', x:wx, y:0, z:wz, h:18 + r()*10, r:4 + r()*2, spin:r()*TAU});
    }

    // Geyser (updraft)
    if(r()<0.75){
      const gz = dist*(0.45 + r()*0.15);
      const gx = (r()<0.5?-1:1)* (4 + r()*8);
      geyser = { x:gx, z:gz, rx:6 + r()*4, height:22 + r()*12, strength:0.65, phase:r()*TAU, speed:0.8 + r()*0.8 };
    }

    // Basket
    const basket = { x:0, y:0, z:dist, pole:2.2, rimY:1.1, rimR:0.17 };

    // Tee reset
    disc.p = {x:0, y:1.4, z:0};
    disc.v = {x:0, y:0, z:0};
    disc.atRest = true; disc.onGround = true; strokes=0;
    disc.lastSafe = {...disc.p};

    // Wind (vertical only)
    windLift = windOn ? (Math.random()*2 - 1) : 0;
    updateWindUI();

    return { par, dist, basket, leftSpan, rightSpan, seed:(Math.random()*1e9)|0 };
  }

  // ===== UI build
  function buildDiscs(){
    clubSeg.innerHTML='';
    DISCS.forEach((d,idx)=>{
      const b=document.createElement('button'); b.className='btn'; b.textContent=d.name; b.dataset.disc=idx;
      b.setAttribute('aria-pressed', idx===0? 'true':'false');
      b.onclick=()=>selectDisc(idx);
      clubSeg.appendChild(b);
    });
    selectDisc(0);
  }
  function selectDisc(i){ currentDisc = DISCS[i]; [...clubSeg.querySelectorAll('button')].forEach((b,idx)=> b.setAttribute('aria-pressed', idx===i? 'true':'false')); }
  spinSeg.addEventListener('click', (e)=>{ const btn=e.target.closest('button'); if(!btn) return; releaseMode = parseInt(btn.dataset.spin,10); [...spinSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });
  handSeg.addEventListener('click', (e)=>{ const btn=e.target.closest('button'); if(!btn) return; hand = btn.dataset.hand; [...handSeg.querySelectorAll('button')].forEach(b=> b.setAttribute('aria-pressed', b===btn? 'true':'false')); });

  function updateWindUI(){
    const mag = Math.abs(windOn ? windLift : 0);
    elWindVal.textContent = mag.toFixed(1)+'x';
    const rot = (windLift >= 0 ? 180 : 0);
    elWindArrow.style.transform = `rotate(${rot}deg)`;
  }

  // ===== Input (aim yaw/pitch via pointer)
  function onPointerDown(e){ if(!disc.atRest) return; aiming=true; meterOn=true; meter=0; meterDir=1; elPowermeter.dataset.on='1'; reticle.hidden=false; Sfx.init(); }
  function onPointerMove(e){
    if(!aiming) return;
    const p = e.changedTouches? e.changedTouches[0] : e;
    mousePX = p.clientX; mousePY = p.clientY;
    const nx = (mousePX / canvasW)*2 - 1;     // -1..1
    const ny = (mousePY / canvasH)*2 - 1;
    // map to yaw (-40..+40 deg), pitch (-10..+25 deg)
    aimYaw   = nx * (40*Math.PI/180);
    aimPitch = -ny * (25*Math.PI/180) - (5*Math.PI/180);
  }
  function onPointerUp(){ if(!aiming) return; aiming=false; meterOn=false; elPowermeter.dataset.on='0'; reticle.hidden=true; throwDisc(); }
  function onKey(e){
    if(e.code==='Space'){
      if(disc.atRest && !aiming){ aiming=true; meterOn=true; meter=0; meterDir=1; elPowermeter.dataset.on='1'; reticle.hidden=false; }
      else if(disc.atRest && aiming){ aiming=false; meterOn=false; elPowermeter.dataset.on='0'; reticle.hidden=true; throwDisc(); }
      e.preventDefault();
    }
  }
  canvas.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  canvas.addEventListener('touchstart', onPointerDown, {passive:false});
  window.addEventListener('touchmove', onPointerMove, {passive:false});
  window.addEventListener('touchend', onPointerUp);
  window.addEventListener('keydown', onKey);

  // ===== Throw
  function throwDisc(){
    if(!disc.atRest) return;
    const base = 34; // m/s max-ish (driver)
    const power = (0.25 + 0.75*meter) * currentDisc.speed;
    const speed = base * power;
    const cy = Math.cos(aimYaw), sy = Math.sin(aimYaw);
    const cp = Math.cos(aimPitch), sp = Math.sin(aimPitch);
    // forward dir from yaw/pitch
    const dir = { x: sy*cp, y: sp, z: cy*cp };
    disc.v = { x: dir.x*speed, y: dir.y*speed, z: dir.z*speed };
    disc.atRest=false; disc.onGround=false; strokes++; elStrokes.textContent=strokes;
    disc.spin0 = 16 + 18*power;
    disc.spin = disc.spin0;
    disc.bank = (releaseMode * 16) * Math.PI/180;
    disc.orientYaw = aimYaw; disc.orientPitch = aimPitch;
    Sfx.playThrow();
    if(navigator.vibrate) navigator.vibrate(16);
  }

  // ===== World functions
  function groundYAt(x,z){ // tiny dunes feel; keep mostly flat (y=0 base)
    const k1 = Math.sin(z*0.08)*0.4 + Math.sin(z*0.017+1.2)*0.6;
    const k2 = Math.sin((x*0.12)+z*0.03)*0.15;
    return 0.0 + 0.3*k1 + 0.15*k2;
  }
  function inWater(x,z,y){
    for(const w of waters){
      const dx=x-w.x, dz=z-w.z;
      if(Math.hypot(dx,dz) <= w.r && y <= 0.05) return true;
    }
    return false;
  }

  // ===== Camera
  const cam = { p:{x:0,y:1.6,z:-0.8}, yaw:0, pitch:0, roll:0 };
  function updateCamera(dt){
    if(disc.atRest){
      cam.p = { x: disc.p.x, y: 1.6, z: disc.p.z - 0.8 };
      cam.yaw = aimYaw; cam.pitch = aimPitch*0.5; cam.roll = 0;
    } else {
      // chase or true FP
      const targetYaw = Math.atan2(disc.v.x, disc.v.z);
      const vHoriz = Math.hypot(disc.v.x, disc.v.z);
      const targetPitch = Math.atan2(disc.v.y, vHoriz);
      const lerpF = 1 - Math.exp(-dt*4);
      cam.yaw += (targetYaw - cam.yaw)*lerpF;
      cam.pitch += (targetPitch - cam.pitch)*lerpF;
      cam.roll = -disc.bank*0.4;

      const back = firstPersonHard? 0.02 : 0.9;
      const up   = firstPersonHard? 0.04 : 0.25;
      const cy = Math.cos(cam.yaw), sy = Math.sin(cam.yaw);
      const cp = Math.cos(cam.pitch), sp = Math.sin(cam.pitch);
      // camera behind disc slightly
      const bx = -sy*cp*back, by = -sp*back + up, bz = -cy*cp*back;
      cam.p.x = disc.p.x + bx;
      cam.p.y = disc.p.y + by;
      cam.p.z = disc.p.z + bz;
      if(cam.p.y < groundYAt(cam.p.x,cam.p.z)+0.2) cam.p.y = groundYAt(cam.p.x,cam.p.z)+0.2;
    }
  }

  // ===== Physics
  function horizLen(v){ return Math.hypot(v.x, v.z); }
  function updatePhysics(dt){
    if(meterOn){ meter += meterDir * 1.6 * dt; if(meter>1){meter=1; meterDir=-1}else if(meter<0){meter=0; meterDir=1} elPowerfill.style.width=(meter*100).toFixed(1)+'%'; }

    if(disc.atRest) return;

    // speeds
    const v = Math.hypot(disc.v.x,disc.v.y,disc.v.z) || 1e-6;
    const vH = horizLen(disc.v);

    // Drag (quadratic)
    const drag = DRAG_K * v;
    disc.v.x -= disc.v.x*drag*dt;
    disc.v.y -= disc.v.y*drag*dt;
    disc.v.z -= disc.v.z*drag*dt;

    // Gravity + vertical wind
    let ay = -G;
    if(windOn){ ay += v*v * LIFT_K * (windLift * WIND_LIFT_SCALE * 0.2); }

    // Lift from AoA (nose vs velocity): approximate with pitch difference
    const vYaw = Math.atan2(disc.v.x, disc.v.z);
    const vPitch = Math.atan2(disc.v.y, vH);
    const aoa = clamp((disc.orientPitch - vPitch) + 0.06, -0.6, 0.6);
    ay += v*v * LIFT_K * currentDisc.glide * aoa;

    // Turn/Fade lateral curve (horizontal)
    const tPow = clamp(v / VREF, 0, 1);
    const spinNorm = clamp(disc.spin / (disc.spin0||1), 0, 1);
    const hyz = releaseMode;
    let turnAmt = currentDisc.turn * (tPow*tPow) * (0.7 + 0.6*spinNorm) * (1 + 0.35*hyz);
    let fadeAmt = currentDisc.fade * (1 - tPow) * (0.9 + 0.5*(1 - spinNorm)) * (1 - 0.25*hyz);
    const curve = (turnAmt - fadeAmt) * (hand==='RHBH'?1:-1);

    // lateral accel perpendicular to horizontal velocity
    if(vH > 0.0001){
      const rightX =  disc.v.z / vH;
      const rightZ = -disc.v.x / vH;
      const curveK = 6.5; // tuning
      const aLat = curveK * curve;
      disc.v.x += rightX * aLat * dt;
      disc.v.z += rightZ * aLat * dt;
    }

    // Geyser updraft
    if(geyser){
      // distance in XZ
      const dx = disc.p.x - geyser.x;
      const dz = disc.p.z - geyser.z;
      const d  = Math.hypot(dx, dz);
      const xFall = Math.exp(-0.5*(d*d)/(geyser.rx*geyser.rx));
      const yAbove = disc.p.y - groundYAt(geyser.x, geyser.z);
      const yRatio = clamp(yAbove / geyser.height, 0, 1);
      const profile = xFall * yRatio;
      if(profile > 0){
        const turb = 0.06 * Math.sin(clock*18 + (disc.p.x+disc.p.z)*0.3 + geyser.phase);
        const boost = geyser.strength * profile * (1 + turb);
        ay += v*v * LIFT_K * (Math.abs(aoa) + 0.08) * boost;
      }
    }

    // Integrate
    disc.v.y += ay*dt;
    disc.p.x += disc.v.x*dt;
    disc.p.y += disc.v.y*dt;
    disc.p.z += disc.v.z*dt;

    // Spin decay and nose alignment
    disc.spin *= Math.exp(-SPIN_DECAY*dt);
    // Relax bank over time
    const bankRelax = 0.2 + 0.9*(1 - spinNorm);
    disc.bank += (-disc.bank) * (1 - Math.exp(-dt*bankRelax));
    // Nose bias: faster = nose down slightly
    const noseFast = -6 * Math.PI/180, noseSlow = 7 * Math.PI/180;
    const noseBias = lerp(noseFast, noseSlow, 1 - tPow);
    disc.orientYaw   = vYaw;
    disc.orientPitch += ((vPitch + noseBias) - disc.orientPitch) * (1 - Math.exp(-dt*3.4));

    // Ground collision
    const gy = groundYAt(disc.p.x, disc.p.z);
    if(disc.p.y <= gy + disc.r){
      disc.p.y = gy + disc.r;
      if(Math.abs(disc.v.y) > 2){
        // small bounce unless sand/water (we keep no sand in FP v1 for simplicity)
        disc.v.y = -disc.v.y * 0.2;
        disc.v.x *= 0.85;
        disc.v.z *= 0.85;
      } else {
        // slide
        disc.v.y = 0;
        const fr = 6.5;
        const vh = horizLen(disc.v);
        const dec = fr*dt;
        if(vh > dec){
          const s = dec/vh; disc.v.x *= (1 - s); disc.v.z *= (1 - s);
        } else {
          disc.v.x = disc.v.z = 0;
          disc.atRest = true; disc.onGround=true; disc.lastSafe = {...disc.p};
        }
      }
    } else {
      disc.onGround = false;
    }

    // Water penalty
    if(inWater(disc.p.x,disc.p.z,disc.p.y)){
      if(navigator.vibrate) navigator.vibrate([40,40,30]);
      strokes++; elStrokes.textContent=strokes;
      // drop back a bit
      disc.p = {...disc.lastSafe};
      disc.v = {x:0,y:0,z:0};
      disc.atRest=true; disc.onGround=true;
    } else if(disc.onGround && !inWater(disc.p.x,disc.p.z,disc.p.y)) {
      disc.lastSafe = {...disc.p};
    }

    // Basket catch
    if(checkBasketCatch()){
      Sfx.playChain();
      if(navigator.vibrate) navigator.vibrate([30,40,30]);
      disc.atRest=true; disc.v={x:0,y:0,z:0};
      setTimeout(()=>endHole(), 520);
    }

    // Keep within simple bounds sideways
    if(disc.p.z < -2) disc.p.z = -2;
    if(Math.abs(disc.p.x) > 80){ disc.p.x = clamp(disc.p.x,-80,80); disc.v.x=0; }
  }

  function checkBasketCatch(){
    const b = hole.basket;
    const dx = disc.p.x - b.x;
    const dz = disc.p.z - b.z;
    const dist = Math.hypot(dx,dz);
    if(dist < b.rimR*1.2){
      const vy = disc.v.y;
      if(disc.p.y > (b.rimY-0.15) && disc.p.y < (b.rimY+0.35) && vy < -0.2) return true;
    }
    return false;
  }

  // ===== Round flow
  function newRound(){ holeIndex=0; roundData={ holes:[], totalPar:0, totalStrokes:0 }; screenIntro.style.display='none'; screenSummary.style.display='none'; nextHole(); }
  function nextHole(){
    hole = genHole();
    roundData.holes.push({par:hole.par, strokes:0}); roundData.totalPar += hole.par;
    elHole.textContent = (holeIndex+1); elPar.textContent = hole.par; elStrokes.textContent = (strokes=0);
  }
  function endHole(){
    roundData.holes[holeIndex].strokes = strokes; roundData.totalStrokes += strokes; holeIndex++;
    if(holeIndex>=HOLES_PER_ROUND){
      sumStrokes.textContent = roundData.totalStrokes; sumPar.textContent = roundData.totalPar;
      const diff = roundData.totalStrokes - roundData.totalPar; sumScore.textContent = diff===0? 'E' : (diff>0? '+'+diff : diff);
      holeBreakdown.innerHTML = ''; roundData.holes.forEach((h,i)=>{ const div=document.createElement('div'); div.className='chip'; div.textContent=`Hole ${i+1}: ${h.strokes} (Par ${h.par})`; holeBreakdown.appendChild(div); });
      screenSummary.style.display='grid';
    } else {
      nextHole();
    }
  }

  // ===== Rendering (canvas 2D, faux-3D)
  function toCam(p){
    // Rotate by yaw (around Y) then pitch (around X), then translate
    const dx = p.x - cam.p.x, dy = p.y - cam.p.y, dz = p.z - cam.p.z;
    const cy = Math.cos(-cam.yaw), sy = Math.sin(-cam.yaw);
    let x = dx*cy - dz*sy;
    let z = dx*sy + dz*cy;
    const cp = Math.cos(-cam.pitch), sp = Math.sin(-cam.pitch);
    let y = dy*cp - z*sp;
    z = dy*sp + z*cp;
    return {x,y,z};
  }
  function project(p){
    if(p.z <= 0.05) return null;
    const sx = CX + (focal * (p.x / p.z));
    const sy = CY - (focal * (p.y / p.z));
    return {x:sx, y:sy};
  }

  function draw(){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,canvasW,canvasH);
    drawSky();
    drawSunAndClouds();
    drawHorizonSilhouettes();

    // Ground grid strips (speed lines)
    drawGroundGrid();

    // Water (billboarded ellipses)
    for(const w of waters) drawWaterDisc(w);

    // Geyser
    if(geyser) drawGeyser3D(geyser);

    // Landmarks
    for(const o of objects) drawObject(o);

    // Basket
    drawBasket3D(hole.basket);

    // (Optional) disc nose hint in FP
    if(!disc.atRest && !firstPersonHard) drawNose();

    // Vignette
    drawVignette();
  }

  function drawSky(){
    const g = ctx.createLinearGradient(0,0,0,canvasH);
    const cs = getComputedStyle(document.documentElement);
    g.addColorStop(0,   cs.getPropertyValue('--bg3').trim());
    g.addColorStop(0.55,cs.getPropertyValue('--bg2').trim());
    g.addColorStop(1,   cs.getPropertyValue('--bg1').trim());
    ctx.fillStyle = g; ctx.fillRect(0,0,canvasW,canvasH);
  }
  function drawSunAndClouds(){
    // soft sun halo fixed in screen (distant)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const x = canvasW*0.78, y = canvasH*0.22, r=40;
    const halo = ctx.createRadialGradient(x,y,r*0.6,x,y,r*3.4);
    halo.addColorStop(0,'rgba(255,210,130,0.26)'); halo.addColorStop(1,'rgba(255,210,130,0)');
    ctx.fillStyle=halo; ctx.beginPath(); ctx.arc(x,y,r*3.4,0,TAU); ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle='#fff2cf'; ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
    ctx.restore();

    // two faint cloud bands
    ctx.save();
    ctx.globalAlpha=0.08;
    ctx.fillStyle='#ffffff';
    const band = (yoff, seed)=>{
      ctx.beginPath();
      for(let i=0;i<=canvasW;i+=8){
        const yy = yoff + Math.sin((i*0.012)+clock*0.2 + seed)*6 + Math.sin((i*0.034)+clock*0.07 + seed*2)*3;
        if(i===0) ctx.moveTo(0,yy); else ctx.lineTo(i,yy);
      }
      ctx.lineTo(canvasW,0); ctx.lineTo(0,0); ctx.closePath(); ctx.fill();
    };
    band(canvasH*0.28, 0.6);
    band(canvasH*0.36, 2.1);
    ctx.restore();
  }
  function drawHorizonSilhouettes(){
    // 3 parallax ridges
    const layers = [
      { shade:0.15, k:0.0022, a:22, off:0.0, par:0.05 },
      { shade:0.25, k:0.0028, a:36, off:1.1, par:0.08 },
      { shade:0.35, k:0.0036, a:52, off:2.1, par:0.12 }
    ];
    const cs = getComputedStyle(document.documentElement), fg = cs.getPropertyValue('--fg').trim() || '#050607';
    const baseH = canvasH*0.66;
    layers.forEach((L,idx)=>{
      ctx.fillStyle = `rgba(0,0,0,${L.shade})`;
      ctx.beginPath(); ctx.moveTo(0,canvasH);
      for(let x=0;x<=canvasW;x+=12){
        const u = (x/canvasW);
        const y = baseH + Math.sin((u+clock*0.02+L.off)*TAU)*L.a + Math.sin((u*3.2+L.off*1.7)*TAU)*L.a*0.25;
        ctx.lineTo(x, y + idx*8);
      }
      ctx.lineTo(canvasW,canvasH); ctx.closePath(); ctx.fill();
    });
  }

  function drawGroundGrid(){
    // project a set of parallel strips at y=0 plane
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(0,0,0,0.85)';
    const near = 0.5, far = 180;
    // horizontal stripes (z slices)
    for(let z=2; z<far; z+=2){
      const p0 = project(toCam({x:-80, y:groundYAt(0,z), z}));
      const p1 = project(toCam({x: 80, y:groundYAt(0,z), z}));
      if(!p0 || !p1) continue;
      ctx.globalAlpha = clamp(1 - z/180, 0.05, 0.35);
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
    }
    // faint verticals to suggest width
    for(let x=-80; x<=80; x+=8){
      const p0 = project(toCam({x,y:groundYAt(x,2), z:2}));
      const p1 = project(toCam({x,y:groundYAt(x,140), z:140}));
      if(!p0||!p1) continue;
      ctx.globalAlpha = 0.06;
      ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawWaterDisc(W){
    // billboard ellipse based on center depth
    const c = toCam({x:W.x, y:0.02, z:W.z});
    const p = project(c); if(!p) return;
    const scale = focal / c.z;
    const rx = W.r * scale;
    const ry = rx * 0.28;
    ctx.save();
    // base
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(p.x, p.y+2, rx*1.04, ry*1.04, 0, 0, TAU); ctx.fill();
    // water tone
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--water').trim() || '#30160f';
    ctx.globalAlpha = 0.85;
    ctx.beginPath(); ctx.ellipse(p.x, p.y, rx, ry, 0, 0, TAU); ctx.fill();
    // rim sheen
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.ellipse(p.x, p.y - ry*0.25, rx*0.85, ry*0.55, 0, 0, TAU); ctx.fill();
    ctx.restore();
  }

  function drawGeyser3D(G){
    const drift = Math.sin(clock*G.speed + G.phase)*G.rx*0.6;
    const cx = toCam({x:G.x+drift, y:0, z:G.z});
    const p = project(cx); if(!p) return;
    const baseScale = focal / Math.max(0.05, cx.z);
    const rx = G.rx * baseScale;
    const h  = G.height * baseScale;
    ctx.save();
    // glow base
    ctx.fillStyle = 'rgba(73,208,255,0.10)';
    ctx.beginPath(); ctx.ellipse(p.x, p.y, rx, rx*0.18, 0, 0, TAU); ctx.fill();
    // column puffs
    ctx.globalAlpha = 0.14;
    for(let i=0;i<8;i++){
      const t = i/7;
      const y = p.y - t*h + Math.sin(clock*2.0 + t*6.0)*2;
      const w = rx*(1 - 0.22*t);
      ctx.beginPath(); ctx.ellipse(p.x, y, w, 8*(1 - 0.3*t), 0, 0, TAU); ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawObject(o){
    const c = toCam(o);
    const p = project(c); if(!p) return;
    const s = focal / c.z;
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.92)';
    ctx.strokeStyle='rgba(0,0,0,0.92)';
    if(o.type==='tree'){
      const h = o.h*s, w = Math.max(2, 0.5*s*2);
      // trunk
      ctx.fillRect(p.x - w/2, p.y - h, w, h);
      // simple triangular crown tiers
      for(let k=0;k<3;k++){
        const yy = p.y - h*0.25 - k*(h*0.22);
        const ww = (h*0.22 + k*(h*0.12));
        ctx.beginPath();
        ctx.moveTo(p.x, yy - h*0.08);
        ctx.lineTo(p.x - ww, yy + h*0.08);
        ctx.lineTo(p.x + ww, yy + h*0.08);
        ctx.closePath(); ctx.fill();
      }
    } else if(o.type==='windmill'){
      const H = o.h*s;
      // tower
      ctx.beginPath();
      ctx.moveTo(p.x - 6*s, p.y);
      ctx.lineTo(p.x + 6*s, p.y);
      ctx.lineTo(p.x + 2*s, p.y - H);
      ctx.lineTo(p.x - 2*s, p.y - H);
      ctx.closePath(); ctx.fill();
      // hub + blades
      const hubY = p.y - H - 6*s;
      const r = (o.r||4)*s;
      ctx.beginPath(); ctx.arc(p.x, hubY, 2*s, 0, TAU); ctx.fill();
      const spin = o.spin + clock*(1 + Math.abs(windLift)*1.2);
      drawBlade(p.x,hubY,spin, r);
      drawBlade(p.x,hubY,spin+TAU/3, r);
      drawBlade(p.x,hubY,spin+2*TAU/3, r);
    }
    ctx.restore();

    function drawBlade(x,y,a,R){
      ctx.save(); ctx.translate(x,y); ctx.rotate(a);
      const bw = Math.max(4, R*0.24);
      ctx.fillRect(0, -bw/2, R, bw);
      ctx.restore();
    }
  }

  function drawBasket3D(B){
    const base = toCam({x:B.x, y:0, z:B.z});
    const poleTop = toCam({x:B.x, y:B.pole, z:B.z});
    const rim = toCam({x:B.x, y:B.rimY, z:B.z});
    const pBase = project(base), pTop = project(poleTop), pRim = project(rim);
    if(!pBase || !pTop || !pRim) return;
    ctx.save();
    // pole
    ctx.strokeStyle='rgba(255,255,255,0.75)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(pBase.x, pBase.y); ctx.lineTo(pTop.x, pTop.y); ctx.stroke();
    // rim ellipse & cage
    const s = focal / rim.z;
    const rimW = B.rimR*2*s* (canvasH/600);
    const ry = Math.max(1, 4*s*0.6);
    ctx.fillStyle='rgba(0,0,0,0.80)';
    // cage box (below rim)
    ctx.fillRect(pRim.x - rimW*0.7, pRim.y + ry*2.5, rimW*1.4, 6);
    // rim
    ctx.beginPath(); ctx.ellipse(pRim.x, pRim.y, rimW*0.9, ry, 0, 0, TAU); ctx.fill();
    // chains
    ctx.strokeStyle='rgba(0,0,0,0.75)'; ctx.lineWidth=1;
    for(let i=0;i<6;i++){
      const t = i/6 * TAU;
      const cx = pRim.x + Math.cos(t)*rimW*0.7;
      ctx.beginPath(); ctx.moveTo(cx, pRim.y); ctx.lineTo(cx, pRim.y + ry*2.6); ctx.stroke();
    }
    // tiny flag
    const stubTop = toCam({x:B.x, y:B.pole+0.2, z:B.z});
    const pStub = project(stubTop);
    if(pStub){
      const dir  = (windOn ? (windLift >= 0 ? 1 : -1) : 1);
      const wmag = windOn ? Math.abs(windLift) : 0;
      const len    = 22 * (1 + wmag*0.6);
      const height = 8;
      const phase  = clock*2.0;
      const N=8;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#ff8a3d';
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth=1;
      ctx.beginPath();
      for(let i=0;i<=N;i++){
        const t=i/N;
        const px = pStub.x + dir * t * (len);
        const py = pStub.y + Math.sin(phase + t*TAU)*2.5;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      for(let i=N;i>=0;i--){
        const t=i/N;
        const px = pStub.x + dir * t * (len);
        const py = pStub.y + height + Math.sin(phase + t*TAU + 0.6)*1.6;
        ctx.lineTo(px,py);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }

  function drawNose(){
    // subtle rim at bottom center to suggest disc presence
    ctx.save();
    ctx.globalAlpha=0.25;
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#ff8a3d';
    const w = 90, h = 18;
    ctx.beginPath();
    ctx.ellipse(canvasW*0.5, canvasH*0.82, w, h, 0, 0, TAU);
    ctx.fill();
    ctx.restore();
  }

  function drawVignette(){
    const g = ctx.createRadialGradient(canvasW*0.5, canvasH*0.58, Math.min(canvasW,canvasH)*0.2, canvasW*0.5, canvasH*0.58, Math.max(canvasW,canvasH)*0.7);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvasW,canvasH);
  }

  // ===== Resize
  function resize(){
    DPR = Math.max(1, Math.min(DPR_MAX, window.devicePixelRatio||1));
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height= Math.floor(window.innerHeight* DPR);
    canvasW = canvas.width / DPR; canvasH = canvas.height / DPR;
    CX = canvasW/2; CY = canvasH*0.64;
    focal = (canvasH / (2*Math.tan((FOV_DEG*Math.PI/180)/2)));
  }
  window.addEventListener('resize', resize); resize();

  // ===== Main loop
  let last=0, clock=0;
  function loop(t){
    const now=t/1000; const dt = Math.min(0.033, last? now-last: 0.016); last=now; clock += dt;
    if(meterOn){ elPowerfill.style.width=(meter*100).toFixed(1)+'%'; }
    updatePhysics(dt);
    updateCamera(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== UI wiring
  btnPlay.addEventListener('click', ()=>{ screenIntro.style.display='none'; Sfx.init(); newRound(); });
  btnPlayAgain.addEventListener('click', ()=>{ screenSummary.style.display='none'; Sfx.init(); newRound(); });
  btnNewRound.addEventListener('click', ()=>{ Sfx.init(); newRound(); });
  btnSettings.addEventListener('click', ()=>{ screenSettings.style.display='grid'; });
  btnCloseSettings.addEventListener('click', ()=>{ screenSettings.style.display='none'; });
  chkReduced.addEventListener('change', ()=>{ /* hook available if you want to dampen effects */ });
  chkAudio.addEventListener('change', ()=>{ const on = chkAudio.checked; Sfx.setEnabled(on); AudioMini.setEnabled(on); });
  chkWind.addEventListener('change', ()=>{ windOn = chkWind.checked; updateWindUI(); AudioMini.setWind(windOn); });
  chkFirstPerson.addEventListener('change', ()=>{ firstPersonHard = chkFirstPerson.checked; });

  // unlock audio on first interaction (mobile)
  window.addEventListener('pointerdown', () => { try { Sfx.init(); } catch{}; if (chkAudio.checked){ try{ Sfx.setEnabled(true); AudioMini.setEnabled(true);}catch{} } }, { once:true });

  // init
  Sfx.setEnabled(chkAudio.checked);
  AudioMini.setEnabled(chkAudio.checked);
  AudioMini.setWind(windOn);
  buildDiscs();
  updateWindUI();
})();
</script>
</body>
</html>
