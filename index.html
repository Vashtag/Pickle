<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Dink City — Retro Pickleball Roguelike</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#000;overflow:hidden;user-select:none;-webkit-user-select:none;font-family:'Courier New',monospace;color:#e6edf3}
  canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges}
  #wrap{position:fixed;inset:0;display:grid;place-items:center;background:#000}

  /* ====== HEAVY CRT EFFECTS ====== */
  #crt-container{position:relative;border-radius:18px;overflow:hidden;box-shadow:0 0 60px rgba(73,208,255,0.15), 0 0 120px rgba(73,208,255,0.05), inset 0 0 1px rgba(255,255,255,0.1)}

  /* Scanlines */
  #scanlines{position:absolute;inset:0;pointer-events:none;z-index:10;
    background:repeating-linear-gradient(
      0deg,
      rgba(0,0,0,0) 0px,
      rgba(0,0,0,0) 1px,
      rgba(0,0,0,0.3) 1px,
      rgba(0,0,0,0.3) 2px
    );
    mix-blend-mode:multiply}

  /* RGB sub-pixel pattern */
  #rgb-grid{position:absolute;inset:0;pointer-events:none;z-index:11;opacity:0.04;
    background:repeating-linear-gradient(
      90deg,
      rgba(255,0,0,1) 0px,rgba(255,0,0,1) 1px,
      rgba(0,255,0,1) 1px,rgba(0,255,0,1) 2px,
      rgba(0,0,255,1) 2px,rgba(0,0,255,1) 3px
    );
    background-size:3px 1px}

  /* Vignette + CRT curvature glow */
  #crt-glow{position:absolute;inset:0;pointer-events:none;z-index:12;
    box-shadow:
      inset 0 0 100px rgba(0,0,0,0.7),
      inset 0 0 200px rgba(0,0,0,0.4),
      inset 0 0 300px rgba(0,0,0,0.2);
    border-radius:18px}

  /* Phosphor bloom layer */
  #phosphor{position:absolute;inset:0;pointer-events:none;z-index:9;opacity:0.12;filter:blur(4px);border-radius:18px;overflow:hidden}
  #phosphor canvas{width:100%;height:100%}

  /* Flicker overlay */
  #flicker{position:absolute;inset:0;pointer-events:none;z-index:13;opacity:0;background:rgba(200,230,255,0.03);animation:crt-flicker 0.15s infinite}
  @keyframes crt-flicker{
    0%{opacity:0}
    5%{opacity:1}
    10%{opacity:0}
    15%{opacity:0.5}
    20%{opacity:0}
    100%{opacity:0}
  }

  /* Turn-on animation */
  #crt-container{animation:crt-on 0.8s ease-out}
  @keyframes crt-on{
    0%{filter:brightness(30) saturate(0);transform:scaleY(0.005) scaleX(0.8)}
    40%{filter:brightness(5) saturate(0.5);transform:scaleY(0.9) scaleX(1)}
    70%{filter:brightness(1.5) saturate(1);transform:scaleY(1.02) scaleX(1)}
    100%{filter:brightness(1) saturate(1);transform:scaleY(1) scaleX(1)}
  }

  /* Slight curvature illusion via border-radius on container */
  #crt-container::before{
    content:'';position:absolute;inset:-2px;border-radius:20px;
    background:linear-gradient(135deg,rgba(255,255,255,0.06),transparent 40%,transparent 60%,rgba(255,255,255,0.03));
    z-index:14;pointer-events:none}

  /* Ambient room glow on the "bezel" */
  #wrap::before{
    content:'';position:fixed;inset:0;pointer-events:none;
    background:radial-gradient(ellipse at 50% 45%,rgba(73,208,255,0.06) 0%,transparent 60%);
    z-index:0}

  /* Custom cursor */
  #crt-container{cursor:crosshair}
</style>
</head>
<body>
<div id="wrap">
  <div id="crt-container">
    <canvas id="c"></canvas>
    <canvas id="phosphor-canvas" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:9;opacity:0.12;filter:blur(4px)"></canvas>
    <div id="scanlines"></div>
    <div id="rgb-grid"></div>
    <div id="crt-glow"></div>
    <div id="flicker"></div>
  </div>
</div>
<script>
// ============================================================
//  DINK CITY — Retro Side-View Pickleball Roguelike
//  Now with HEAVY CRT vibes, mouse click hits, & power-ups!
// ============================================================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const phosphorCanvas = document.getElementById('phosphor-canvas');
const phosphorCtx = phosphorCanvas.getContext('2d');

// --- Responsive sizing ---
let W, H, SCALE;
function resize() {
  W = 800; H = 500;
  const aspect = W / H;
  let cw = window.innerWidth * 0.96, ch = window.innerHeight * 0.94;
  if (cw / ch > aspect) { cw = ch * aspect; } else { ch = cw / aspect; }
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.width = W;
  canvas.height = H;
  phosphorCanvas.width = W;
  phosphorCanvas.height = H;
  const container = document.getElementById('crt-container');
  container.style.width = cw + 'px';
  container.style.height = ch + 'px';
  SCALE = cw / W;
}
window.addEventListener('resize', resize);
resize();

// --- Colors (retro palette) ---
const COL = {
  bg: '#0f1020',
  skyGrad1: '#0d0825',
  skyGrad2: '#1a1050',
  court: '#2a7a3a',
  courtDark: '#1e5c2a',
  courtLine: '#d8d8c0',
  net: '#ccccaa',
  netPole: '#888870',
  kitchenLine: '#ffaa33',
  p1: '#49d0ff',
  p1Dark: '#2090bb',
  p2: '#ff6b4a',
  p2Dark: '#bb3a2a',
  ball: '#ffe033',
  text: '#e6edf3',
  muted: '#7a8a9a',
  accent: '#ff8a3d',
  accent2: '#49d0ff',
  accent3: '#86efac',
  panel: 'rgba(10,10,20,0.92)',
  shadow: 'rgba(0,0,0,0.4)',
};

// --- Court dimensions ---
const COURT = {
  groundY: 360,
  leftX: 80,
  rightX: 720,
  netX: 400,
  netHeight: 60,
  kitchenDepth: 90,
};

// --- Game states ---
const STATE = { TITLE:0, MATCH_INTRO:1, PLAYING:2, POINT_SCORED:3, UPGRADE:4, GAME_OVER:5, VICTORY:6 };

// --- Opponents ---
const OPPONENTS = [
  { name:'Rusty', title:'The Weekend Warrior', color:'#cc8844', speed:1.5, reaction:0.6, power:0.5, accuracy:0.4 },
  { name:'Brenda', title:'Spin Queen', color:'#cc44aa', speed:1.8, reaction:0.55, power:0.55, accuracy:0.5 },
  { name:'Chad', title:'Banger Bro', color:'#44cc44', speed:2.0, reaction:0.5, power:0.8, accuracy:0.45 },
  { name:'Miko', title:'Kitchen Assassin', color:'#aa44cc', speed:2.3, reaction:0.4, power:0.6, accuracy:0.65 },
  { name:'Big Tony', title:'The Wall', color:'#cc6644', speed:1.6, reaction:0.35, power:0.7, accuracy:0.7 },
  { name:'Svetlana', title:'Ice Cold Dinks', color:'#44aacc', speed:2.8, reaction:0.3, power:0.65, accuracy:0.8 },
  { name:'The Pickle', title:'Final Boss', color:'#44ff44', speed:3.2, reaction:0.2, power:0.85, accuracy:0.9 },
];

// --- Upgrades pool (between-match roguelike upgrades) ---
const UPGRADE_POOL = [
  { id:'speed', icon:'\u26A1', name:'Quick Feet', desc:'+20% move speed', apply:(p)=>{p.speed*=1.2;} },
  { id:'power', icon:'\uD83D\uDCAA', name:'Power Shot', desc:'+25% hit power', apply:(p)=>{p.power*=1.25;} },
  { id:'reach', icon:'\uD83E\uDDBE', name:'Long Arm', desc:'+20% paddle reach', apply:(p)=>{p.reachX*=1.2;p.reachY*=1.2;} },
  { id:'stamina', icon:'\uD83C\uDFC3', name:'Endurance', desc:'Faster recovery', apply:(p)=>{p.recoveryRate*=1.3;} },
  { id:'spin', icon:'\uD83C\uDF00', name:'Wicked Spin', desc:'Shots curve more', apply:(p)=>{p.spinPower*=1.4;} },
  { id:'dink', icon:'\uD83C\uDFAF', name:'Soft Hands', desc:'Better dink control', apply:(p)=>{p.dinkSkill*=1.3;} },
  { id:'smash', icon:'\uD83D\uDD28', name:'Overhead Slam', desc:'Stronger smashes', apply:(p)=>{p.smashPower*=1.3;} },
  { id:'lucky', icon:'\uD83C\uDF40', name:'Lucky Paddle', desc:'+15% crit chance', apply:(p)=>{p.critChance=Math.min(0.5,p.critChance+0.15);} },
  { id:'wall', icon:'\uD83E\uDDF1', name:'The Wall', desc:'+30% block range', apply:(p)=>{p.reachY*=1.3;} },
  { id:'wind', icon:'\uD83D\uDCA8', name:'Tailwind', desc:'Ball goes faster', apply:(p)=>{p.power*=1.15;p.speed*=1.1;} },
];

// --- In-match Power-ups (collectible pickups that spawn on court) ---
const POWERUP_TYPES = [
  { id:'giant_paddle', icon:'GP', name:'GIANT PADDLE', color:'#ff44ff', duration:300, desc:'Huge reach!',
    onApply:(p)=>{ p._origReachX=p.reachX; p._origReachY=p.reachY; p.reachX*=2; p.reachY*=2; },
    onRemove:(p)=>{ p.reachX=p._origReachX||p.reachX/2; p.reachY=p._origReachY||p.reachY/2; } },
  { id:'speed_boost', icon:'SP', name:'SPEED BOOST', color:'#44ffff', duration:350, desc:'Zoom!',
    onApply:(p)=>{ p._origSpeed=p.speed; p.speed*=1.8; },
    onRemove:(p)=>{ p.speed=p._origSpeed||p.speed/1.8; } },
  { id:'fire_ball', icon:'FB', name:'FIRE BALL', color:'#ff6600', duration:250, desc:'Blazing shots!',
    onApply:(p)=>{ p._origPower=p.power; p.power*=2; },
    onRemove:(p)=>{ p.power=p._origPower||p.power/2; } },
  { id:'magnet', icon:'MG', name:'MAGNET BALL', color:'#ffff44', duration:280, desc:'Ball seeks paddle!',
    onApply:(p)=>{ p.hasMagnet=true; },
    onRemove:(p)=>{ p.hasMagnet=false; } },
  { id:'freeze', icon:'FZ', name:'FREEZE FOE', color:'#88ccff', duration:200, desc:'Opponent slowed!',
    onApply:()=>{}, onRemove:()=>{} },  // handled in AI update
  { id:'double_pts', icon:'2X', name:'DOUBLE POINTS', color:'#86efac', duration:400, desc:'2x scoring!',
    onApply:(p)=>{ p.doublePoints=true; },
    onRemove:(p)=>{ p.doublePoints=false; } },
];

// --- Input ---
const keys = {};
let mouseX = 0, mouseY = 0;
let mouseClicked = false, mouseRightClicked = false;
let touchLeft = false, touchRight = false, touchSwing = false, touchLob = false;
window.addEventListener('keydown', e => { keys[e.key]=true; keys[e.code]=true; });
window.addEventListener('keyup', e => { keys[e.key]=false; keys[e.code]=false; });

// Mouse input
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) / SCALE;
  mouseY = (e.clientY - rect.top) / SCALE;
});
canvas.addEventListener('mousedown', e => {
  e.preventDefault();
  if (e.button === 0) mouseClicked = true;
  if (e.button === 2) mouseRightClicked = true;
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// Touch controls
canvas.addEventListener('touchstart', handleTouch, {passive:false});
canvas.addEventListener('touchmove', handleTouch, {passive:false});
canvas.addEventListener('touchend', handleTouchEnd, {passive:false});
function handleTouch(e) {
  e.preventDefault();
  touchLeft=false;touchRight=false;touchSwing=false;touchLob=false;
  for(let t of e.touches){
    const x=t.clientX/window.innerWidth, y=t.clientY/window.innerHeight;
    if(y>0.5){if(x<0.35)touchLeft=true;else if(x<0.65)touchSwing=true;else touchRight=true;}
    else{if(x>0.5)touchLob=true;}
  }
}
function handleTouchEnd(e){
  e.preventDefault();
  if(e.touches.length===0){touchLeft=false;touchRight=false;touchSwing=false;touchLob=false;}
  else handleTouch(e);
}

// --- Player ---
function createPlayer(isAI, side) {
  return {
    x: side==='left'?200:600, y:COURT.groundY, vx:0, vy:0,
    side, isAI,
    speed:3.5, power:1.0, reachX:35, reachY:45,
    recoveryRate:1.0, spinPower:1.0, dinkSkill:1.0, smashPower:1.0, critChance:0.05,
    swinging:false, swingTimer:0, swingCooldown:0,
    facingRight: side==='left',
    walkFrame:0, walkTimer:0, hitFlash:0,
    upgrades:[], hasMagnet:false, doublePoints:false,
  };
}

// --- Ball ---
let ball = {x:0,y:0,vx:0,vy:0,active:false,gravity:0.25,lastHitBy:null,bounced:false,trail:[],inPlay:false,spin:0,onFire:false};

// --- Game state ---
let state = STATE.TITLE;
let player, opponent;
let currentOpponentIdx = 0;
let playerScore = 0, opponentScore = 0;
let scoreToWin = 5;
let servingSide = 'left';
let serveReady = false;
let pointPause = 0;
let selectedUpgrades = [];
let upgradeSelection = -1;
let stars = [];
let particles = [];
let shakeTimer = 0, shakeIntensity = 0;
let kitchenFaultTimer = 0;
let savedUpgrades = [];

// Power-up state
let powerups = [];          // active pickups on court
let activePowerups = [];    // currently active effects on player
let powerupSpawnTimer = 0;
const POWERUP_SPAWN_INTERVAL = 300; // frames between spawns

// CRT frame counter for effects
let frameCount = 0;

// Generate stars
for(let i=0;i<120;i++){
  stars.push({x:Math.random()*W, y:Math.random()*(COURT.groundY-80), size:Math.random()*2+0.5, twinkle:Math.random()*Math.PI*2, speed:Math.random()*0.02});
}

// --- AI state ---
let aiTargetX=0, aiSwingIntent=false, aiReactionTimer=0, aiDecisionTimer=0;

// --- Init round ---
function initMatch() {
  const opp = OPPONENTS[currentOpponentIdx];
  player = createPlayer(false, 'left');
  opponent = createPlayer(true, 'right');
  opponent.speed = opp.speed;
  opponent.power = 0.5 + opp.power*0.8;
  opponent.reachX = 30 + opp.accuracy*15;
  opponent.reachY = 40 + opp.accuracy*15;
  playerScore=0; opponentScore=0;
  servingSide='left';
  powerups=[];
  activePowerups=[];
  powerupSpawnTimer = 150; // first spawn comes quick
  resetBall();
}

function resetBall() {
  ball.active=false; ball.inPlay=false; ball.trail=[];
  ball.bounced=false; ball.lastHitBy=null; ball.spin=0; ball.onFire=false;
  serveReady=true;
  kitchenFaultTimer=0;
  if(servingSide==='left'){ ball.x=player.x+20; ball.y=player.y-50; }
  else{ ball.x=opponent.x-20; ball.y=opponent.y-50; }
  ball.vx=0; ball.vy=0;
}

// ---- Serve ----
function doServe(who) {
  serveReady=false; ball.active=true; ball.inPlay=true; ball.bounced=false;
  if(who==='left'){
    ball.x=player.x+20; ball.y=player.y-60;
    ball.vx=5+player.power*2; ball.vy=-5-player.power; ball.lastHitBy='left';
    player.swingCooldown=20;
  } else {
    ball.x=opponent.x-20; ball.y=opponent.y-60;
    ball.vx=-(5+opponent.power*2); ball.vy=-5-opponent.power; ball.lastHitBy='right';
    opponent.swingCooldown=20;
  }
}

// ---- Kitchen ----
function isInKitchen(px, side) {
  if(side==='left') return px>=(COURT.netX-COURT.kitchenDepth)&&px<=COURT.netX;
  else return px>=COURT.netX&&px<=(COURT.netX+COURT.kitchenDepth);
}
function checkKitchenVolley(px, side, ballBounced) {
  return isInKitchen(px, side) && !ballBounced;
}

// ---- Hit ball ----
function tryHit(p, isLob) {
  if(p.swingCooldown>0) return false;
  const dx=ball.x-p.x, dy=ball.y-(p.y-40);
  const dist=Math.sqrt(dx*dx+dy*dy);
  const reach=Math.sqrt(p.reachX*p.reachX+p.reachY*p.reachY);

  if(dist<reach && ball.active) {
    if(checkKitchenVolley(p.x, p.side, ball.bounced)){
      kitchenFaultTimer=90;
      scorePoint(p.side==='left'?'right':'left');
      shakeTimer=15; shakeIntensity=4;
      addParticles(p.x, p.y-40, COL.kitchenLine, 15);
      return true;
    }

    p.swinging=true; p.swingTimer=10; p.swingCooldown=15; p.hitFlash=8;
    const dir=p.side==='left'?1:-1;
    const isCrit=Math.random()<p.critChance;
    const powerMult=isCrit?1.8:1.0;

    if(p.side==='left'){
      // Player: aim toward mouse cursor
      const aimDx=mouseX-ball.x, aimDy=mouseY-ball.y;
      const aimDist=Math.sqrt(aimDx*aimDx+aimDy*aimDy)||1;
      const aimNx=aimDx/aimDist, aimNy=aimDy/aimDist;
      // Ensure ball always goes toward opponent's side
      const aimNxClamped=Math.max(0.2, aimNx);
      if(isLob){
        const spd=4+p.power*1.5;
        ball.vx=aimNxClamped*(spd)*powerMult; ball.vy=-8-p.power*2;
      } else if(ball.y<p.y-60){
        // Smash: aim toward mouse but force downward component
        const spd=7+p.smashPower*3;
        ball.vx=aimNxClamped*spd*powerMult; ball.vy=Math.max(1, aimNy*spd*0.5)*powerMult;
      } else if(isInKitchen(p.x, p.side)){
        const spd=2.5+p.dinkSkill*0.5;
        ball.vx=aimNxClamped*spd*powerMult; ball.vy=Math.min(-1, aimNy*spd)*powerMult;
      } else {
        const spd=5+p.power*2.5;
        ball.vx=aimNxClamped*spd*powerMult; ball.vy=aimNy*spd*0.6*powerMult;
        // Clamp vy so ball doesn't go straight into the ground
        ball.vy=Math.max(-spd, Math.min(spd*0.4, ball.vy));
      }
    } else {
      // AI: use fixed formulas
      if(isLob){
        ball.vx=dir*(3+p.power*1.5)*powerMult; ball.vy=-8-p.power*2;
      } else if(ball.y<p.y-60){
        ball.vx=dir*(6+p.smashPower*3)*powerMult; ball.vy=3+p.smashPower;
      } else if(isInKitchen(p.x, p.side)){
        ball.vx=dir*(2+p.dinkSkill*0.5)*powerMult; ball.vy=-3-p.dinkSkill*0.5;
      } else {
        ball.vx=dir*(4+p.power*2.5)*powerMult; ball.vy=-4-p.power*1.5;
      }
    }

    ball.spin=p.spinPower*dir*0.3; ball.lastHitBy=p.side; ball.bounced=false;

    // Fire ball visual
    ball.onFire = hasActivePowerup('fire_ball');

    shakeTimer=isCrit?10:4; shakeIntensity=isCrit?6:2;
    addParticles(ball.x, ball.y, isCrit?'#ff4444':COL.ball, isCrit?12:6);
    if(ball.onFire) addParticles(ball.x, ball.y, '#ff6600', 8);
    return true;
  }
  return false;
}

// ---- Score ----
function scorePoint(winner) {
  let pts = 1;
  if(winner==='left' && player.doublePoints) pts=2;
  if(winner==='left') playerScore+=pts; else opponentScore++;
  ball.active=false; ball.inPlay=false; pointPause=90;
  servingSide=winner;
  if(playerScore>=scoreToWin||opponentScore>=scoreToWin) pointPause=120;
  state=STATE.POINT_SCORED;
}

// ---- Particles ----
function addParticles(x,y,color,count){
  for(let i=0;i<count;i++){
    particles.push({x,y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6-2,
      life:20+Math.random()*20, maxLife:40, color, size:2+Math.random()*3});
  }
}

// ---- Power-up helpers ----
function hasActivePowerup(id) {
  return activePowerups.some(p => p.type.id === id);
}

function spawnPowerup() {
  const type = POWERUP_TYPES[Math.floor(Math.random()*POWERUP_TYPES.length)];
  // Spawn on player's side of the court
  const x = COURT.leftX + 30 + Math.random()*(COURT.netX - COURT.leftX - 60);
  const y = COURT.groundY - 20 - Math.random()*80;
  powerups.push({ type, x, y, timer:400, bobPhase:Math.random()*Math.PI*2 });
}

function collectPowerup(idx) {
  const pu = powerups[idx];
  powerups.splice(idx, 1);

  // Remove existing of same type
  activePowerups = activePowerups.filter(ap => {
    if(ap.type.id === pu.type.id) { ap.type.onRemove(player); return false; }
    return true;
  });

  pu.type.onApply(player);
  activePowerups.push({ type:pu.type, remaining:pu.type.duration });
  addParticles(pu.x, pu.y, pu.type.color, 12);
  shakeTimer=5; shakeIntensity=3;
}

// ---- AI ----
function updateAI(dt) {
  const opp = OPPONENTS[currentOpponentIdx];
  const isFrozen = hasActivePowerup('freeze');
  const speedMult = isFrozen ? 0.3 : 1.0;

  aiDecisionTimer-=dt;
  if(aiDecisionTimer<=0){
    aiDecisionTimer=5+opp.reaction*15;
    if(ball.active&&ball.inPlay){
      if(ball.vx>0||ball.x>COURT.netX){
        let predX=ball.x+ball.vx*15;
        aiTargetX=predX-15;
        const ddx=Math.abs(ball.x-opponent.x), ddy=Math.abs(ball.y-(opponent.y-40));
        if(ddx<opponent.reachX+10&&ddy<opponent.reachY+10) aiSwingIntent=true;
      } else {
        aiTargetX=600+Math.random()*60; aiSwingIntent=false;
      }
    } else { aiTargetX=600; aiSwingIntent=false; }
  }

  const moveDir=aiTargetX-opponent.x;
  if(Math.abs(moveDir)>5){
    opponent.vx=Math.sign(moveDir)*opponent.speed*speedMult;
    opponent.facingRight=moveDir>0;
  } else opponent.vx=0;

  if(aiSwingIntent&&opponent.swingCooldown<=0){
    const ddx=Math.abs(ball.x-opponent.x), ddy=Math.abs(ball.y-(opponent.y-40));
    if(ddx<opponent.reachX&&ddy<opponent.reachY){
      const inKit=isInKitchen(opponent.x,'right');
      if(inKit&&!ball.bounced&&Math.random()<opp.accuracy) aiSwingIntent=false;
      else { tryHit(opponent, Math.random()<0.2); aiSwingIntent=false; }
    }
  }

  if(serveReady&&servingSide==='right'){
    aiReactionTimer+=dt;
    if(aiReactionTimer>40){ doServe('right'); aiReactionTimer=0; }
  }
}

// ---- Main update ----
function update() {
  const dt=1;
  frameCount++;

  if(state===STATE.PLAYING){
    // --- Player input ---
    let moveX=0;
    if(keys['ArrowLeft']||keys['a']||keys['A']||touchLeft) moveX=-1;
    if(keys['ArrowRight']||keys['d']||keys['D']||touchRight) moveX=1;
    player.vx=moveX*player.speed;
    player.facingRight = moveX>0?true:moveX<0?false:player.facingRight;

    // Keyboard swing
    if((keys[' ']||keys['z']||keys['Z']||touchSwing)&&!player.swinging){
      if(ball.active&&ball.inPlay) tryHit(player, false);
    }
    // Keyboard lob
    if((keys['x']||keys['X']||keys['ArrowUp']||touchLob)&&!player.swinging){
      if(ball.active&&ball.inPlay) tryHit(player, true);
    }

    // Mouse click to hit!
    if(mouseClicked){
      mouseClicked=false;
      if(serveReady&&servingSide==='left') doServe('left');
      else if(ball.active&&ball.inPlay&&!player.swinging) tryHit(player, false);
    }
    if(mouseRightClicked){
      mouseRightClicked=false;
      if(ball.active&&ball.inPlay&&!player.swinging) tryHit(player, true);
    }

    // Keyboard serve
    if(serveReady&&servingSide==='left'){
      if(keys[' ']||keys['z']||keys['Z']||touchSwing) doServe('left');
    }

    // Update player position
    player.x+=player.vx;
    player.x=Math.max(COURT.leftX, Math.min(COURT.netX-20, player.x));

    // Magnet effect: pull ball toward player
    if(player.hasMagnet && ball.active && ball.inPlay && ball.lastHitBy==='right'){
      const mdx=player.x-ball.x, mdy=(player.y-40)-ball.y;
      const md=Math.sqrt(mdx*mdx+mdy*mdy);
      if(md<200 && md>10){
        ball.vx+=mdx/md*0.15; ball.vy+=mdy/md*0.1;
      }
    }

    // AI
    updateAI(dt);
    opponent.x+=opponent.vx;
    opponent.x=Math.max(COURT.netX+20, Math.min(COURT.rightX, opponent.x));

    // --- Ball physics ---
    if(ball.active){
      ball.trail.push({x:ball.x,y:ball.y,fire:ball.onFire});
      if(ball.trail.length>12) ball.trail.shift();

      ball.vy+=ball.gravity; ball.vx+=ball.spin*0.05;
      ball.x+=ball.vx; ball.y+=ball.vy;

      // Net collision
      if(ball.y>COURT.groundY-COURT.netHeight&&ball.y<COURT.groundY){
        if(Math.abs(ball.x-COURT.netX)<4){
          // Push ball back to whichever side it came from
          if(ball.vx>0) ball.x=COURT.netX-4;
          else ball.x=COURT.netX+4;
          ball.vx*=-0.3; ball.vy*=0.5;
          addParticles(COURT.netX, ball.y, COL.net, 5);
          shakeTimer=5; shakeIntensity=2;
        }
      }

      // Ground bounce
      if(ball.y>=COURT.groundY){
        ball.y=COURT.groundY;
        if(!ball.bounced&&ball.inPlay){
          ball.bounced=true; ball.vy=-ball.vy*0.5; ball.vx*=0.8;
          addParticles(ball.x, COURT.groundY, '#8B7355', 4);
          if(ball.x<COURT.leftX||ball.x>COURT.rightX){
            scorePoint(ball.lastHitBy==='left'?'right':'left');
            addParticles(ball.x, COURT.groundY, '#ff4444', 8);
          }
        } else if(ball.bounced){
          if(ball.x<COURT.netX) scorePoint('right'); else scorePoint('left');
          addParticles(ball.x, COURT.groundY, COL.accent3, 8);
        }
      }
      if(ball.y<20){ball.y=20; ball.vy=Math.abs(ball.vy)*0.5;}
      if(ball.x<COURT.leftX-50||ball.x>COURT.rightX+50){
        if(ball.inPlay) scorePoint(ball.lastHitBy==='left'?'right':'left');
      }
    }

    // --- Timers ---
    if(player.swingTimer>0){ player.swingTimer--; if(player.swingTimer<=0) player.swinging=false; }
    if(player.swingCooldown>0) player.swingCooldown--;
    if(player.hitFlash>0) player.hitFlash--;
    if(opponent.swingTimer>0){ opponent.swingTimer--; if(opponent.swingTimer<=0) opponent.swinging=false; }
    if(opponent.swingCooldown>0) opponent.swingCooldown--;
    if(opponent.hitFlash>0) opponent.hitFlash--;

    // Walk anim
    if(Math.abs(player.vx)>0.5){player.walkTimer++;if(player.walkTimer>8){player.walkTimer=0;player.walkFrame=(player.walkFrame+1)%4;}}
    else{player.walkFrame=0;player.walkTimer=0;}
    if(Math.abs(opponent.vx)>0.5){opponent.walkTimer++;if(opponent.walkTimer>8){opponent.walkTimer=0;opponent.walkFrame=(opponent.walkFrame+1)%4;}}
    else{opponent.walkFrame=0;opponent.walkTimer=0;}

    // --- Power-up spawning ---
    powerupSpawnTimer--;
    if(powerupSpawnTimer<=0 && powerups.length<2){
      spawnPowerup();
      powerupSpawnTimer = POWERUP_SPAWN_INTERVAL + Math.random()*150;
    }

    // --- Power-up collection (player walks over them) ---
    for(let i=powerups.length-1;i>=0;i--){
      const pu=powerups[i];
      pu.timer--;
      if(pu.timer<=0){ powerups.splice(i,1); continue; }
      const ddx=Math.abs(player.x-pu.x), ddy=Math.abs((player.y-25)-pu.y);
      if(ddx<25&&ddy<30) collectPowerup(i);
    }

    // --- Active power-up timers ---
    for(let i=activePowerups.length-1;i>=0;i--){
      activePowerups[i].remaining--;
      if(activePowerups[i].remaining<=0){
        activePowerups[i].type.onRemove(player);
        activePowerups.splice(i,1);
      }
    }

  } else if(state===STATE.POINT_SCORED){
    pointPause--;
    if(pointPause<=0){
      if(playerScore>=scoreToWin){
        currentOpponentIdx++;
        if(currentOpponentIdx>=OPPONENTS.length) state=STATE.VICTORY;
        else { generateUpgrades(); state=STATE.UPGRADE; }
      } else if(opponentScore>=scoreToWin) state=STATE.GAME_OVER;
      else { resetBall(); state=STATE.PLAYING; }
    }
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx;p.y+=p.vy;p.vy+=0.1;p.life--;
    if(p.life<=0)particles.splice(i,1);
  }

  if(shakeTimer>0) shakeTimer--;
  if(kitchenFaultTimer>0) kitchenFaultTimer--;
}

// ---- Upgrade screen ----
function generateUpgrades(){
  const shuffled=[...UPGRADE_POOL].sort(()=>Math.random()-0.5);
  selectedUpgrades=shuffled.slice(0,3); upgradeSelection=-1;
}
function selectUpgrade(idx){
  if(idx<0||idx>=selectedUpgrades.length) return;
  savedUpgrades.push(selectedUpgrades[idx]);
  state=STATE.MATCH_INTRO;
}

// ============================================================
//  DRAWING
// ============================================================

function drawSky(){
  const grad=ctx.createLinearGradient(0,0,0,COURT.groundY);
  grad.addColorStop(0,COL.skyGrad1); grad.addColorStop(1,COL.skyGrad2);
  ctx.fillStyle=grad; ctx.fillRect(0,0,W,COURT.groundY);
  // Stars
  const time=Date.now()*0.001;
  for(const s of stars){
    const alpha=0.3+0.7*Math.abs(Math.sin(time*s.speed*10+s.twinkle));
    ctx.fillStyle=`rgba(255,255,255,${alpha})`;
    ctx.fillRect(Math.floor(s.x),Math.floor(s.y),Math.ceil(s.size),Math.ceil(s.size));
  }
}

function drawCourt(){
  ctx.fillStyle=COL.court;
  ctx.fillRect(COURT.leftX,COURT.groundY,COURT.rightX-COURT.leftX,H-COURT.groundY);
  ctx.fillStyle='#0a3a15'; ctx.fillRect(0,COURT.groundY+40,W,H-COURT.groundY-40);
  ctx.fillStyle='#051a0a'; ctx.fillRect(0,COURT.groundY+80,W,H);

  // Court stripes
  for(let x=COURT.leftX;x<COURT.rightX;x+=40){
    ctx.fillStyle=(Math.floor(x/40)%2===0)?COL.court:COL.courtDark;
    ctx.fillRect(x,COURT.groundY,40,35);
  }

  // Kitchen zones
  const kitAlpha=0.15+0.05*Math.sin(Date.now()*0.003);
  ctx.fillStyle=`rgba(255,170,51,${kitAlpha})`;
  ctx.fillRect(COURT.netX-COURT.kitchenDepth,COURT.groundY,COURT.kitchenDepth,35);
  ctx.fillRect(COURT.netX,COURT.groundY,COURT.kitchenDepth,35);

  // Kitchen lines
  ctx.strokeStyle=COL.kitchenLine; ctx.lineWidth=2; ctx.setLineDash([4,4]);
  ctx.beginPath(); ctx.moveTo(COURT.netX-COURT.kitchenDepth,COURT.groundY);
  ctx.lineTo(COURT.netX-COURT.kitchenDepth,COURT.groundY+35); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(COURT.netX+COURT.kitchenDepth,COURT.groundY);
  ctx.lineTo(COURT.netX+COURT.kitchenDepth,COURT.groundY+35); ctx.stroke();
  ctx.setLineDash([]);

  // Kitchen labels
  ctx.fillStyle='rgba(255,170,51,0.6)'; ctx.font='10px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('KITCHEN',COURT.netX-COURT.kitchenDepth/2,COURT.groundY+25);
  ctx.fillText('KITCHEN',COURT.netX+COURT.kitchenDepth/2,COURT.groundY+25);

  // Court border
  ctx.strokeStyle=COL.courtLine; ctx.lineWidth=2; ctx.setLineDash([]);
  ctx.strokeRect(COURT.leftX,COURT.groundY,COURT.rightX-COURT.leftX,35);
  ctx.beginPath(); ctx.moveTo(COURT.netX,COURT.groundY);
  ctx.lineTo(COURT.netX,COURT.groundY+35); ctx.stroke();

  // Net
  ctx.fillStyle=COL.netPole;
  ctx.fillRect(COURT.netX-2,COURT.groundY-COURT.netHeight,4,COURT.netHeight);
  ctx.strokeStyle=COL.net; ctx.lineWidth=1;
  for(let ny=COURT.groundY-COURT.netHeight;ny<COURT.groundY;ny+=6){
    ctx.beginPath();ctx.moveTo(COURT.netX-6,ny);ctx.lineTo(COURT.netX+6,ny);ctx.stroke();
  }
  for(let nx=COURT.netX-6;nx<=COURT.netX+6;nx+=3){
    ctx.beginPath();ctx.moveTo(nx,COURT.groundY-COURT.netHeight);ctx.lineTo(nx,COURT.groundY);ctx.stroke();
  }
  ctx.fillStyle=COL.courtLine;
  ctx.fillRect(COURT.netX-7,COURT.groundY-COURT.netHeight-2,14,3);
}

function drawPlayer(p, color, darkColor, label){
  const x=Math.floor(p.x), y=Math.floor(p.y), facing=p.facingRight?1:-1;

  // Power-up glow
  if(!p.isAI && activePowerups.length>0){
    const glowCol = activePowerups[0].type.color;
    ctx.save();
    ctx.globalAlpha=0.2+0.1*Math.sin(frameCount*0.1);
    ctx.shadowColor=glowCol; ctx.shadowBlur=20;
    ctx.fillStyle=glowCol;
    ctx.beginPath(); ctx.ellipse(x,y-25,18,30,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Shadow
  ctx.fillStyle=COL.shadow;
  ctx.beginPath(); ctx.ellipse(x,y+2,14,4,0,0,Math.PI*2); ctx.fill();

  // Legs
  const legOffset=[0,-3,0,3][p.walkFrame];
  ctx.fillStyle=darkColor;
  ctx.fillRect(x-6,y-14,5,14);
  ctx.fillRect(x+1,y-14+legOffset,5,14-legOffset);

  // Body
  ctx.fillStyle=color; ctx.fillRect(x-8,y-36,16,22);

  // Head
  ctx.fillStyle=p.hitFlash>0?'#ffffff':color;
  ctx.fillRect(x-6,y-48,12,12);

  // Eyes
  ctx.fillStyle='#000';
  if(facing>0){ctx.fillRect(x,y-44,3,3);ctx.fillRect(x+4,y-44,3,3);}
  else{ctx.fillRect(x-7,y-44,3,3);ctx.fillRect(x-3,y-44,3,3);}

  // Paddle
  const paddleExtend=p.swingTimer>0?18:8;
  const paddleY=p.swingTimer>0?-38:-30;
  ctx.fillStyle='#ddd';
  ctx.fillRect(x+facing*8,y+paddleY,facing*paddleExtend,3);
  ctx.fillStyle=color;
  ctx.fillRect(x+facing*(8+paddleExtend),y+paddleY-6,facing*6,14);
  ctx.strokeStyle='#fff'; ctx.lineWidth=1;
  ctx.strokeRect(x+facing*(8+paddleExtend),y+paddleY-6,facing*6,14);

  // Name
  ctx.fillStyle=color; ctx.font='bold 10px "Courier New"'; ctx.textAlign='center';
  ctx.fillText(label,x,y-54);

  // Kitchen indicator
  if(isInKitchen(p.x,p.side)){
    ctx.fillStyle=`rgba(255,170,51,${0.5+0.3*Math.sin(Date.now()*0.008)})`;
    ctx.font='bold 9px "Courier New"';
    ctx.fillText('\u26A0 NVZ',x,y-62);
  }
}

function drawBall(){
  if(!ball.active&&!serveReady) return;

  // Trail
  for(let i=0;i<ball.trail.length;i++){
    const t=ball.trail[i];
    const alpha=(i/ball.trail.length)*0.5;
    const size=2+(i/ball.trail.length)*4;
    if(t.fire){
      ctx.fillStyle=`rgba(255,100,0,${alpha})`;
      ctx.fillRect(Math.floor(t.x-size/2),Math.floor(t.y-size/2),size,size);
      ctx.fillStyle=`rgba(255,200,0,${alpha*0.5})`;
      ctx.fillRect(Math.floor(t.x-size/4),Math.floor(t.y-size/4),size/2,size/2);
    } else {
      ctx.fillStyle=`rgba(255,136,0,${alpha})`;
      ctx.fillRect(Math.floor(t.x-size/2),Math.floor(t.y-size/2),size,size);
    }
  }

  // Ball shadow
  if(ball.y<COURT.groundY){
    ctx.fillStyle=COL.shadow;
    ctx.beginPath(); ctx.ellipse(ball.x,COURT.groundY+2,5,2,0,0,Math.PI*2); ctx.fill();
  }

  // Fire glow
  if(ball.onFire){
    ctx.save();
    ctx.globalAlpha=0.4+0.2*Math.sin(frameCount*0.3);
    ctx.shadowColor='#ff6600'; ctx.shadowBlur=15;
    ctx.fillStyle='#ff4400';
    ctx.beginPath(); ctx.arc(ball.x,ball.y,8,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Ball
  ctx.fillStyle=ball.onFire?'#ff8800':COL.ball;
  ctx.fillRect(Math.floor(ball.x-4),Math.floor(ball.y-4),8,8);
  ctx.fillStyle='#fff';
  ctx.fillRect(Math.floor(ball.x-2),Math.floor(ball.y-4),3,2);

  // Serve prompt
  if(serveReady&&!ball.inPlay&&servingSide==='left'){
    ctx.fillStyle=`rgba(255,224,51,${0.5+0.3*Math.sin(Date.now()*0.005)})`;
    ctx.font='bold 12px "Courier New"'; ctx.textAlign='center';
    ctx.fillText('CLICK or SPACE to Serve',player.x,player.y-75);
  }
}

function drawPowerups(){
  for(const pu of powerups){
    const bob=Math.sin(frameCount*0.05+pu.bobPhase)*4;
    const x=Math.floor(pu.x), y=Math.floor(pu.y+bob);
    const blink = pu.timer<80 && Math.floor(pu.timer/6)%2===0;
    if(blink) continue;

    // Glow
    ctx.save();
    ctx.globalAlpha=0.3+0.15*Math.sin(frameCount*0.08);
    ctx.shadowColor=pu.type.color; ctx.shadowBlur=12;
    ctx.fillStyle=pu.type.color;
    ctx.beginPath(); ctx.arc(x,y,14,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // Box
    ctx.fillStyle='rgba(0,0,0,0.7)';
    ctx.fillRect(x-12,y-12,24,24);
    ctx.strokeStyle=pu.type.color; ctx.lineWidth=2;
    ctx.strokeRect(x-12,y-12,24,24);

    // Icon text
    ctx.fillStyle=pu.type.color;
    ctx.font='bold 10px "Courier New"'; ctx.textAlign='center';
    ctx.fillText(pu.type.icon,x,y+4);
  }
}

function drawActivePowerupHUD(){
  if(activePowerups.length===0) return;
  const baseY = savedUpgrades.length>0 ? 52 : 35;
  ctx.fillStyle='rgba(10,10,20,0.8)';
  ctx.fillRect(0,baseY,W,18);

  let tx=10;
  for(const ap of activePowerups){
    const pct=ap.remaining/ap.type.duration;
    // Icon
    ctx.fillStyle=ap.type.color;
    ctx.font='bold 10px "Courier New"'; ctx.textAlign='left';
    ctx.fillText(ap.type.name,tx,baseY+13);
    tx+=ctx.measureText(ap.type.name).width+8;
    // Timer bar
    ctx.fillStyle='rgba(255,255,255,0.15)';
    ctx.fillRect(tx,baseY+5,40,8);
    ctx.fillStyle=ap.type.color;
    ctx.fillRect(tx,baseY+5,40*pct,8);
    tx+=50;
  }
}

function drawHUD(){
  ctx.fillStyle=COL.panel; ctx.fillRect(0,0,W,32);

  ctx.font='bold 14px "Courier New"';
  ctx.textAlign='left'; ctx.fillStyle=COL.p1;
  ctx.fillText(`YOU: ${playerScore}`,20,22);

  ctx.textAlign='right'; ctx.fillStyle=COL.p2;
  const oppName=OPPONENTS[currentOpponentIdx]?OPPONENTS[currentOpponentIdx].name.toUpperCase():'CPU';
  ctx.fillText(`${oppName}: ${opponentScore}`,W-20,22);

  ctx.textAlign='center'; ctx.fillStyle=COL.muted;
  ctx.font='11px "Courier New"';
  ctx.fillText(`First to ${scoreToWin} | Round ${currentOpponentIdx+1}/7`,W/2,14);

  ctx.fillStyle=COL.accent; ctx.font='10px "Courier New"';
  ctx.fillText(servingSide==='left'?'\u25CF YOUR SERVE':'\u25CF THEIR SERVE',W/2,26);

  // Kitchen fault
  if(kitchenFaultTimer>0){
    const alpha=kitchenFaultTimer/90;
    ctx.fillStyle=`rgba(255,100,30,${alpha*0.3})`; ctx.fillRect(0,0,W,H);
    ctx.fillStyle=`rgba(255,170,51,${alpha})`;
    ctx.font='bold 28px "Courier New"'; ctx.textAlign='center';
    ctx.fillText('KITCHEN FAULT!',W/2,H/2-40);
    ctx.font='14px "Courier New"';
    ctx.fillText('No volleys in the Non-Volley Zone!',W/2,H/2-10);
  }

  // Controls
  ctx.fillStyle=COL.muted; ctx.font='9px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('\u2190 \u2192 Move | CLICK/SPACE Hit | Right-Click/X Lob',W/2,H-10);

  // Buffs
  if(savedUpgrades.length>0){
    ctx.fillStyle='rgba(10,10,20,0.7)'; ctx.fillRect(0,33,W,16);
    ctx.fillStyle=COL.accent2; ctx.font='9px "Courier New"'; ctx.textAlign='left';
    ctx.fillText('Buffs: '+savedUpgrades.map(u=>u.icon+u.name).join('  '),10,44);
  }

  drawActivePowerupHUD();
}

function drawParticles(){
  for(const p of particles){
    ctx.globalAlpha=p.life/p.maxLife;
    ctx.fillStyle=p.color;
    ctx.fillRect(Math.floor(p.x),Math.floor(p.y),Math.ceil(p.size),Math.ceil(p.size));
  }
  ctx.globalAlpha=1;
}

// ---- Crosshair cursor on canvas ----
function drawCrosshair(){
  if(state!==STATE.PLAYING) return;
  const cx=mouseX, cy=mouseY;
  ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(cx-8,cy); ctx.lineTo(cx+8,cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx,cy-8); ctx.lineTo(cx,cy+8); ctx.stroke();
  ctx.strokeStyle='rgba(255,255,255,0.15)';
  ctx.beginPath(); ctx.arc(cx,cy,12,0,Math.PI*2); ctx.stroke();
}

// ---- Screen draws ----
function drawTitle(){
  drawSky(); drawCourt();
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H);

  // Glowing title with CRT phosphor feel
  ctx.save();
  ctx.shadowColor='#ff8a3d'; ctx.shadowBlur=30;
  ctx.fillStyle=COL.accent; ctx.font='bold 42px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('DINK CITY',W/2,130);
  ctx.shadowBlur=15;
  ctx.fillText('DINK CITY',W/2,130);
  ctx.restore();

  ctx.fillStyle=COL.accent2; ctx.font='bold 14px "Courier New"';
  ctx.save(); ctx.shadowColor='#49d0ff'; ctx.shadowBlur=10;
  ctx.fillText('RETRO PICKLEBALL ROGUELIKE',W/2,160);
  ctx.restore();

  ctx.fillStyle=COL.text; ctx.font='12px "Courier New"';
  const lines=[
    'Defeat 7 opponents in a bracket tournament.',
    'Earn upgrades between rounds.',
    'Collect power-ups during matches!',
    'Lose once and it\'s all over!',
    '',
    '\u2190 \u2192 / A D    to move',
    'CLICK / SPACE  to hit & serve',
    'RIGHT-CLICK / X  to lob',
    '',
    '\u26A0 KITCHEN RULES ENFORCED \u26A0',
    'No volleys in the Non-Volley Zone!',
  ];
  lines.forEach((l,i)=>{
    ctx.fillStyle=l.includes('KITCHEN')?COL.kitchenLine:l.includes('power-ups')?'#ff44ff':COL.text;
    ctx.fillText(l,W/2,198+i*18);
  });

  const blink=Math.sin(Date.now()*0.005)>0;
  if(blink){
    ctx.save(); ctx.shadowColor=COL.accent; ctx.shadowBlur=12;
    ctx.fillStyle=COL.accent; ctx.font='bold 16px "Courier New"';
    ctx.fillText('[ CLICK or SPACE TO START ]',W/2,430);
    ctx.restore();
  }

  // Bracket
  ctx.fillStyle=COL.muted; ctx.font='10px "Courier New"'; ctx.fillText('BRACKET',W/2,452);
  for(let i=0;i<7;i++){
    const bx=W/2-100+i*30;
    ctx.strokeStyle=COL.muted; ctx.lineWidth=1; ctx.strokeRect(bx,458,22,18);
    ctx.fillStyle=COL.muted; ctx.font='8px "Courier New"'; ctx.textAlign='center';
    ctx.fillText(OPPONENTS[i].name[0],bx+11,471);
  }
}

function drawMatchIntro(){
  drawSky(); drawCourt();
  ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H);
  const opp=OPPONENTS[currentOpponentIdx];

  ctx.fillStyle=COL.muted; ctx.font='bold 14px "Courier New"'; ctx.textAlign='center';
  ctx.fillText(`\u2014 ROUND ${currentOpponentIdx+1} OF 7 \u2014`,W/2,120);

  // Bracket
  for(let i=0;i<7;i++){
    const bx=W/2-100+i*30;
    let col=COL.muted, bg='transparent';
    if(i<currentOpponentIdx){col=COL.accent3;bg='rgba(134,239,172,0.1)';}
    else if(i===currentOpponentIdx){col=COL.accent;bg='rgba(255,138,61,0.15)';}
    ctx.fillStyle=bg; ctx.fillRect(bx,135,22,18);
    ctx.strokeStyle=col; ctx.lineWidth=1.5; ctx.strokeRect(bx,135,22,18);
    ctx.fillStyle=col; ctx.font='8px "Courier New"'; ctx.textAlign='center';
    ctx.fillText(OPPONENTS[i].name[0],bx+11,148);
  }

  ctx.fillStyle=COL.text; ctx.font='bold 24px "Courier New"'; ctx.fillText('VS',W/2,200);

  ctx.save(); ctx.shadowColor=opp.color; ctx.shadowBlur=20;
  ctx.fillStyle=opp.color; ctx.font='bold 28px "Courier New"';
  ctx.fillText(opp.name.toUpperCase(),W/2,250);
  ctx.restore();
  ctx.fillStyle=COL.muted; ctx.font='italic 12px "Courier New"';
  ctx.fillText(`"${opp.title}"`,W/2,272);

  [{label:'Speed',val:opp.speed/3.5},{label:'Power',val:opp.power},{label:'Accuracy',val:opp.accuracy}].forEach((s,i)=>{
    const sx=W/2-80, sy=300+i*22;
    ctx.fillStyle=COL.muted; ctx.font='11px "Courier New"'; ctx.textAlign='left';
    ctx.fillText(s.label,sx,sy);
    ctx.fillStyle='rgba(255,255,255,0.1)'; ctx.fillRect(sx+80,sy-8,80,8);
    ctx.fillStyle=opp.color; ctx.fillRect(sx+80,sy-8,80*Math.min(1,s.val),8);
  });

  if(savedUpgrades.length>0){
    ctx.fillStyle=COL.accent2; ctx.font='11px "Courier New"'; ctx.textAlign='center';
    ctx.fillText('Your buffs:',W/2,385);
    ctx.fillStyle=COL.text; ctx.font='10px "Courier New"';
    ctx.fillText(savedUpgrades.map(u=>u.icon+u.name).join('  '),W/2,402);
  }

  const blink=Math.sin(Date.now()*0.005)>0;
  if(blink){
    ctx.save(); ctx.shadowColor=COL.accent; ctx.shadowBlur=10;
    ctx.fillStyle=COL.accent; ctx.font='bold 14px "Courier New"'; ctx.textAlign='center';
    ctx.fillText('[ CLICK or SPACE TO FIGHT ]',W/2,450);
    ctx.restore();
  }
}

function drawUpgradeScreen(){
  drawSky();
  ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,0,W,H);

  ctx.save(); ctx.shadowColor=COL.accent3; ctx.shadowBlur=20;
  ctx.fillStyle=COL.accent3; ctx.font='bold 28px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('VICTORY!',W/2,80);
  ctx.restore();

  ctx.fillStyle=COL.text; ctx.font='14px "Courier New"'; ctx.fillText('Choose an upgrade:',W/2,120);

  for(let i=0;i<selectedUpgrades.length;i++){
    const u=selectedUpgrades[i];
    const cx=W/2-240+i*200, cy=160, cw=180, ch=200;
    const hover=upgradeSelection===i;

    if(hover){
      ctx.save(); ctx.shadowColor=COL.accent; ctx.shadowBlur=15;
      ctx.fillStyle='rgba(255,138,61,0.15)'; ctx.fillRect(cx,cy,cw,ch);
      ctx.restore();
    } else {
      ctx.fillStyle='rgba(255,255,255,0.05)'; ctx.fillRect(cx,cy,cw,ch);
    }
    ctx.strokeStyle=hover?COL.accent:'rgba(255,255,255,0.15)';
    ctx.lineWidth=hover?2:1; ctx.strokeRect(cx,cy,cw,ch);

    ctx.font='36px serif'; ctx.textAlign='center'; ctx.fillText(u.icon,cx+cw/2,cy+60);
    ctx.fillStyle=COL.text; ctx.font='bold 13px "Courier New"'; ctx.fillText(u.name,cx+cw/2,cy+100);
    ctx.fillStyle=COL.muted; ctx.font='11px "Courier New"'; ctx.fillText(u.desc,cx+cw/2,cy+125);
    ctx.fillStyle=COL.accent; ctx.font='bold 14px "Courier New"'; ctx.fillText(`[ ${i+1} ]`,cx+cw/2,cy+170);
  }

  ctx.fillStyle=COL.muted; ctx.font='11px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('Press 1, 2, 3 or click to choose',W/2,400);
}

function drawGameOver(){
  drawSky(); drawCourt();
  ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,0,W,H);

  ctx.save(); ctx.shadowColor='#ff4444'; ctx.shadowBlur=25;
  ctx.fillStyle='#ff4444'; ctx.font='bold 36px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('GAME OVER',W/2,180);
  ctx.restore();

  ctx.fillStyle=COL.muted; ctx.font='14px "Courier New"';
  ctx.fillText(`Defeated by ${OPPONENTS[currentOpponentIdx].name} in Round ${currentOpponentIdx+1}`,W/2,220);
  ctx.fillStyle=COL.text; ctx.font='12px "Courier New"';
  ctx.fillText(`Rounds won: ${currentOpponentIdx} / 7`,W/2,260);

  if(savedUpgrades.length>0){
    ctx.fillText('Upgrades collected:',W/2,290);
    ctx.fillStyle=COL.accent2; ctx.font='10px "Courier New"';
    ctx.fillText(savedUpgrades.map(u=>u.icon+u.name).join('  '),W/2,310);
  }

  const blink=Math.sin(Date.now()*0.005)>0;
  if(blink){
    ctx.save(); ctx.shadowColor=COL.accent; ctx.shadowBlur=10;
    ctx.fillStyle=COL.accent; ctx.font='bold 14px "Courier New"';
    ctx.fillText('[ CLICK or SPACE TO TRY AGAIN ]',W/2,380);
    ctx.restore();
  }
}

function drawVictory(){
  drawSky();
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,W,H);
  if(Math.random()<0.3) addParticles(Math.random()*W,-10,['#ff4444','#44ff44','#4444ff','#ffff44','#ff44ff'][Math.floor(Math.random()*5)],1);
  drawParticles();

  ctx.save(); ctx.shadowColor=COL.accent3; ctx.shadowBlur=30;
  ctx.fillStyle=COL.accent3; ctx.font='bold 42px "Courier New"'; ctx.textAlign='center';
  ctx.fillText('CHAMPION!',W/2,160);
  ctx.restore();

  ctx.fillStyle=COL.accent; ctx.font='bold 16px "Courier New"';
  ctx.fillText('You conquered Dink City!',W/2,200);
  ctx.fillStyle=COL.text; ctx.font='12px "Courier New"';
  ctx.fillText('All 7 opponents defeated!',W/2,240);

  if(savedUpgrades.length>0){
    ctx.fillText('Final build:',W/2,280);
    ctx.fillStyle=COL.accent2; ctx.font='10px "Courier New"';
    ctx.fillText(savedUpgrades.map(u=>u.icon+u.name).join('  '),W/2,300);
  }

  const blink=Math.sin(Date.now()*0.005)>0;
  if(blink){
    ctx.save(); ctx.shadowColor=COL.accent; ctx.shadowBlur=10;
    ctx.fillStyle=COL.accent; ctx.font='bold 14px "Courier New"';
    ctx.fillText('[ CLICK or SPACE TO PLAY AGAIN ]',W/2,380);
    ctx.restore();
  }
}

function drawPointScored(){
  drawSky(); drawCourt();
  drawPlayer(player,COL.p1,COL.p1Dark,'YOU');
  drawPlayer(opponent,COL.p2,COL.p2Dark,OPPONENTS[currentOpponentIdx].name.toUpperCase());
  drawBall(); drawPowerups(); drawParticles(); drawHUD();

  const alpha=Math.min(1,pointPause/60);
  ctx.fillStyle=`rgba(0,0,0,${alpha*0.4})`; ctx.fillRect(0,0,W,H);

  ctx.textAlign='center';
  if(playerScore>=scoreToWin){
    ctx.save(); ctx.shadowColor=COL.accent3; ctx.shadowBlur=20;
    ctx.fillStyle=COL.accent3; ctx.font='bold 32px "Courier New"';
    ctx.fillText('MATCH WON!',W/2,H/2); ctx.restore();
  } else if(opponentScore>=scoreToWin){
    ctx.save(); ctx.shadowColor='#ff4444'; ctx.shadowBlur=20;
    ctx.fillStyle='#ff4444'; ctx.font='bold 32px "Courier New"';
    ctx.fillText('MATCH LOST!',W/2,H/2); ctx.restore();
  } else {
    ctx.save(); ctx.shadowColor='#fff'; ctx.shadowBlur=10;
    ctx.font='bold 24px "Courier New"'; ctx.fillStyle=COL.text;
    ctx.fillText(`${playerScore} - ${opponentScore}`,W/2,H/2);
    ctx.restore();
  }
}

// ---- Phosphor bloom pass ----
function updatePhosphor(){
  phosphorCtx.drawImage(canvas,0,0);
}

// ---- CRT chromatic aberration (subtle, drawn into main canvas) ----
function drawChromaticAberration(){
  // Subtle RGB offset at edges
  const imgData = ctx.getImageData(0,0,W,H);
  // Too expensive per-frame; instead we use CSS filters on the phosphor layer
  // The phosphor canvas + blur gives us the bloom effect
}

// ---- Main draw ----
function draw(){
  ctx.clearRect(0,0,W,H);

  // CRT warm background (slight color tint)
  ctx.fillStyle='#080810'; ctx.fillRect(0,0,W,H);

  if(shakeTimer>0){
    ctx.save();
    ctx.translate((Math.random()-0.5)*shakeIntensity,(Math.random()-0.5)*shakeIntensity);
  }

  switch(state){
    case STATE.TITLE: drawTitle(); break;
    case STATE.MATCH_INTRO: drawMatchIntro(); break;
    case STATE.PLAYING:
      drawSky(); drawCourt(); drawPowerups();
      drawPlayer(player,COL.p1,COL.p1Dark,'YOU');
      drawPlayer(opponent,COL.p2,COL.p2Dark,OPPONENTS[currentOpponentIdx].name.toUpperCase());
      drawBall(); drawParticles(); drawHUD(); drawCrosshair();
      break;
    case STATE.POINT_SCORED: drawPointScored(); break;
    case STATE.UPGRADE: drawUpgradeScreen(); break;
    case STATE.GAME_OVER: drawGameOver(); break;
    case STATE.VICTORY: drawVictory(); break;
  }

  if(shakeTimer>0) ctx.restore();

  // Update phosphor bloom layer
  updatePhosphor();
}

// ---- Input handling for menus ----
window.addEventListener('keydown', function(e){
  if(state===STATE.TITLE){
    if(e.code==='Space'||e.key==='z'||e.key==='Z'){ currentOpponentIdx=0; savedUpgrades=[]; state=STATE.MATCH_INTRO; }
  } else if(state===STATE.MATCH_INTRO){
    if(e.code==='Space'||e.key==='z'||e.key==='Z'){
      initMatch();
      for(const upg of savedUpgrades) upg.apply(player);
      state=STATE.PLAYING;
    }
  } else if(state===STATE.UPGRADE){
    if(e.key==='1') selectUpgrade(0);
    else if(e.key==='2') selectUpgrade(1);
    else if(e.key==='3') selectUpgrade(2);
  } else if(state===STATE.GAME_OVER||state===STATE.VICTORY){
    if(e.code==='Space') state=STATE.TITLE;
  }
});

// Mouse click for menus & upgrades
canvas.addEventListener('click', function(e){
  const rect=canvas.getBoundingClientRect();
  const mx=(e.clientX-rect.left)/SCALE, my=(e.clientY-rect.top)/SCALE;

  if(state===STATE.UPGRADE){
    for(let i=0;i<3;i++){
      const cx=W/2-240+i*200,cy=160;
      if(mx>=cx&&mx<=cx+180&&my>=cy&&my<=cy+200){ selectUpgrade(i); return; }
    }
  }
  if(state===STATE.TITLE||state===STATE.MATCH_INTRO||state===STATE.GAME_OVER||state===STATE.VICTORY){
    const evt=new KeyboardEvent('keydown',{code:'Space',key:' '});
    window.dispatchEvent(evt);
  }
});

canvas.addEventListener('mousemove', function(e){
  if(state===STATE.UPGRADE){
    const rect=canvas.getBoundingClientRect();
    const mx=(e.clientX-rect.left)/SCALE, my=(e.clientY-rect.top)/SCALE;
    upgradeSelection=-1;
    for(let i=0;i<3;i++){
      const cx=W/2-240+i*200,cy=160;
      if(mx>=cx&&mx<=cx+180&&my>=cy&&my<=cy+200){upgradeSelection=i;break;}
    }
  }
});

// ---- Game loop ----
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}
gameLoop();

</script>
</body>
</html>
