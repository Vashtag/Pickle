<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>PicklePop — 2D Canvas Edition (GPU-free)</title>
<style>
  html,body{margin:0;height:100%;background:#0a0f17;overflow:hidden}
  #ui, #fault, #nvzHint, #help, #hud { position:fixed; color:#e8f0ff; font:600 14px/1.3 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial }
  #hud{ left:12px; top:12px; background:rgba(10,15,23,.55); backdrop-filter:blur(6px); padding:10px 12px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.35) }
  #hud .big{ font-size:18px }
  #hud .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.08); margin-left:6px }
  #fault{ left:50%; top:50%; transform:translate(-50%,-50%); display:none; font:800 28px/1 ui-sans-serif; letter-spacing:.5px;
          background:linear-gradient(180deg, rgba(255,60,60,.92), rgba(180,0,0,.9)); padding:16px 18px; border-radius:14px; box-shadow:0 20px 50px rgba(0,0,0,.5) }
  #nvzHint{ left:50%; bottom:70px; transform:translateX(-50%); display:none; font-weight:800;
            background:rgba(255,45,45,.85); padding:8px 10px; border-radius:10px }
  #help{ right:12px; bottom:12px; max-width:min(42ch,45vw); background:rgba(10,15,23,.55); backdrop-filter:blur(6px);
         padding:10px 12px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.35) }
  #centerMsg{ position:fixed; left:50%; top:10px; transform:translateX(-50%); font:700 20px/1 ui-sans-serif; opacity:.95;
              color:#f5f9ff; background:rgba(14,22,32,.6); backdrop-filter:blur(8px); padding:10px 14px; border-radius:12px }
  canvas{ display:block; width:100vw; height:100vh; background:linear-gradient(#20324f,#132237) }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="big">Score: <span id="pScore">0</span> – <span id="aiScore">0</span> <span class="pill" id="serverPill">Serve: You</span></div>
  <div>Side: <span id="sidePill">Right</span> • To 11 (win by 2) • Aim-assist ON</div>
  <div id="lastMsg" style="opacity:.9;margin-top:6px"></div>
</div>

<div id="fault">FAULT</div>
<div id="nvzHint">NVZ VOLLEY = FAULT</div>
<div id="help">
  <b>Controls</b>: WASD move, Shift sprint, Ctrl reach (tighter contact), <b>Space (hold)</b> serve, <b>Left-click</b> hit, Q/E tilt (spin/arc).<br/>
  <b>Rules</b>: Singles, to 11 (win by 2). Kitchen (NVZ) volley faults. Serve must land diagonally in the box.
</div>
<div id="centerMsg">Move with WASD • Aim with mouse • Space to serve</div>

<script>
/* =========================
   Dimensions / constants
========================= */
const COURT_W = 6.10; // meters (x, left-right)
const COURT_L = 13.41; // meters (z, up-down)
const HALF_W = COURT_W/2;
const HALF_L = COURT_L/2;
const NVZ = 2.13; // kitchen depth from net
const NET_H_CENTER = 0.86, NET_H_SIDE = 0.914;
const BALL_R = 0.037; // 74mm/2
const GRAV = -9.81;
const DRAG_K = 0.9, MAGNUS_K = 0.0006;
const DT_FIXED = 1/120;
const SERVE_MIN = 0.4, SERVE_MAX = 1.0;

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
function netHeightAtX(x){
  const t = clamp(Math.abs(x)/HALF_W, 0, 1);
  const s = t*t*(3-2*t);
  return lerp(NET_H_CENTER, NET_H_SIDE, s);
}

/* =========================
   Canvas + scale helpers
========================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W=innerWidth, H=innerHeight, S=1, courtPxW, courtPxL, cx, cz;
function fit(){
  W=canvas.width=innerWidth; H=canvas.height=innerHeight;
  // fit court within viewport with margins
  const pad = Math.min(W,H)*0.08;
  const availW = W - pad*2, availH = H - pad*2;
  const aspect = COURT_W/COURT_L;
  if(availW/availH > aspect){
    courtPxL = availH;
    courtPxW = availH*aspect;
  }else{
    courtPxW = availW;
    courtPxL = availW/aspect;
  }
  S = courtPxW/COURT_W; // pixels per meter
  cx = (W-courtPxW)/2;
  cz = (H-courtPxL)/2;
}
addEventListener('resize', fit); fit();

// world (x,z) → screen (px,py) top-down
function toScreen(x,z){
  const px = cx + (x + HALF_W)*S;
  const py = cz + (z + HALF_L)*S;
  return [px, py];
}

/* =========================
   Game state
========================= */
const keys = new Set();
const mouse = {x:0, y:0, down:false};
addEventListener('mousemove', e=>{ mouse.x=e.clientX; mouse.y=e.clientY; });
addEventListener('mousedown', e=>{ if(e.button===0){ mouse.down=true; tryHit(); } });
addEventListener('mouseup', e=>{ if(e.button===0) mouse.down=false; });
addEventListener('keydown', e=>{ keys.add(e.code); if(e.code==='Space') beginServeCharge(); if(e.code==='Tab') e.preventDefault(); });
addEventListener('keyup', e=>{ 
  keys.delete(e.code); 
  if(e.code==='Space') releaseServe();
});

const hud = {
  pScore: document.getElementById('pScore'),
  aiScore: document.getElementById('aiScore'),
  serverPill: document.getElementById('serverPill'),
  sidePill: document.getElementById('sidePill'),
  lastMsg: document.getElementById('lastMsg'),
  centerMsg: document.getElementById('centerMsg'),
  fault: document.getElementById('fault'),
  nvz: document.getElementById('nvzHint')
};

const score = { player:0, ai:0 };

const player = {
  x: 0, z: -HALF_L+1.5, speed: 5.5, sprint: 8.0,
  tilt: 0, // -0.22..0.22 (radians-ish)
  crouch: 0
};
const ai = {
  x: 0, z: HALF_L-1.6, speed: 5.0, cool: 0
};

const ball = {
  x: 0, y: 1.0, z: -HALF_L+0.8, // y = height above floor
  vx: 0, vy: 0, vz: 0,
  ox: 0, oy: 0, oz: 0, // spin
  lastZ: -HALF_L+0.8,
  lastHitter: 'none', // 'player' | 'ai'
  inPlay: false,
  serving: 'player',
  serveSide: 'right', // right/left (server POV)
  awaitingServe: true,
  bouncesSinceServe: 0,
  sideNow: 'player', // which side of court last known
  groundBouncesSinceSide: 0
};

let serveHold = 0; // charging timer

function updateHUD(){
  hud.pScore.textContent = score.player;
  hud.aiScore.textContent = score.ai;
  hud.serverPill.textContent = `Serve: ${ball.serving==='player'?'You':'AI'}`;
  hud.sidePill.textContent = ball.serveSide==='right'?'Right':'Left';
}

function resetForServe(serving){
  ball.serving = serving;
  ball.awaitingServe = true;
  ball.inPlay = false;
  ball.bouncesSinceServe = 0;
  ball.ox=ball.oy=ball.oz=0; ball.vx=ball.vy=ball.vz=0;

  const s = ((serving==='player'?score.player:score.ai)%2===0) ? 'right' : 'left';
  ball.serveSide = s;
  updateHUD();

  if(serving==='player'){
    player.x = (s==='right'? 1.0:-1.0);
    player.z = -HALF_L + 1.2;
    ai.x = 0; ai.z = HALF_L - 1.6;
  }else{
    player.x = 0; player.z = -HALF_L + 1.6;
    ai.x = (s==='right'? -1.0:1.0); ai.z = HALF_L - 1.2;
  }
  const bx = (serving==='player') ? (s==='right'? 1.0:-1.0) : (s==='right'?-1.0:1.0);
  const bz = (serving==='player') ? (player.z + 0.4) : (ai.z - 0.4);
  ball.x=bx; ball.z=bz; ball.y=1.0;
  ball.lastZ = ball.z;
  ball.sideNow = (serving==='player')?'player':'ai';
  hud.lastMsg.textContent = `${serving==='player'?'Your':'AI'} serve — ${s} side`;
}
resetForServe('player');

/* =========================
   Serve handling
========================= */
function beginServeCharge(){
  if(ball.awaitingServe && ball.serving==='player' && serveHold===0){
    serveHold = 0.0001;
    hud.lastMsg.textContent = 'Hold Space, release to serve (diagonal)';
  }
}
function releaseServe(){
  if(!(ball.awaitingServe && ball.serving==='player' && serveHold>0)) { serveHold=0; return; }
  const t = clamp(serveHold, SERVE_MIN, SERVE_MAX);
  const pow = lerp(7,18,(t-SERVE_MIN)/(SERVE_MAX-SERVE_MIN));
  const toLeft = (ball.serveSide==='left'); // from player POV
  const targetX = (toLeft? 1:-1) * 1.1;
  const targetZ = HALF_L - NVZ - (COURT_L/4 - NVZ/2)*0.6;
  const dirx = targetX - ball.x;
  const dirz = targetZ - ball.z;
  let len = Math.hypot(dirx, dirz); if(len<1e-6) len=1e-6;
  // underhand: upward vertical component
  const nx = dirx/len, nz = dirz/len, ny = 0.35;
  ball.vx = nx*pow; ball.vz = nz*pow; ball.vy = Math.abs(ny)*pow*0.35;
  ball.ox = 0; ball.oy = (toLeft?-1:1)*15; ball.oz = 70;
  ball.awaitingServe = false; ball.inPlay = true; ball.lastHitter='player';
  hud.lastMsg.textContent = '';
  serveHold = 0;
}

function updateServeHold(dt){
  if(ball.awaitingServe && ball.serving==='player' && serveHold>0){
    serveHold += dt; if(serveHold>SERVE_MAX) serveHold=SERVE_MAX;
  }
}

/* =========================
   AI
========================= */
function aiUpdate(dt){
  // Move to a reasonable intercept position
  const targetX = clamp(ball.x, -HALF_W+0.4, HALF_W-0.4);
  const baseZ = HALF_L - (ball.z>HALF_L*0.5 ? 1.8 : 2.4);
  const targetZ = baseZ;

  const dx = targetX - ai.x, dz = targetZ - ai.z;
  const dist = Math.hypot(dx,dz);
  if(dist>1e-3){
    const step = ai.speed * dt;
    const k = Math.min(1, step/dist);
    ai.x += dx*k; ai.z += dz*k;
  }
  ai.x = clamp(ai.x, -HALF_W+0.35, HALF_W-0.35);
  ai.z = clamp(ai.z, 0.2, HALF_L-0.4);

  ai.cool -= dt;
  // Hit if ball in reach and on AI side
  const reach = 0.95;
  const onAISide = ball.z>0;
  const inReach = Math.hypot(ball.x-ai.x, (ball.z - (ai.z-0.25))) < reach && Math.abs(ball.y-0.8)<1.2;
  if(ball.inPlay && onAISide && ai.cool<=0 && inReach){
    // Aim slightly cross-court to keep rallies going
    const tgtX = ball.x>0 ? -1.2 : 1.2;
    const tgtZ = -HALF_L + 1.8;
    const dirx = tgtX - ball.x, diry = 0.9 - ball.y, dirz = tgtZ - ball.z;
    const len = Math.hypot(dirx,diry,dirz)||1;
    const nx=dirx/len, ny=diry/len, nz=dirz/len;
    const spd = clamp(8 + (ball.y-0.5)*4, 6, 11);
    ball.vx = nx*spd; ball.vy = ny*spd; ball.vz = nz*spd;
    const sideSpin = (tgtX>0?-1:1)*25;
    ball.ox = 0; ball.oy = sideSpin; ball.oz = 55;
    ball.lastHitter='ai';
    ai.cool = 0.22;
  }
}

/* =========================
   Player movement, tilt, hit
========================= */
function updatePlayer(dt){
  // Movement
  const fwz = 1; // forward is +z on canvas
  let vx=0,vz=0;
  if(keys.has('KeyW')) vz += fwz;
  if(keys.has('KeyS')) vz -= fwz;
  if(keys.has('KeyA')) vx -= 1;
  if(keys.has('KeyD')) vx += 1;
  if(vx||vz){ const inv = 1/Math.hypot(vx,vz); vx*=inv; vz*=inv; }
  const spd = keys.has('ShiftLeft') ? player.sprint : player.speed;
  player.x += vx*spd*dt;
  player.z += vz*spd*dt;
  player.x = clamp(player.x, -HALF_W+0.35, HALF_W-0.35);
  player.z = clamp(player.z, -HALF_L+0.4, -0.2);

  // Tilt
  if(keys.has('KeyQ')) player.tilt += dt*0.7;
  if(keys.has('KeyE')) player.tilt -= dt*0.7;
  player.tilt = clamp(player.tilt, -0.22, 0.22);

  // Crouch
  const targetC = keys.has('ControlLeft') ? 1 : 0;
  player.crouch += (targetC - player.crouch)*Math.min(1, dt*12);
}

function tryHit(){
  if(!ball.inPlay) return;
  // Reach check
  const reach = 0.95;
  const inReach = Math.hypot(ball.x - player.x, (ball.z - (player.z+0.25))) < reach && Math.abs(ball.y-0.8)<1.2;
  if(!inReach) return;

  // NVZ volley fault (no ground bounce yet on this side and you're in NVZ area)
  const isVolley = (ball.z<0) && (ball.groundBouncesSinceSide===0);
  const inNVZ = (player.z>-NVZ && player.z<0);
  if(isVolley && inNVZ){ fault('NVZ Volley Fault (You)', 'ai'); return; }

  // Aim where the mouse points on court
  const [mx,my] = [mouse.x, mouse.y];
  // Convert mouse to world (x,z) clamped to court
  const x = clamp((mx - cx)/S - HALF_W, -HALF_W, HALF_W);
  const z = clamp((my - cz)/S - HALF_L, -HALF_L, HALF_L);

  // Build outgoing direction & speed
  const dirx = x - ball.x;
  const dirz = z - ball.z;
  const diry = (Math.sin(player.tilt)*0.9) + ((ball.y<1.0)?0.18:0.08);
  const len = Math.hypot(dirx, diry, dirz)||1;
  const nx=dirx/len, ny=diry/len, nz=dirz/len;
  const base = 9.5;
  const heightBonus = clamp((ball.y-0.6)*2.5, -1, 2.5);
  const spd = clamp(base + heightBonus, 6.5, 12.5);

  ball.vx = nx*spd; ball.vy = ny*spd; ball.vz = nz*spd;
  ball.ox = 0; ball.oy = -player.tilt*120; ball.oz = 65; // top + side from tilt
  ball.lastHitter='player';
}

/* =========================
   Physics & rules
========================= */
function physicsStep(dt){
  // Idle ball during serves
  if(ball.awaitingServe){
    if(ball.serving==='player'){
      // float near player
      ball.x = lerp(ball.x, player.x + (ball.serveSide==='right'?1.0:-1.0), 0.1);
      ball.z = lerp(ball.z, player.z + 0.4, 0.1);
      ball.y = lerp(ball.y, 1.0, 0.15);
    }else{
      // AI serve timer
      aiServeT -= dt;
      if(aiServeT<=0) aiDoServe();
    }
    return;
  }
  if(!ball.inPlay) return;

  // Integrate with drag + Magnus
  const vlen = Math.hypot(ball.vx,ball.vy,ball.vz);
  const drag = DRAG_K * vlen;
  // accelerations
  let ax = -drag*ball.vx + MAGNUS_K*(ball.oy*ball.vz - ball.oz*ball.vy);
  let ay = GRAV - drag*ball.vy + MAGNUS_K*(ball.oz*ball.vx - ball.ox*ball.vz);
  let az = -drag*ball.vz + MAGNUS_K*(ball.ox*ball.vy - ball.oy*ball.vx);

  ball.vx += ax*dt; ball.vy += ay*dt; ball.vz += az*dt;
  ball.x  += ball.vx*dt; ball.y  += ball.vy*dt; ball.z  += ball.vz*dt;

  // Ground bounce
  if(ball.y < BALL_R && ball.vy < 0){
    ball.y = BALL_R;
    ball.vy = -ball.vy * 0.45;
    ball.vx *= 0.85; ball.vz *= 0.85;
    ball.ox *= 0.90; ball.oy *= 0.90; ball.oz *= 0.90;
    ball.bouncesSinceServe++;

    // Track which side
    if(ball.z<0){
      ball.groundBouncesSinceSide = (ball.sideNow==='player') ? (ball.groundBouncesSinceSide+1) : 1;
      ball.sideNow = 'player';
    }else{
      ball.groundBouncesSinceSide = (ball.sideNow==='ai') ? (ball.groundBouncesSinceSide+1) : 1;
      ball.sideNow = 'ai';
    }

    // Serve validity: first bounce must be in diagonal receiver box
    if(ball.bouncesSinceServe===1){
      if(ball.lastHitter==='player' && !isInReceiverServiceBox('ai', ball.x, ball.z)){
        fault('Bad Serve (Service box)', 'ai'); return;
      }
      if(ball.lastHitter==='ai' && !isInReceiverServiceBox('player', ball.x, ball.z)){
        fault('AI Bad Serve', 'player'); return;
      }
    }
  }

  // Net crossing & height check
  if( (ball.lastZ<0 && ball.z>=0) || (ball.lastZ>0 && ball.z<=0) ){
    const nh = netHeightAtX(ball.x) + BALL_R*0.75;
    if(ball.y <= nh){
      fault(ball.lastHitter==='player'?'Net (You)':'Net (AI)', ball.lastHitter==='player'?'ai':'player'); return;
    }else{
      ball.groundBouncesSinceSide = 0;
      ball.sideNow = (ball.z>=0)?'ai':'player';
    }
  }
  ball.lastZ = ball.z;

  // OUT when ball touches ground outside court
  if(ball.y<=BALL_R+0.0001){
    const outX = Math.abs(ball.x) > HALF_W + 0.01;
    const outZ = Math.abs(ball.z) > HALF_L + 0.01;
    if(outX || outZ){
      const winner = (ball.lastHitter==='player') ? 'ai':'player';
      fault(outX?'OUT (sideline)':'OUT (baseline)', winner);
      return;
    }
  }
}

function isInReceiverServiceBox(receiver, x, z){
  const onFar = (receiver==='ai'); // ai side z>0
  if(onFar && z<0) return false;
  if(!onFar && z>0) return false;
  const inDepth = Math.abs(z) >= NVZ-0.02 && Math.abs(z) <= HALF_L+0.05;
  let mustLeft;
  if(ball.serving==='player'){ mustLeft = (ball.serveSide==='right'); } else { mustLeft = (ball.serveSide!=='right'); }
  const inHalf = mustLeft ? (x < 0) : (x > 0);
  return inDepth && inHalf && (Math.abs(x) <= HALF_W+0.03);
}

function fault(reason, pointTo){
  // Feedback
  hud.fault.textContent = 'FAULT — ' + reason;
  hud.fault.style.display='block';
  setTimeout(()=>hud.fault.style.display='none', 900);

  // Rally end scoring: if server won rally -> point, else side-out
  if(ball.serving === pointTo){ score[pointTo]++; } else { ball.serving = pointTo; }
  updateHUD();

  // Win by 2 to 11
  if( (score.player>=11 || score.ai>=11) && Math.abs(score.player - score.ai) >= 2 ){
    hud.lastMsg.textContent = (score.player>score.ai?'You win!':'AI wins!') + ' Refresh to play again.';
    ball.inPlay=false; ball.awaitingServe=false; return;
  }
  resetForServe(ball.serving);
}

/* AI serve */
let aiServeT = 1.2;
function aiDoServe(){
  if(!(ball.awaitingServe && ball.serving==='ai')) return;
  const hold = 0.7;
  const pow = lerp(7,18,(hold-SERVE_MIN)/(SERVE_MAX-SERVE_MIN));
  const toLeft = (ball.serveSide==='right'); // from AI POV
  const targetX = (toLeft?-1:1)*1.1;
  const targetZ = -HALF_L + NVZ + 1.6;
  const dirx = targetX - ball.x, dirz = targetZ - ball.z;
  let len = Math.hypot(dirx,dirz)||1;
  const nx=dirx/len, nz=dirz/len, ny=0.35;
  ball.vx = nx*pow; ball.vz = nz*pow; ball.vy = Math.abs(ny)*pow*0.35;
  ball.ox=0; ball.oy = (toLeft?1:-1)*15; ball.oz = 70;
  ball.awaitingServe=false; ball.inPlay=true; ball.lastHitter='ai';
  aiServeT = 1.2;
}

/* =========================
   Aim-assist (predict arc)
========================= */
const dots = new Array(7).fill(null).map(()=>({x:0,y:0,show:false,alpha:1}));
function updateDots(){
  dots.forEach(d=>d.show=false);

  // show when: ball in reach on your side OR serving (player)
  const reach = 0.95;
  const inReach = Math.hypot(ball.x - player.x, (ball.z - (player.z+0.25))) < reach && ball.z<0;
  const show = (ball.inPlay && inReach) || (ball.awaitingServe && ball.serving==='player');
  if(!show) return;

  // Hypothetical outgoing velocity
  let vx,vy,vz;
  if(ball.awaitingServe){
    const hold = (serveHold>0?serveHold:SERVE_MIN);
    const pow = lerp(7,18,(hold-SERVE_MIN)/(SERVE_MAX-SERVE_MIN));
    const toLeft = (ball.serveSide==='left');
    const targetX=(toLeft?1:-1)*1.1, targetZ=HALF_L - NVZ - (COURT_L/4 - NVZ/2)*0.6;
    const dx=targetX-ball.x, dz=targetZ-ball.z, L=Math.hypot(dx,dz)||1;
    const nx=dx/L, nz=dz/L, ny=0.35;
    vx=nx*pow; vy=Math.abs(ny)*pow*0.35; vz=nz*pow;
  }else{
    // mouse aim
    const mx = clamp((mouse.x - cx)/S - HALF_W, -HALF_W, HALF_W);
    const mz = clamp((mouse.y - cz)/S - HALF_L, -HALF_L, HALF_L);
    const dx=mx-ball.x, dz=mz-ball.z;
    const dy=(Math.sin(player.tilt)*0.9) + ((ball.y<1.0)?0.18:0.08);
    const L = Math.hypot(dx,dy,dz)||1;
    const nx=dx/L, ny=dy/L, nz=dz/L;
    const spd = 9.5;
    vx=nx*spd; vy=ny*spd; vz=nz*spd;
  }

  // simulate ~0.6s
  let px=ball.x, py=ball.y, pz=ball.z;
  let vvx=vx, vvy=vy, vvz=vz;
  for(let i=0;i<dots.length;i++){
    // small steps for smoother curve
    const step=0.1, sub=3;
    for(let s=0;s<sub;s++){
      const vlen = Math.hypot(vvx,vvy,vvz);
      const drag = DRAG_K*vlen*0.04; // lighter for preview
      const ax = -drag*vvx + MAGNUS_K*(ball.oy*vvz - ball.oz*vvy);
      const ay = GRAV - drag*vvy + MAGNUS_K*(ball.oz*vvx - ball.ox*vvz);
      const az = -drag*vvz + MAGNUS_K*(ball.ox*vvy - ball.oy*vvx);
      vvx += ax*(step/sub); vvy += ay*(step/sub); vvz += az*(step/sub);
      px  += vvx*(step/sub); py  += vvy*(step/sub); pz  += vvz*(step/sub);
      if(py<BALL_R){ vvy = Math.abs(vvy)*0.45; py=BALL_R; vvx*=0.87; vvz*=0.87; }
    }
    dots[i].x = px; dots[i].y = pz; dots[i].show = true; dots[i].alpha = 0.9 - i*0.12;
  }
}

/* =========================
   NVZ hint
========================= */
function updateNVZHint(){
  if(!ball.inPlay){ hud.nvz.style.display='none'; return; }
  const onPlayerSide = ball.z<0;
  const inNVZ = (player.z>-NVZ && player.z<0);
  const wasVolley = ball.groundBouncesSinceSide===0 && onPlayerSide;
  const close = Math.hypot(player.x-ball.x, player.z-ball.z)<1.2;
  hud.nvz.style.display = (inNVZ && wasVolley && close) ? 'block':'none';
}

/* =========================
   Render
========================= */
function drawCourt(){
  // Court base
  ctx.save();
  ctx.translate(cx, cz);
  ctx.fillStyle = '#1d7fb5'; ctx.fillRect(0,0,courtPxW,courtPxL);

  // Lines
  ctx.fillStyle='#ffffff';
  const line = Math.max(1, S*0.04);
  // Baselines
  ctx.fillRect(0, 0, courtPxW, line);
  ctx.fillRect(0, courtPxL-line, courtPxW, line);
  // Sidelines
  ctx.fillRect(0, 0, line, courtPxL);
  ctx.fillRect(courtPxW-line, 0, line, courtPxL);
  // Center service lines (stop at NVZ)
  const centerX = courtPxW/2 - (S*0.02);
  const nvzPx = NVZ*S;
  ctx.fillRect(centerX, courtPxL/2 - nvzPx, S*0.04, (courtPxL/2 - nvzPx));
  ctx.fillRect(centerX, courtPxL/2, S*0.04, -(courtPxL/2 - nvzPx));
  // Kitchen lines
  ctx.fillRect(0, courtPxL/2 - nvzPx - line/2, courtPxW, line);
  ctx.fillRect(0, courtPxL/2 + nvzPx - line/2, courtPxW, line);

  // Subtle outdoor props (fence lines)
  ctx.globalAlpha=0.35; ctx.strokeStyle='#6fa0c8'; ctx.lineWidth=1;
  for(let i=-3;i<=3;i++){
    const y = courtPxL/2 + i* (S*4.5);
    ctx.beginPath(); ctx.moveTo(-S*2, y); ctx.lineTo(courtPxW+S*2, y); ctx.stroke();
  }
  ctx.globalAlpha=1;
  ctx.restore();

  // Net
  ctx.save();
  ctx.translate(cx, cz);
  ctx.strokeStyle='rgba(42,47,54,0.7)'; ctx.lineWidth=1.2;
  const midY = courtPxL/2;
  ctx.beginPath(); ctx.moveTo(0, midY); ctx.lineTo(courtPxW, midY); ctx.stroke();
  ctx.restore();
}

function drawPlayers(){
  // Player + AI as circles
  const [px, pz] = toScreen(player.x, player.z);
  const [ax, az] = toScreen(ai.x, ai.z);
  ctx.fillStyle='#59a4ff'; ctx.beginPath(); ctx.arc(px, pz, 10, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#ff8b59'; ctx.beginPath(); ctx.arc(ax, az, 10, 0, Math.PI*2); ctx.fill();

  // Paddle tilt indicator (small arc near player)
  ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(px, pz-18, 12, -Math.PI/4 + player.tilt, Math.PI/4 + player.tilt);
  ctx.stroke();
}

function drawBall(){
  const [sx, sz] = toScreen(ball.x, ball.z);
  // Shadow (ellipse, darker when low)
  const alpha = clamp(1 - (ball.y/3), 0.2, 0.9);
  ctx.fillStyle = `rgba(0,0,0,${0.25*alpha})`;
  ctx.beginPath(); ctx.ellipse(sx, sz, 9, 5, 0, 0, Math.PI*2); ctx.fill();

  // Ball (height affects size/brightness)
  const radius = 6 + clamp(ball.y*2, 0, 6);
  ctx.fillStyle = '#ffef88';
  ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.arc(sx, sz - clamp(ball.y*6, 0, 18), radius, 0, Math.PI*2); ctx.fill(); ctx.stroke();
}

function drawDots(){
  for(const d of dots){
    if(!d.show) continue;
    const [sx,sy] = toScreen(d.x,d.y);
    ctx.fillStyle = `rgba(255,255,255,${d.alpha})`;
    ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
  }
}

/* =========================
   NVZ area highlight (optional)
========================= */
function drawNVZGlow(){
  // Show glow when you're inside NVZ
  if(player.z>-NVZ && player.z<0){
    ctx.save();
    ctx.globalAlpha=0.15;
    ctx.fillStyle='#ff2d2d';
    const y1 = cz + courtPxL/2 - NVZ*S, y2 = cz + courtPxL/2;
    ctx.fillRect(cx, y1, courtPxW, y2-y1);
    ctx.restore();
  }
}

/* =========================
   Main loop
========================= */
let acc=0, last=performance.now();
function loop(now){
  const dt = Math.min(0.05, (now-last)/1000); last = now; acc += dt;

  // Update
  updatePlayer(dt);
  aiUpdate(dt);
  updateServeHold(dt);
  updateDots();
  updateNVZHint();

  while(acc >= DT_FIXED){
    physicsStep(DT_FIXED);
    acc -= DT_FIXED;
  }

  // Draw
  ctx.clearRect(0,0,W,H);
  drawCourt();
  drawNVZGlow();
  drawDots();
  drawPlayers();
  drawBall();

  // Center tip fades after first serve
  if(!ball.awaitingServe || (ball.awaitingServe && ball.serving==='player' && serveHold>0)) {
    hud.centerMsg.style.display='none';
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =========================
   Utility UI updates
========================= */
updateHUD();

</script>
</body>
</html>
