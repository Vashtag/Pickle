<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Pickle Brawl â€” Roguelike Pickleball Tournament</title>
<style>
  @font-face { font-family:'PB'; src:local('Courier New'),local('Courier'),local(monospace); }
  :root {
    --bg:#0a0a14; --court:#1a3a1a; --line:#e8e8d0; --net:#ccccaa;
    --p1:#49d0ff; --p2:#ff6b4a; --ball:#ffe033;
    --accent:#ff8a3d; --accent2:#49d0ff; --accent3:#86efac;
    --panel:rgba(10,10,20,0.92); --text:#e6edf3; --muted:#7a8a9a;
    --crt-line:rgba(0,0,0,0.08);
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:var(--bg);color:var(--text);font-family:'PB',monospace;overflow:hidden;user-select:none;-webkit-user-select:none}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}

  /* Scanline overlay */
  #scanlines{position:fixed;inset:0;pointer-events:none;z-index:10;
    background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.06) 2px,rgba(0,0,0,0.06) 4px);
  }
  #crt-glow{position:fixed;inset:0;pointer-events:none;z-index:9;
    box-shadow:inset 0 0 80px rgba(0,0,0,0.5),inset 0 0 160px rgba(0,0,0,0.3);
    border-radius:8px;
  }

  /* Screens */
  .screen{position:fixed;inset:0;display:grid;place-items:center;z-index:20;background:rgba(0,0,0,0.85)}
  .card{background:var(--panel);border:2px solid rgba(255,255,255,0.1);border-radius:4px;padding:1.5rem;max-width:600px;width:min(600px,92vw);text-align:center}
  .card h1{font-size:1.8rem;margin-bottom:0.5rem;color:var(--accent);text-transform:uppercase;letter-spacing:3px;text-shadow:0 0 20px rgba(255,138,61,0.5)}
  .card h2{font-size:1.3rem;margin-bottom:0.5rem;color:var(--accent2);text-transform:uppercase;letter-spacing:2px}
  .card p{margin:0.4rem 0;font-size:0.85rem;color:var(--muted);line-height:1.5}
  .card .highlight{color:var(--ball);font-weight:bold}
  .btn{appearance:none;border:2px solid var(--accent);background:rgba(255,138,61,0.15);color:var(--accent);padding:0.6rem 1.4rem;font-family:inherit;font-size:1rem;font-weight:bold;text-transform:uppercase;letter-spacing:2px;cursor:pointer;border-radius:2px;transition:all 0.15s}
  .btn:hover{background:rgba(255,138,61,0.3);box-shadow:0 0 15px rgba(255,138,61,0.3)}
  .btn:active{transform:scale(0.97)}
  .btn-small{padding:0.4rem 0.8rem;font-size:0.8rem}

  /* Upgrade cards */
  .upgrades{display:grid;grid-template-columns:repeat(3,1fr);gap:0.6rem;margin:1rem 0}
  .upgrade-card{border:2px solid rgba(255,255,255,0.1);border-radius:4px;padding:0.8rem 0.5rem;cursor:pointer;transition:all 0.15s;background:rgba(255,255,255,0.03)}
  .upgrade-card:hover{border-color:var(--accent);background:rgba(255,138,61,0.1);box-shadow:0 0 12px rgba(255,138,61,0.2)}
  .upgrade-card .icon{font-size:1.8rem;margin-bottom:0.3rem}
  .upgrade-card .name{font-size:0.8rem;font-weight:bold;color:var(--text);margin-bottom:0.2rem}
  .upgrade-card .desc{font-size:0.65rem;color:var(--muted)}

  /* Bracket display */
  .bracket{display:flex;gap:0.3rem;margin:0.8rem 0;justify-content:center;flex-wrap:wrap}
  .bracket-slot{width:28px;height:28px;border:2px solid rgba(255,255,255,0.15);border-radius:2px;display:grid;place-items:center;font-size:0.6rem;font-weight:bold}
  .bracket-slot.won{border-color:var(--accent3);color:var(--accent3);background:rgba(134,239,172,0.1)}
  .bracket-slot.current{border-color:var(--accent);color:var(--accent);background:rgba(255,138,61,0.15);animation:pulse 1s infinite}
  .bracket-slot.lost{border-color:#ff4444;color:#ff4444;background:rgba(255,68,68,0.1)}
  .bracket-slot.future{opacity:0.3}
  @keyframes pulse{0%,100%{box-shadow:0 0 4px rgba(255,138,61,0.3)}50%{box-shadow:0 0 12px rgba(255,138,61,0.6)}}

  /* HUD */
  .hud{position:fixed;top:0;left:0;right:0;pointer-events:none;z-index:15;padding:0.5rem 0.8rem;display:flex;justify-content:space-between;align-items:flex-start}
  .hud-left,.hud-right,.hud-center{display:flex;gap:0.4rem;align-items:center}
  .hud-center{position:absolute;left:50%;transform:translateX(-50%);top:0.5rem}
  .chip{background:rgba(10,10,20,0.8);border:1px solid rgba(255,255,255,0.1);border-radius:2px;padding:0.25rem 0.5rem;font-size:0.75rem}
  .chip .label{color:var(--muted);margin-right:0.3rem}
  .chip strong{color:var(--text)}
  .score-big{font-size:1.6rem;font-weight:bold;min-width:3ch;text-align:center}
  .score-p1{color:var(--p1)}
  .score-p2{color:var(--p2)}

  /* Slow-mo indicator */
  .slowmo-bar{position:fixed;bottom:0.6rem;left:50%;transform:translateX(-50%);width:min(200px,40vw);height:8px;border:1px solid rgba(255,255,255,0.15);border-radius:2px;z-index:15;background:rgba(0,0,0,0.5);overflow:hidden;display:none}
  .slowmo-fill{height:100%;background:linear-gradient(90deg,var(--accent2),var(--accent3));transition:width 0.1s}

  /* Match result overlay */
  .match-result{position:fixed;inset:0;display:grid;place-items:center;z-index:25;background:rgba(0,0,0,0.8);display:none}
  .result-text{font-size:2.5rem;font-weight:bold;text-transform:uppercase;letter-spacing:4px;text-shadow:0 0 30px currentColor;animation:resultIn 0.5s ease-out}
  @keyframes resultIn{from{transform:scale(2);opacity:0}to{transform:scale(1);opacity:1}}
  .win-text{color:var(--accent3)}
  .lose-text{color:#ff4444}

  /* Opponent intro */
  .opponent-intro{margin:0.8rem 0}
  .opponent-name{font-size:1.2rem;font-weight:bold;color:var(--p2);text-transform:uppercase;letter-spacing:2px}
  .opponent-title{font-size:0.7rem;color:var(--muted);font-style:italic}
  .opponent-stats{display:flex;gap:0.5rem;justify-content:center;margin-top:0.4rem;flex-wrap:wrap}
  .stat{font-size:0.65rem;color:var(--muted)}
  .stat-bar{display:inline-block;width:40px;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;vertical-align:middle;margin-left:0.2rem;overflow:hidden}
  .stat-fill{height:100%;background:var(--p2);border-radius:2px}

  /* Player upgrades display */
  .player-buffs{display:flex;gap:0.3rem;justify-content:center;margin:0.5rem 0;flex-wrap:wrap}
  .buff{font-size:0.6rem;padding:0.15rem 0.4rem;border:1px solid rgba(73,208,255,0.3);border-radius:2px;color:var(--accent2);background:rgba(73,208,255,0.08)}
</style>
</head>
<body>
<div id="wrap"><canvas id="game"></canvas></div>
<div id="scanlines"></div>
<div id="crt-glow"></div>

<!-- HUD -->
<div class="hud" id="hud" style="display:none">
  <div class="hud-left">
    <div class="chip"><span class="label">Round</span><strong id="hudRound">1</strong>/8</div>
    <div class="chip"><span class="label">Match</span><strong id="hudMatch">QF1</strong></div>
  </div>
  <div class="hud-center">
    <span class="score-big score-p1" id="scoreP1">0</span>
    <span class="chip" style="color:var(--muted)">-</span>
    <span class="score-big score-p2" id="scoreP2">0</span>
  </div>
  <div class="hud-right">
    <div class="chip"><span class="label">Serving</span><strong id="hudServe">YOU</strong></div>
  </div>
</div>

<div class="slowmo-bar" id="slowmoBar"><div class="slowmo-fill" id="slowmoFill" style="width:100%"></div></div>

<!-- Title Screen -->
<div id="screenTitle" class="screen">
  <div class="card">
    <h1>Pickle Brawl</h1>
    <p style="color:var(--accent);font-size:0.9rem;margin-bottom:0.6rem">ROGUELIKE PICKLEBALL TOURNAMENT</p>
    <p>Fight through a bracket of 7 increasingly ruthless opponents.<br/>
    Between matches, choose powerful upgrades.<br/>
    <span class="highlight">Lose once and it's all over.</span></p>
    <p style="margin-top:0.6rem;font-size:0.75rem">
      <strong>Controls:</strong> Mouse/Touch = move paddle &bull; Auto-swing on contact<br/>
      Spacebar = activate Slow-Mo (when available)
    </p>
    <div style="margin-top:1rem"><button class="btn" id="btnStart">Enter Tournament</button></div>
  </div>
</div>

<!-- Pre-Match Screen -->
<div id="screenPreMatch" class="screen" style="display:none">
  <div class="card">
    <h2>Next Opponent</h2>
    <div class="opponent-intro">
      <div class="opponent-name" id="oppName">???</div>
      <div class="opponent-title" id="oppTitle"></div>
      <div class="opponent-stats" id="oppStats"></div>
    </div>
    <div class="bracket" id="bracketDisplay"></div>
    <div class="player-buffs" id="playerBuffs"></div>
    <p style="font-size:0.7rem;color:var(--muted);margin:0.5rem 0">First to <strong id="targetScore">5</strong> points wins the match</p>
    <div style="margin-top:0.8rem"><button class="btn" id="btnFight">Fight!</button></div>
  </div>
</div>

<!-- Upgrade Screen -->
<div id="screenUpgrade" class="screen" style="display:none">
  <div class="card">
    <h2>Victory! Choose an Upgrade</h2>
    <p style="font-size:0.75rem;color:var(--muted)">Pick one upgrade to carry into the next match</p>
    <div class="upgrades" id="upgradeGrid"></div>
  </div>
</div>

<!-- Game Over Screen -->
<div id="screenGameOver" class="screen" style="display:none">
  <div class="card">
    <h2 style="color:#ff4444">Tournament Over</h2>
    <p>You were eliminated in <strong id="goRound">Round 1</strong></p>
    <p>Opponents defeated: <strong id="goWins">0</strong></p>
    <p id="goMessage" style="color:var(--muted);margin-top:0.5rem"></p>
    <div style="margin-top:1rem"><button class="btn" id="btnRetry">Try Again</button></div>
  </div>
</div>

<!-- Champion Screen -->
<div id="screenChampion" class="screen" style="display:none">
  <div class="card">
    <h1 style="color:var(--accent3)">Champion!</h1>
    <p style="color:var(--accent3);font-size:1rem">You conquered the tournament!</p>
    <p style="margin-top:0.5rem">Upgrades collected: <strong id="champUpgrades">0</strong></p>
    <div class="player-buffs" id="champBuffs" style="margin:0.5rem 0"></div>
    <div style="margin-top:1rem"><button class="btn" id="btnNewRun">New Run</button></div>
  </div>
</div>

<!-- Match result flash -->
<div class="match-result" id="matchResult">
  <div class="result-text" id="resultText"></div>
</div>

<script>
(function(){
'use strict';

// ============================================================
// CONSTANTS
// ============================================================
const COURT_W = 640, COURT_H = 360;
const NET_X = COURT_W / 2;
const PADDLE_W = 8, PADDLE_H_BASE = 48;
const BALL_R = 5;
const BALL_SPEED_BASE = 280;
const SERVE_SPEED = 220;
const AI_SPEED_BASE = 160;
const KITCHEN_W = 80; // no-volley zone width from net
const WIN_SCORE_BASE = 5;
const GRAVITY = 320;

// Court boundaries (play area within canvas)
const MARGIN_TOP = 40, MARGIN_BOT = 20, MARGIN_SIDE = 30;
const PLAY_L = MARGIN_SIDE, PLAY_R = COURT_W - MARGIN_SIDE;
const PLAY_T = MARGIN_TOP, PLAY_B = COURT_H - MARGIN_BOT;

// ============================================================
// GAME STATE
// ============================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let DPR = Math.min(2, window.devicePixelRatio || 1);
let cW, cH, scaleX, scaleY;

// Screens
const screenTitle = document.getElementById('screenTitle');
const screenPreMatch = document.getElementById('screenPreMatch');
const screenUpgrade = document.getElementById('screenUpgrade');
const screenGameOver = document.getElementById('screenGameOver');
const screenChampion = document.getElementById('screenChampion');
const matchResult = document.getElementById('matchResult');
const hud = document.getElementById('hud');
const slowmoBar = document.getElementById('slowmoBar');

// Tournament state
let run = null; // current run data
let matchState = null; // current match

// Player upgrades (accumulated across run)
let upgrades = [];

// Input
let mouseY = COURT_H / 2;
let mouseActive = false;
let slowmoKey = false;

// Timing
let lastTime = 0, clock = 0;
let gamePhase = 'title'; // title, prematch, playing, point-scored, match-over, upgrading, gameover, champion

// ============================================================
// OPPONENT GENERATION
// ============================================================
const FIRST_NAMES = ['Crusher','Blitz','Shadow','Viper','Thunder','Spike','Ghost','Havoc','Fury','Ace','Phantom','Storm','Razor','Tank','Nova','Bolt','Fang','Hex','Jinx','Onyx'];
const LAST_NAMES = ['McSmash','Dinkerson','Paddleton','Volleysworth','Spinetti','Dropper','Slicer','Netburn','Courtside','Baseline'];
const TITLES = [
  'The Kitchen Dweller','Dink Master','Power Server','Spin Doctor','Net Ninja',
  'The Lob King','Baseline Brawler','Drop Shot Artist','The Wall','Rally Machine',
  'Speed Demon','Angle Grinder','The Finisher','Court Ghost','Paddle Fury'
];

function seededRand(seed) {
  let s = seed | 0;
  return () => { s |= 0; s = s + 0x6D2B79F5 | 0; let t = Math.imul(s ^ s >>> 15, 1 | s); t ^= t + Math.imul(t ^ t >>> 7, 61 | t); return ((t ^ t >>> 14) >>> 0) / 4294967296; };
}

function genOpponent(round, seed) {
  const r = seededRand(seed);
  const diff = 0.25 + (round / 7) * 0.7; // 0.25 to ~0.95
  const first = FIRST_NAMES[Math.floor(r() * FIRST_NAMES.length)];
  const last = LAST_NAMES[Math.floor(r() * LAST_NAMES.length)];
  const title = TITLES[Math.floor(r() * TITLES.length)];

  return {
    name: first + ' ' + last,
    title: title,
    speed: AI_SPEED_BASE * (0.6 + diff * 0.7),
    reaction: 0.25 - diff * 0.18, // lower = faster reaction
    accuracy: 0.5 + diff * 0.45,
    aggression: 0.3 + r() * 0.5,
    spinSkill: diff * 0.8,
    paddleH: PADDLE_H_BASE * (0.9 + r() * 0.2),
    color: `hsl(${Math.floor(r()*360)}, 70%, 60%)`,
    seed: seed
  };
}

// ============================================================
// UPGRADE POOL
// ============================================================
const ALL_UPGRADES = [
  { id:'bigger_paddle', icon:'ðŸ“', name:'Mega Paddle', desc:'+30% paddle size', effect:s=>{s.paddleMult*=1.3} },
  { id:'power_shots', icon:'ðŸ’¥', name:'Power Shots', desc:'+20% ball speed on hit', effect:s=>{s.powerMult*=1.2} },
  { id:'slowmo', icon:'â³', name:'Slow-Mo', desc:'Spacebar slows time (3s charge)', effect:s=>{s.hasSlowmo=true;s.slowmoMax+=3} },
  { id:'speed_up', icon:'âš¡', name:'Quick Feet', desc:'+25% paddle speed', effect:s=>{s.speedMult*=1.25} },
  { id:'spin_master', icon:'ðŸŒ€', name:'Spin Master', desc:'Add curve to your shots', effect:s=>{s.spinPower+=0.4} },
  { id:'magnet', icon:'ðŸ§²', name:'Ball Magnet', desc:'Ball curves toward paddle', effect:s=>{s.magnetStr+=25} },
  { id:'intimidate', icon:'ðŸ‘', name:'Intimidate', desc:'Opponent 15% slower', effect:s=>{s.oppDebuff*=0.85} },
  { id:'second_wind', icon:'ðŸ’¨', name:'Second Wind', desc:'+2 points needed to lose', effect:s=>{s.bonusHP+=2} },
  { id:'precise', icon:'ðŸŽ¯', name:'Precision', desc:'Tighter angle control', effect:s=>{s.precisionMult*=0.7} },
  { id:'wall', icon:'ðŸ§±', name:'The Wall', desc:'Paddle blocks wider area', effect:s=>{s.paddleMult*=1.15;s.speedMult*=1.1} },
  { id:'fire_serve', icon:'ðŸ”¥', name:'Fire Serve', desc:'Serves are 40% faster', effect:s=>{s.serveMult*=1.4} },
  { id:'ghost_ball', icon:'ðŸ‘»', name:'Ghost Ball', desc:'Ball flickers (harder to read)', effect:s=>{s.ghostBall=true} },
];

function pickUpgradeChoices(existing) {
  const pool = ALL_UPGRADES.filter(u => {
    const count = existing.filter(e => e.id === u.id).length;
    if (u.id === 'slowmo' && count >= 1) return false; // unique
    if (u.id === 'ghost_ball' && count >= 1) return false;
    if (u.id === 'second_wind' && count >= 2) return false;
    if (count >= 3) return false;
    return true;
  });
  // Shuffle and pick 3
  for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }
  return pool.slice(0, 3);
}

// ============================================================
// PLAYER STATS (computed from upgrades)
// ============================================================
function computePlayerStats(upgradeList) {
  const s = {
    paddleMult: 1, powerMult: 1, speedMult: 1, spinPower: 0,
    magnetStr: 0, oppDebuff: 1, bonusHP: 0, precisionMult: 1,
    serveMult: 1, hasSlowmo: false, slowmoMax: 0, ghostBall: false
  };
  for (const u of upgradeList) {
    const def = ALL_UPGRADES.find(a => a.id === u.id);
    if (def) def.effect(s);
  }
  return s;
}

// ============================================================
// AUDIO
// ============================================================
const Audio = (() => {
  let actx = null, master = null;
  function ensure() {
    if (actx) return;
    actx = new (window.AudioContext || window.webkitAudioContext)();
    master = actx.createGain(); master.gain.value = 0.15; master.connect(actx.destination);
  }
  function play(freq, dur, type='square', vol=0.5) {
    if (!actx) return;
    const o = actx.createOscillator(); o.type = type;
    const g = actx.createGain();
    o.frequency.setValueAtTime(freq, actx.currentTime);
    g.gain.setValueAtTime(vol, actx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur);
    o.connect(g); g.connect(master); o.start(); o.stop(actx.currentTime + dur + 0.02);
  }
  return {
    unlock() { ensure(); },
    hit() { play(440, 0.08, 'square', 0.4); },
    wall() { play(220, 0.06, 'triangle', 0.3); },
    score() { play(880, 0.15, 'square', 0.5); setTimeout(() => play(1100, 0.2, 'square', 0.4), 100); },
    lose() { play(200, 0.3, 'sawtooth', 0.4); setTimeout(() => play(150, 0.4, 'sawtooth', 0.3), 150); },
    win() { play(660, 0.1, 'square', 0.4); setTimeout(() => play(880, 0.1, 'square', 0.4), 100); setTimeout(() => play(1100, 0.15, 'square', 0.5), 200); },
    serve() { play(330, 0.1, 'triangle', 0.3); },
    upgrade() { play(523, 0.1, 'square', 0.3); setTimeout(() => play(659, 0.1, 'square', 0.3), 80); setTimeout(() => play(784, 0.15, 'square', 0.4), 160); },
    slowmo() { play(180, 0.5, 'sine', 0.2); }
  };
})();

// ============================================================
// MATCH LOGIC
// ============================================================
function createMatch(opponent, stats, roundIdx) {
  const winScore = WIN_SCORE_BASE + Math.floor(roundIdx / 3);
  const loseScore = winScore + stats.bonusHP;

  return {
    opp: opponent,
    stats: stats,
    winScore: winScore,
    loseScore: loseScore,
    p1Score: 0,
    p2Score: 0,
    serving: 'p1', // p1 = player

    // Paddles
    p1: { x: PLAY_L + 20, y: COURT_H / 2, w: PADDLE_W, h: PADDLE_H_BASE * stats.paddleMult, speed: 300 * stats.speedMult },
    p2: { x: PLAY_R - 20, y: COURT_H / 2, w: PADDLE_W, h: opponent.paddleH, speed: opponent.speed * stats.oppDebuff, targetY: COURT_H / 2, reactionTimer: 0, lastBallY: COURT_H / 2 },

    // Ball
    ball: { x: 0, y: 0, vx: 0, vy: 0, speed: 0, spin: 0, active: false, trail: [], ghost: 0 },

    // Serve state
    serveTimer: 0,
    serveReady: false,

    // Slow-mo
    slowmoCharge: stats.hasSlowmo ? stats.slowmoMax : 0,
    slowmoActive: false,
    slowmoMax: stats.slowmoMax,

    // Particles
    particles: [],

    // Point flash
    pointFlash: 0,
    pointText: '',

    // Rally count
    rallyCount: 0,

    // AI state
    aiState: { anticipateY: COURT_H / 2, moving: false }
  };
}

function resetBall(m) {
  const isP1 = m.serving === 'p1';
  m.ball.x = isP1 ? m.p1.x + PADDLE_W + BALL_R + 2 : m.p2.x - PADDLE_W - BALL_R - 2;
  m.ball.y = isP1 ? m.p1.y : m.p2.y;
  m.ball.vx = 0; m.ball.vy = 0; m.ball.speed = 0; m.ball.spin = 0;
  m.ball.active = false; m.ball.trail = []; m.ball.ghost = 0;
  m.serveTimer = 0.8;
  m.serveReady = false;
  m.rallyCount = 0;
}

function serveBall(m) {
  const isP1Serve = m.serving === 'p1';
  const dir = isP1Serve ? 1 : -1;
  const speed = SERVE_SPEED * (isP1Serve ? m.stats.serveMult : 1);
  const angle = (Math.random() - 0.5) * 0.5;
  m.ball.vx = dir * speed * Math.cos(angle);
  m.ball.vy = speed * Math.sin(angle) * 0.6;
  m.ball.speed = speed;
  m.ball.active = true;
  m.ball.spin = 0;
  Audio.serve();
}

function updateMatch(m, dt) {
  if (m.pointFlash > 0) { m.pointFlash -= dt; return; }

  // Time scale for slow-mo
  let timeScale = 1;
  if (m.slowmoActive && m.slowmoCharge > 0) {
    timeScale = 0.35;
    m.slowmoCharge -= dt;
    if (m.slowmoCharge <= 0) { m.slowmoCharge = 0; m.slowmoActive = false; }
  } else if (m.stats.hasSlowmo && !m.slowmoActive && m.slowmoCharge < m.slowmoMax) {
    m.slowmoCharge += dt * 0.5; // recharge slowly
    if (m.slowmoCharge > m.slowmoMax) m.slowmoCharge = m.slowmoMax;
  }
  const sDt = dt * timeScale;

  // Update slow-mo UI
  if (m.stats.hasSlowmo) {
    slowmoBar.style.display = 'block';
    document.getElementById('slowmoFill').style.width = ((m.slowmoCharge / m.slowmoMax) * 100) + '%';
  }

  // Serve timer
  if (!m.ball.active) {
    m.serveTimer -= sDt;
    if (m.serveTimer <= 0 && !m.serveReady) {
      m.serveReady = true;
      if (m.serving !== 'p1') {
        // AI serves after a short delay
        setTimeout(() => { if (m.serveReady && !m.ball.active) serveBall(m); }, 300 + Math.random() * 400);
      }
    }
    // Player serves by being near ball position (auto-serve after delay)
    if (m.serveReady && m.serving === 'p1') {
      m.serveTimer -= sDt;
      if (m.serveTimer <= -0.5) serveBall(m); // auto-serve after 1.3s total
    }
  }

  // Move player paddle
  const targetY = mouseY;
  const diff = targetY - m.p1.y;
  const maxMove = m.p1.speed * sDt;
  m.p1.y += Math.sign(diff) * Math.min(Math.abs(diff), maxMove);
  m.p1.y = clamp(m.p1.y, PLAY_T + m.p1.h / 2, PLAY_B - m.p1.h / 2);

  // AI paddle
  updateAI(m, sDt);

  if (!m.ball.active) return;

  // Ball magnet effect
  if (m.stats.magnetStr > 0 && m.ball.vx < 0) {
    const dy = m.p1.y - m.ball.y;
    m.ball.vy += Math.sign(dy) * m.stats.magnetStr * sDt;
  }

  // Move ball
  m.ball.x += m.ball.vx * sDt;
  m.ball.y += m.ball.vy * sDt;
  // Apply spin as curve
  m.ball.vy += m.ball.spin * 200 * sDt;
  m.ball.spin *= (1 - 2 * sDt); // decay spin

  // Ghost ball flicker
  if (m.stats.ghostBall) {
    m.ball.ghost = Math.sin(clock * 15) > 0.3 ? 1 : 0.15;
  } else {
    m.ball.ghost = 1;
  }

  // Trail
  m.ball.trail.push({ x: m.ball.x, y: m.ball.y, t: 1 });
  if (m.ball.trail.length > 12) m.ball.trail.shift();
  for (const t of m.ball.trail) t.t -= sDt * 5;

  // Wall bounce (top/bottom)
  if (m.ball.y - BALL_R <= PLAY_T) { m.ball.y = PLAY_T + BALL_R; m.ball.vy = Math.abs(m.ball.vy); Audio.wall(); }
  if (m.ball.y + BALL_R >= PLAY_B) { m.ball.y = PLAY_B - BALL_R; m.ball.vy = -Math.abs(m.ball.vy); Audio.wall(); }

  // Paddle collision - Player (left)
  if (m.ball.vx < 0 && m.ball.x - BALL_R <= m.p1.x + m.p1.w / 2 && m.ball.x + BALL_R >= m.p1.x - m.p1.w / 2) {
    if (m.ball.y >= m.p1.y - m.p1.h / 2 && m.ball.y <= m.p1.y + m.p1.h / 2) {
      paddleHit(m, m.p1, true);
    }
  }

  // Paddle collision - AI (right)
  if (m.ball.vx > 0 && m.ball.x + BALL_R >= m.p2.x - m.p2.w / 2 && m.ball.x - BALL_R <= m.p2.x + m.p2.w / 2) {
    if (m.ball.y >= m.p2.y - m.p2.h / 2 && m.ball.y <= m.p2.y + m.p2.h / 2) {
      paddleHit(m, m.p2, false);
    }
  }

  // Scoring
  if (m.ball.x < PLAY_L - 10) { scorePoint(m, 'p2'); }
  if (m.ball.x > PLAY_R + 10) { scorePoint(m, 'p1'); }

  // Particles
  for (let i = m.particles.length - 1; i >= 0; i--) {
    const p = m.particles[i];
    p.x += p.vx * sDt; p.y += p.vy * sDt;
    p.life -= sDt;
    if (p.life <= 0) m.particles.splice(i, 1);
  }
}

function paddleHit(m, paddle, isPlayer) {
  const relY = (m.ball.y - paddle.y) / (paddle.h / 2); // -1 to 1
  const maxAngle = 60 * Math.PI / 180;
  let angle = relY * maxAngle * (isPlayer ? m.stats.precisionMult : 1);

  const speedBoost = isPlayer ? m.stats.powerMult : 1;
  const rallyBoost = 1 + m.rallyCount * 0.02; // gets faster each rally
  const newSpeed = Math.min(BALL_SPEED_BASE * speedBoost * rallyBoost * (1 + Math.random() * 0.1), 600);

  const dir = isPlayer ? 1 : -1;
  m.ball.vx = dir * newSpeed * Math.cos(angle);
  m.ball.vy = newSpeed * Math.sin(angle);
  m.ball.speed = newSpeed;
  m.ball.x = paddle.x + (isPlayer ? paddle.w / 2 + BALL_R + 1 : -paddle.w / 2 - BALL_R - 1);

  // Add spin if player has spin upgrade
  if (isPlayer && m.stats.spinPower > 0) {
    m.ball.spin = relY * m.stats.spinPower;
  }
  // AI spin
  if (!isPlayer && m.opp.spinSkill > 0.3) {
    m.ball.spin = (Math.random() - 0.5) * m.opp.spinSkill * 0.5;
  }

  m.rallyCount++;
  Audio.hit();

  // Hit particles
  for (let i = 0; i < 6; i++) {
    m.particles.push({
      x: m.ball.x, y: m.ball.y,
      vx: (Math.random() - 0.5) * 100 * dir,
      vy: (Math.random() - 0.5) * 80,
      life: 0.3 + Math.random() * 0.2,
      color: isPlayer ? 'var(--p1)' : m.opp.color
    });
  }
}

function scorePoint(m, who) {
  m.ball.active = false;
  if (who === 'p1') {
    m.p1Score++;
    m.pointText = 'POINT!';
    Audio.score();
  } else {
    m.p2Score++;
    m.pointText = 'OPPONENT SCORES';
    Audio.lose();
  }
  m.pointFlash = 1.0;
  document.getElementById('scoreP1').textContent = m.p1Score;
  document.getElementById('scoreP2').textContent = m.p2Score;

  // Score particles
  for (let i = 0; i < 12; i++) {
    m.particles.push({
      x: who === 'p1' ? PLAY_R : PLAY_L, y: m.ball.y,
      vx: (Math.random() - 0.5) * 150, vy: (Math.random() - 0.5) * 150,
      life: 0.5 + Math.random() * 0.3,
      color: who === 'p1' ? '#49d0ff' : '#ff6b4a'
    });
  }

  // Check match end
  if (m.p1Score >= m.winScore) {
    setTimeout(() => endMatch(true), 800);
    return;
  }
  if (m.p2Score >= m.loseScore) {
    setTimeout(() => endMatch(false), 800);
    return;
  }

  // Alternate serve
  m.serving = m.serving === 'p1' ? 'p2' : 'p1';
  document.getElementById('hudServe').textContent = m.serving === 'p1' ? 'YOU' : 'OPP';
  setTimeout(() => resetBall(m), 600);
}

// ============================================================
// AI
// ============================================================
function updateAI(m, dt) {
  const opp = m.opp;
  const p2 = m.p2;

  // Predict where ball will be
  let targetY = COURT_H / 2;
  if (m.ball.active && m.ball.vx > 0) {
    // Simple prediction: where will ball be at paddle x?
    const timeToReach = (p2.x - m.ball.x) / Math.max(1, m.ball.vx);
    targetY = m.ball.y + m.ball.vy * timeToReach;
    // Bounce prediction (simple)
    while (targetY < PLAY_T || targetY > PLAY_B) {
      if (targetY < PLAY_T) targetY = 2 * PLAY_T - targetY;
      if (targetY > PLAY_B) targetY = 2 * PLAY_B - targetY;
    }
    // Add inaccuracy
    targetY += (Math.random() - 0.5) * (1 - opp.accuracy) * 80;
  } else if (m.ball.active && m.ball.vx < 0) {
    // Return to center-ish while ball heading away
    targetY = COURT_H / 2 + (Math.random() - 0.5) * 40;
  }

  // Reaction delay
  p2.reactionTimer -= dt;
  if (p2.reactionTimer <= 0) {
    p2.targetY = targetY;
    p2.reactionTimer = opp.reaction * (0.8 + Math.random() * 0.4);
  }

  // Move toward target
  const diff = p2.targetY - p2.y;
  const maxMove = p2.speed * dt;
  p2.y += Math.sign(diff) * Math.min(Math.abs(diff), maxMove);
  p2.y = clamp(p2.y, PLAY_T + p2.h / 2, PLAY_B - p2.h / 2);
}

// ============================================================
// MATCH FLOW
// ============================================================
function endMatch(won) {
  gamePhase = 'match-over';
  if (won) {
    run.bracket[run.currentRound] = 'won';
    Audio.win();
    showMatchResult('YOU WIN!', true);
    setTimeout(() => {
      matchResult.style.display = 'none';
      run.currentRound++;
      if (run.currentRound >= 7) {
        // Champion!
        showChampion();
      } else {
        showUpgradeScreen();
      }
    }, 1800);
  } else {
    run.bracket[run.currentRound] = 'lost';
    Audio.lose();
    showMatchResult('DEFEATED', false);
    setTimeout(() => {
      matchResult.style.display = 'none';
      showGameOver();
    }, 2000);
  }
}

function showMatchResult(text, isWin) {
  const el = document.getElementById('resultText');
  el.textContent = text;
  el.className = 'result-text ' + (isWin ? 'win-text' : 'lose-text');
  matchResult.style.display = 'grid';
}

// ============================================================
// RENDERING
// ============================================================
function drawGame(m) {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Scale to virtual coordinates
  ctx.save();
  ctx.scale(canvas.width / COURT_W, canvas.height / COURT_H);

  // Background
  ctx.fillStyle = '#0d1117';
  ctx.fillRect(0, 0, COURT_W, COURT_H);

  // Court surface
  const courtGrad = ctx.createLinearGradient(0, PLAY_T, 0, PLAY_B);
  courtGrad.addColorStop(0, '#0f2a0f');
  courtGrad.addColorStop(0.5, '#1a3a1a');
  courtGrad.addColorStop(1, '#0f2a0f');
  ctx.fillStyle = courtGrad;
  ctx.fillRect(PLAY_L, PLAY_T, PLAY_R - PLAY_L, PLAY_B - PLAY_T);

  // Court lines
  ctx.strokeStyle = 'rgba(232,232,208,0.3)';
  ctx.lineWidth = 1;
  // Outer boundary
  ctx.strokeRect(PLAY_L, PLAY_T, PLAY_R - PLAY_L, PLAY_B - PLAY_T);
  // Center line
  ctx.beginPath();
  ctx.setLineDash([4, 4]);
  ctx.moveTo(NET_X, PLAY_T); ctx.lineTo(NET_X, PLAY_B);
  ctx.stroke();
  ctx.setLineDash([]);

  // Kitchen zones (no-volley zone)
  ctx.fillStyle = 'rgba(255,138,61,0.06)';
  ctx.fillRect(NET_X - KITCHEN_W, PLAY_T, KITCHEN_W, PLAY_B - PLAY_T);
  ctx.fillRect(NET_X, PLAY_T, KITCHEN_W, PLAY_B - PLAY_T);
  ctx.strokeStyle = 'rgba(255,138,61,0.2)';
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(NET_X - KITCHEN_W, PLAY_T); ctx.lineTo(NET_X - KITCHEN_W, PLAY_B);
  ctx.moveTo(NET_X + KITCHEN_W, PLAY_T); ctx.lineTo(NET_X + KITCHEN_W, PLAY_B);
  ctx.stroke();
  ctx.setLineDash([]);

  // Net
  ctx.strokeStyle = 'rgba(200,200,170,0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(NET_X, PLAY_T); ctx.lineTo(NET_X, PLAY_B); ctx.stroke();
  // Net diamonds
  ctx.strokeStyle = 'rgba(200,200,170,0.15)';
  ctx.lineWidth = 0.5;
  for (let y = PLAY_T; y < PLAY_B; y += 12) {
    ctx.beginPath(); ctx.moveTo(NET_X - 3, y); ctx.lineTo(NET_X, y + 6); ctx.lineTo(NET_X + 3, y); ctx.stroke();
  }

  if (!m) { ctx.restore(); return; }

  // Slow-mo tint
  if (m.slowmoActive && m.slowmoCharge > 0) {
    ctx.fillStyle = 'rgba(73,208,255,0.04)';
    ctx.fillRect(0, 0, COURT_W, COURT_H);
  }

  // Ball trail
  for (const t of m.ball.trail) {
    if (t.t <= 0) continue;
    ctx.globalAlpha = t.t * 0.3 * m.ball.ghost;
    ctx.fillStyle = '#ffe033';
    ctx.beginPath(); ctx.arc(t.x, t.y, BALL_R * t.t * 0.7, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Ball
  if (m.ball.active || m.serveReady) {
    ctx.globalAlpha = m.ball.ghost;
    // Ball glow
    ctx.shadowColor = '#ffe033';
    ctx.shadowBlur = 8;
    ctx.fillStyle = '#ffe033';
    ctx.beginPath(); ctx.arc(m.ball.x, m.ball.y, BALL_R, 0, Math.PI * 2); ctx.fill();
    // Ball holes (wiffle ball look)
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(200,170,0,0.5)';
    for (let a = 0; a < 4; a++) {
      const ang = a * Math.PI / 2 + clock * 3;
      ctx.beginPath(); ctx.arc(m.ball.x + Math.cos(ang) * 2.5, m.ball.y + Math.sin(ang) * 2.5, 1, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // Player paddle
  ctx.shadowColor = '#49d0ff';
  ctx.shadowBlur = 6;
  drawPaddle(m.p1.x, m.p1.y, m.p1.w, m.p1.h, '#49d0ff');
  ctx.shadowBlur = 0;

  // AI paddle
  ctx.shadowColor = m.opp.color;
  ctx.shadowBlur = 6;
  drawPaddle(m.p2.x, m.p2.y, m.p2.w, m.p2.h, m.opp.color);
  ctx.shadowBlur = 0;

  // Particles
  for (const p of m.particles) {
    ctx.globalAlpha = clamp(p.life / 0.3, 0, 1);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
  }
  ctx.globalAlpha = 1;

  // Point flash text
  if (m.pointFlash > 0) {
    ctx.globalAlpha = Math.min(1, m.pointFlash * 2);
    ctx.fillStyle = m.pointText === 'POINT!' ? '#49d0ff' : '#ff6b4a';
    ctx.font = 'bold 28px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(m.pointText, COURT_W / 2, COURT_H / 2);
    ctx.globalAlpha = 1;
  }

  // Rally counter
  if (m.rallyCount > 3 && m.ball.active) {
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('RALLY x' + m.rallyCount, COURT_W / 2, PLAY_T - 5);
  }

  // Serve indicator
  if (!m.ball.active && m.serveReady && m.serving === 'p1') {
    ctx.globalAlpha = 0.5 + Math.sin(clock * 6) * 0.3;
    ctx.fillStyle = '#49d0ff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SERVING...', m.p1.x + 40, m.p1.y - 20);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function drawPaddle(x, y, w, h, color) {
  // Retro pixelated paddle
  ctx.fillStyle = color;
  const px = x - w / 2, py = y - h / 2;
  ctx.fillRect(px, py, w, h);
  // Highlight edge
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillRect(px, py, 2, h);
  // Shadow edge
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(px + w - 2, py, 2, h);
}

// ============================================================
// SCREENS
// ============================================================
function hideAllScreens() {
  screenTitle.style.display = 'none';
  screenPreMatch.style.display = 'none';
  screenUpgrade.style.display = 'none';
  screenGameOver.style.display = 'none';
  screenChampion.style.display = 'none';
  matchResult.style.display = 'none';
  hud.style.display = 'none';
  slowmoBar.style.display = 'none';
}

function startNewRun() {
  Audio.unlock();
  run = {
    currentRound: 0,
    opponents: [],
    bracket: Array(7).fill('future'),
    seed: Math.floor(Math.random() * 1e9)
  };
  upgrades = [];
  // Generate all opponents
  for (let i = 0; i < 7; i++) {
    run.opponents.push(genOpponent(i, run.seed + i * 777));
  }
  run.bracket[0] = 'current';
  showPreMatch();
}

function showPreMatch() {
  hideAllScreens();
  gamePhase = 'prematch';
  screenPreMatch.style.display = 'grid';

  const opp = run.opponents[run.currentRound];
  document.getElementById('oppName').textContent = opp.name;
  document.getElementById('oppTitle').textContent = '"' + opp.title + '"';

  // Stats bars
  const statsEl = document.getElementById('oppStats');
  statsEl.innerHTML = '';
  const stats = [
    { name: 'SPD', val: opp.speed / (AI_SPEED_BASE * 1.3) },
    { name: 'ACC', val: opp.accuracy },
    { name: 'AGR', val: opp.aggression },
    { name: 'SPN', val: opp.spinSkill }
  ];
  for (const s of stats) {
    const div = document.createElement('div');
    div.className = 'stat';
    div.innerHTML = s.name + ' <span class="stat-bar"><span class="stat-fill" style="width:' + Math.round(s.val * 100) + '%"></span></span>';
    statsEl.appendChild(div);
  }

  // Bracket
  const bracketEl = document.getElementById('bracketDisplay');
  bracketEl.innerHTML = '';
  const labels = ['QF1','QF2','QF3','QF4','SF1','SF2','F'];
  for (let i = 0; i < 7; i++) {
    const div = document.createElement('div');
    div.className = 'bracket-slot ' + (i === run.currentRound ? 'current' : run.bracket[i]);
    div.textContent = labels[i];
    bracketEl.appendChild(div);
  }

  // Player buffs
  const buffsEl = document.getElementById('playerBuffs');
  buffsEl.innerHTML = '';
  if (upgrades.length === 0) {
    buffsEl.innerHTML = '<span style="font-size:0.65rem;color:var(--muted)">No upgrades yet</span>';
  } else {
    for (const u of upgrades) {
      const span = document.createElement('span');
      span.className = 'buff';
      span.textContent = u.icon + ' ' + u.name;
      buffsEl.appendChild(span);
    }
  }

  const winScore = WIN_SCORE_BASE + Math.floor(run.currentRound / 3);
  document.getElementById('targetScore').textContent = winScore;

  // Round label
  const roundNames = ['Quarter-Final 1','Quarter-Final 2','Quarter-Final 3','Quarter-Final 4','Semi-Final 1','Semi-Final 2','Grand Final'];
  document.getElementById('hudRound').textContent = run.currentRound + 1;
  document.getElementById('hudMatch').textContent = labels[run.currentRound];
}

function startMatch() {
  hideAllScreens();
  hud.style.display = 'flex';
  gamePhase = 'playing';

  const opp = run.opponents[run.currentRound];
  const stats = computePlayerStats(upgrades);
  matchState = createMatch(opp, stats, run.currentRound);

  document.getElementById('scoreP1').textContent = '0';
  document.getElementById('scoreP2').textContent = '0';
  document.getElementById('hudServe').textContent = 'YOU';

  resetBall(matchState);
}

function showUpgradeScreen() {
  hideAllScreens();
  gamePhase = 'upgrading';
  screenUpgrade.style.display = 'grid';

  const choices = pickUpgradeChoices(upgrades);
  const grid = document.getElementById('upgradeGrid');
  grid.innerHTML = '';

  for (const c of choices) {
    const div = document.createElement('div');
    div.className = 'upgrade-card';
    div.innerHTML = '<div class="icon">' + c.icon + '</div><div class="name">' + c.name + '</div><div class="desc">' + c.desc + '</div>';
    div.addEventListener('click', () => {
      Audio.upgrade();
      upgrades.push({ id: c.id, icon: c.icon, name: c.name });
      run.bracket[run.currentRound] = 'current';
      showPreMatch();
    });
    grid.appendChild(div);
  }
}

function showGameOver() {
  hideAllScreens();
  gamePhase = 'gameover';
  screenGameOver.style.display = 'grid';

  const roundNames = ['Quarter-Final 1','Quarter-Final 2','Quarter-Final 3','Quarter-Final 4','Semi-Final 1','Semi-Final 2','Grand Final'];
  document.getElementById('goRound').textContent = roundNames[run.currentRound];
  document.getElementById('goWins').textContent = run.currentRound;

  const messages = [
    'The kitchen claimed another soul...',
    'Your paddle wasn\'t ready for this.',
    'Dink harder next time.',
    'The tournament continues without you.',
    'Every champion starts with defeat.',
    'The court remembers all.'
  ];
  document.getElementById('goMessage').textContent = messages[Math.floor(Math.random() * messages.length)];
}

function showChampion() {
  hideAllScreens();
  gamePhase = 'champion';
  screenChampion.style.display = 'grid';
  document.getElementById('champUpgrades').textContent = upgrades.length;

  const buffsEl = document.getElementById('champBuffs');
  buffsEl.innerHTML = '';
  for (const u of upgrades) {
    const span = document.createElement('span');
    span.className = 'buff';
    span.textContent = u.icon + ' ' + u.name;
    buffsEl.appendChild(span);
  }
}

// ============================================================
// INPUT
// ============================================================
function getCanvasY(clientY) {
  const rect = canvas.getBoundingClientRect();
  return ((clientY - rect.top) / rect.height) * COURT_H;
}

canvas.addEventListener('mousemove', e => { mouseY = getCanvasY(e.clientY); mouseActive = true; });
canvas.addEventListener('touchmove', e => { e.preventDefault(); mouseY = getCanvasY(e.touches[0].clientY); mouseActive = true; }, { passive: false });
canvas.addEventListener('touchstart', e => { e.preventDefault(); mouseY = getCanvasY(e.touches[0].clientY); mouseActive = true; }, { passive: false });

window.addEventListener('keydown', e => {
  if (e.code === 'Space' && matchState && matchState.stats.hasSlowmo && gamePhase === 'playing') {
    if (matchState.slowmoCharge > 0.5) {
      matchState.slowmoActive = true;
      Audio.slowmo();
    }
    e.preventDefault();
  }
});
window.addEventListener('keyup', e => {
  if (e.code === 'Space' && matchState) {
    matchState.slowmoActive = false;
  }
});

// ============================================================
// BUTTON WIRING
// ============================================================
document.getElementById('btnStart').addEventListener('click', startNewRun);
document.getElementById('btnFight').addEventListener('click', startMatch);
document.getElementById('btnRetry').addEventListener('click', startNewRun);
document.getElementById('btnNewRun').addEventListener('click', startNewRun);

// ============================================================
// RESIZE
// ============================================================
function resize() {
  DPR = Math.min(2, window.devicePixelRatio || 1);
  const w = window.innerWidth, h = window.innerHeight;
  // Maintain aspect ratio
  const aspect = COURT_W / COURT_H;
  let cw, ch;
  if (w / h > aspect) { ch = h; cw = h * aspect; } else { cw = w; ch = w / aspect; }
  canvas.width = Math.floor(cw * DPR);
  canvas.height = Math.floor(ch * DPR);
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
}
window.addEventListener('resize', resize, { passive: true });
resize();

// ============================================================
// UTILS
// ============================================================
function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }

// ============================================================
// MAIN LOOP
// ============================================================
function loop(t) {
  const now = t / 1000;
  const dt = Math.min(0.05, lastTime ? now - lastTime : 0.016);
  lastTime = now;
  clock += dt;

  if (gamePhase === 'playing' && matchState) {
    updateMatch(matchState, dt);
    drawGame(matchState);
  } else {
    // Draw idle court
    drawGame(null);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
