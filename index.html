<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>PicklePop — FP Arcade Pickleball (v0.1.1)</title>
<style>
  html,body{margin:0;height:100%;background:#0a0f17;overscroll-behavior:none}
  canvas{display:block}
  #hud{
    position:fixed;inset:12px auto auto 12px;color:#e8f0ff;font:600 14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
    background:rgba(10,15,23,.5);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;
    box-shadow:0 6px 20px rgba(0,0,0,.35);pointer-events:none;user-select:none
  }
  #hud .big{font-size:18px}
  #hud .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);margin-left:6px}
  #centerMsg{
    position:fixed;left:50%;top:10px;transform:translateX(-50%);font:700 20px/1 ui-sans-serif,system-ui;
    color:#f5f9ff;background:rgba(14,22,32,.6);backdrop-filter:blur(8px);padding:10px 14px;border-radius:12px;opacity:.95
  }
  #help{
    position:fixed;right:12px;bottom:12px;color:#b9c7e6;font:500 12px/1.4 ui-sans-serif,system-ui;
    background:rgba(10,15,23,.55);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;max-width:min(42ch,45vw)
  }
  #fault{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    font:800 28px/1 ui-sans-serif;letter-spacing:.5px;color:#fff;padding:16px 18px;border-radius:14px;
    background:linear-gradient(180deg, rgba(255,60,60,.92), rgba(180,0,0,.9));box-shadow:0 20px 50px rgba(0,0,0,.5);
    display:none
  }
  #lock{
    position:fixed;inset:0;background:radial-gradient(1200px 600px at 50% 30%, rgba(255,255,255,.07), transparent 70%) #0a0f17;
    display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;color:#e8f0ff;text-align:center
  }
  #lock button{
    font:700 14px ui-sans-serif,system-ui;padding:10px 14px;border-radius:12px;border:0;cursor:pointer;
    background:#59a4ff;color:#071525;box-shadow:0 6px 18px rgba(0,0,0,.45)
  }
  #nvzHint{
    position:fixed;left:50%;bottom:70px;transform:translateX(-50%);
    color:#fff;font:700 14px ui-sans-serif;background:rgba(255,45,45,.85);padding:8px 10px;border-radius:10px;display:none
  }
</style>
</head>
<body>
<div id="hud">
  <div class="big">Score: <span id="pScore">0</span> – <span id="aiScore">0</span> <span class="pill" id="serverPill">Serve: You</span></div>
  <div>Side: <span id="sidePill">Right</span> • To 11 (win by 2) • Aim-assist ON</div>
  <div id="lastMsg" style="opacity:.9;margin-top:6px"></div>
</div>
<div id="centerMsg">Click the game to lock cursor</div>
<div id="help">
  <b>Controls</b>: WASD move, Shift sprint, Ctrl crouch/reach, <b>Space (hold)</b> serve, <b>Left-click</b> hit, Q/E paddle tilt, Esc unlock.<br/>
  <b>Rules</b>: Singles, 11 to win (by 2). Kitchen (NVZ) volley faults enforced. Diagonal serve must land in service box. No wind.
</div>
<div id="fault">FAULT</div>
<div id="nvzHint">NVZ VOLLEY = FAULT</div>
<div id="lock">
  <div style="font:800 28px/1 ui-sans-serif;">PicklePop</div>
  <div style="opacity:.9;max-width:60ch">Press <b>Play</b>. If the cursor doesn’t lock, just click anywhere on the game to lock it.</div>
  <button id="playBtn">Play</button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const COURT_W = 6.10, COURT_L = 13.41, HALF_W = COURT_W*0.5, HALF_L = COURT_L*0.5;
const NVZ = 2.13, NET_H_CENTER = 0.86, NET_H_SIDELINE = 0.914;
const BALL_RADIUS = 0.037, GRAVITY = new THREE.Vector3(0,-9.81,0);
const DRAG_K = 0.9, MAGNUS_K = 0.0006;
const SERVE_MIN = 0.4, SERVE_MAX = 1.0, DT_FIXED = 1/120;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v)); const lerp=(a,b,t)=>a+(b-a)*t;
const vec3=(x=0,y=0,z=0)=>new THREE.Vector3(x,y,z);
function netHeightAtX(x){const t=clamp(Math.abs(x)/HALF_W,0,1);const s=t*t*(3-2*t);return lerp(NET_H_CENTER,NET_H_SIDELINE,s);}

const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2)); document.body.appendChild(renderer.domElement);
const scene=new THREE.Scene(); scene.fog=new THREE.FogExp2(0x0a0f17,0.04);

// Sky
{
  const skyGeo=new THREE.SphereGeometry(100,32,16);
  const skyMat=new THREE.ShaderMaterial({side:THREE.BackSide,uniforms:{top:{value:new THREE.Color(0x20324f)},mid:{value:new THREE.Color(0x2a466f)},bot:{value:new THREE.Color(0x132237)}},
  vertexShader:`varying vec3 vPos;void main(){vPos=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
  fragmentShader:`uniform vec3 top,mid,bot;varying vec3 vPos;void main(){float h=normalize(vPos).y*.5+.5;vec3 c=mix(bot,mid,smoothstep(.2,.7,h));c=mix(c,top,smoothstep(.7,1.,h));gl_FragColor=vec4(c,1.);} `});
  scene.add(new THREE.Mesh(skyGeo,skyMat));
}
scene.add(new THREE.DirectionalLight(0xffffff,1.0)).position.set(-2,6,-3);
scene.add(new THREE.AmbientLight(0xbfd7ff,.35));

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,.05,200);
const player={pos:vec3(0,1.7,-HALF_L+0.8),vel:vec3(),yaw:0,pitch:0,speed:5.5,sprint:8.0,crouch:0,paddleTilt:0,canHitCooldown:0};
camera.position.copy(player.pos);

// Pointer lock (fixed)
let pointerLocked=false;
const lockUI=document.getElementById('lock');
const playBtn=document.getElementById('playBtn');
const centerMsg=document.getElementById('centerMsg');

playBtn.onclick=()=>{
  // Hide overlay FIRST so you can click the canvas even if lock fails
  lockUI.style.display='none';
  centerMsg.style.display='';
  // Try to lock now (will succeed on Pages/https, may fail on file://)
  try{ renderer.domElement.requestPointerLock(); }catch(e){}
};
document.addEventListener('pointerlockchange', ()=>{
  pointerLocked=(document.pointerLockElement===renderer.domElement);
  centerMsg.style.display=pointerLocked?'none':'';
});
document.addEventListener('pointerlockerror', ()=>{
  // Non-fatal: still playable; user can click the canvas to retry
  pointerLocked=false;
  centerMsg.textContent='Click the game to lock cursor';
  lockUI.style.display='none';
});
renderer.domElement.addEventListener('click', ()=>{
  if(!pointerLocked) { try{ renderer.domElement.requestPointerLock(); }catch(e){} }
});
addEventListener('resize', ()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

// Input
const keys=new Set();
addEventListener('keydown', e=>{keys.add(e.code); if(e.code==='Tab') e.preventDefault();});
addEventListener('keyup', e=>keys.delete(e.code));
addEventListener('mousemove', e=>{
  if(!pointerLocked) return;
  player.yaw-=e.movementX*0.0025; player.pitch-=e.movementY*0.0020; player.pitch=clamp(player.pitch,-1.1,1.1);
});
addEventListener('mousedown', e=>{ if(e.button===0) tryHit(); });

function getMoveDir(){
  const dir=vec3(); const fw=vec3(-Math.sin(player.yaw),0,-Math.cos(player.yaw)); const rt=vec3(-fw.z,0,fw.x);
  if(keys.has('KeyW')) dir.add(fw); if(keys.has('KeyS')) dir.sub(fw); if(keys.has('KeyA')) dir.sub(rt); if(keys.has('KeyD')) dir.add(rt);
  if(dir.lengthSq()>0) dir.normalize(); return dir;
}

// Paddle
const paddle=new THREE.Mesh(new THREE.BoxGeometry(.22,.32,.02), new THREE.MeshStandardMaterial({color:0x2b5fff,roughness:.6,metalness:.05}));
scene.add(paddle);

// Court
function makeCourt(){
  const g=new THREE.Group();
  const ground=new THREE.Mesh(new THREE.PlaneGeometry(60,60,1,1), new THREE.MeshStandardMaterial({color:0x264b3f,roughness:1}));
  ground.rotation.x=-Math.PI/2; ground.position.y=0; g.add(ground);
  const court=new THREE.Mesh(new THREE.PlaneGeometry(COURT_W,COURT_L), new THREE.MeshStandardMaterial({color:0x1d7fb5,roughness:.8}));
  court.rotation.x=-Math.PI/2; court.position.y=.001; g.add(court);
  const lineMat=new THREE.MeshBasicMaterial({color:0xffffff}); const lineH=.003;
  const addLine=(x,z,w,l)=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(w,l),lineMat); m.rotation.x=-Math.PI/2;m.position.set(x,lineH,z);g.add(m);};
  addLine(0,-HALF_L,COURT_W,.05); addLine(0,HALF_L,COURT_W,.05);
  addLine(-HALF_W,0,.05,COURT_L); addLine(HALF_W,0,.05,COURT_L);
  addLine(0,0,.04,COURT_L/2-NVZ); addLine(0,0,.04,-(COURT_L/2-NVZ));
  addLine(0,NVZ,COURT_W,.04); addLine(0,-NVZ,COURT_W,.04);
  const postGeo=new THREE.CylinderGeometry(.05,.05,1.2,8);
  const postMat=new THREE.MeshStandardMaterial({color:0x222a33,metalness:.2,roughness:.6});
  const postL=new THREE.Mesh(postGeo,postMat), postR=postL.clone();
  postL.position.set(-HALF_W-.05,NET_H_SIDELINE/2,0); postR.position.set(HALF_W+.05,NET_H_SIDELINE/2,0); g.add(postL,postR);
  const net=new THREE.Mesh(new THREE.PlaneGeometry(COURT_W,NET_H_SIDELINE*1.3,16,4),
    new THREE.MeshBasicMaterial({color:0x2a2f36,wireframe:true,transparent:true,opacity:.5}));
  net.rotation.y=Math.PI/2; net.position.set(0,NET_H_CENTER*.8,0); g.add(net);
  const fenceMat=new THREE.LineBasicMaterial({color:0x6fa0c8,transparent:true,opacity:.35});
  for(let i=-3;i<=3;i++){const z=i*4.5; const pts=[new THREE.Vector3(-HALF_W-2,1.2,z), new THREE.Vector3(HALF_W+2,1.2,z)];
    g.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), fenceMat));}
  const treeMat=new THREE.MeshStandardMaterial({color:0x2f6b3a,roughness:1});
  const trunkMat=new THREE.MeshStandardMaterial({color:0x915c2a,roughness:1});
  const addTree=(x,z)=>{const trunk=new THREE.Mesh(new THREE.CylinderGeometry(.07,.07,.8,6),trunkMat); trunk.position.set(x,.4,z);
    const crown=new THREE.Mesh(new THREE.ConeGeometry(.6,1.2,6),treeMat); crown.position.set(x,1.4,z); g.add(trunk,crown);};
  for(let i=0;i<10;i++){addTree((Math.random()<.5?-1:1)*(HALF_W+2+Math.random()*4),(Math.random()*2-1)*(HALF_L+2+Math.random()*6));}
  scene.add(g);
}
makeCourt();

// HUD refs
const pScoreEl=document.getElementById('pScore'), aiScoreEl=document.getElementById('aiScore');
const serverPill=document.getElementById('serverPill'), sidePill=document.getElementById('sidePill');
const lastMsg=document.getElementById('lastMsg'), faultUI=document.getElementById('fault'), nvzHint=document.getElementById('nvzHint');

// Ball
const ballMesh=new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS,16,12),
  new THREE.MeshStandardMaterial({color:0xffee88,roughness:.5,metalness:0}));
scene.add(ballMesh);
const ball={pos:vec3(0,1.2,-HALF_L+.5),vel:vec3(),omega:vec3(),lastZ:-HALF_L+.5,bouncesSinceServe:0,lastHitter:'none',
  inPlay:false,serving:'player',serveSide:'right',awaitingServe:true,rallyOver:false,groundBouncesSinceSide:0};

// Dots
const dots=[]; (function setupDots(n=7){for(let i=0;i<n;i++){const m=new THREE.Mesh(new THREE.SphereGeometry(.03,8,8),
  new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:.8})); m.visible=false; scene.add(m); dots.push(m);}})();

// Score
const score={player:0,ai:0};
function updateHUD(){pScoreEl.textContent=score.player; aiScoreEl.textContent=score.ai;
  serverPill.textContent=`Serve: ${ball.serving==='player'?'You':'AI'}`; sidePill.textContent=ball.serveSide==='right'?'Right':'Left';}
function resetForServe(serving){
  ball.serving=serving; ball.awaitingServe=true; ball.inPlay=false; ball.rallyOver=false; ball.bouncesSinceServe=0;
  ball.vel.set(0,0,0); ball.omega.set(0,0,0);
  const s=((serving==='player'?score.player:score.ai)%2===0)?'right':'left'; ball.serveSide=s; updateHUD();
  if(serving==='player'){ player.pos.set((s==='right'?1.0:-1.0),1.7,-HALF_L+1.2); camera.position.copy(player.pos); ai.pos.set(0,1.7,HALF_L-1.6);}
  else{ player.pos.set(0,1.7,-HALF_L+1.6); camera.position.copy(player.pos); ai.pos.set((s==='right'?-1.0:1.0),1.7,HALF_L-1.2);}
  const bx=(serving==='player')?(s==='right'?1.0:-1.0):(s==='right'?-1.0:1.0);
  const bz=(serving==='player')?(player.pos.z+.4):(ai.pos.z-.4);
  ball.pos.set(bx,1.0,bz); ballMesh.position.copy(ball.pos);
  lastMsg.textContent=`${serving==='player'?'Your':'AI'} serve — ${s} side`;
}
resetForServe('player');

// AI
const ai={pos:vec3(0,1.7,HALF_L-1.6),speed:5.0,paddleTilt:0,cool:0};
function aiUpdate(dt){
  let targetX=clamp(ball.pos.x,-HALF_W+.4,HALF_W-.4);
  const baseZ=HALF_L-(ball.pos.z>HALF_L*.5?1.8:2.4);
  let targetZ=baseZ;
  const to=vec3(targetX-ai.pos.x,0,targetZ-ai.pos.z); const d=to.length(); if(d>0.001){to.normalize(); const v=ai.speed*dt; const k=Math.min(1,v/d); ai.pos.addScaledVector(to,k*d);}
  ai.pos.x=clamp(ai.pos.x,-HALF_W+.35,HALF_W-.35); ai.pos.z=clamp(ai.pos.z,.2,HALF_L-.4);
  ai.cool-=dt;
  const reach=.9; const dist=ai.pos.clone().add(vec3(0,-.4,-.3)).distanceTo(ball.pos); const onAISide=ball.pos.z>0;
  if(ball.inPlay && onAISide && ai.cool<=0 && dist<reach){
    const targetX = ball.pos.x>0 ? -1.2 : 1.2; const targetZ = -HALF_L+1.8;
    const dir=vec3(targetX-ball.pos.x,.9-ball.pos.y,targetZ-ball.pos.z).normalize();
    const speed=THREE.MathUtils.clamp(8+(ball.pos.y-.5)*4,6,11);
    ball.vel.copy(dir.multiplyScalar(speed));
    const sideSpin=(targetX>0?-1:1)*25; ball.omega.set(0,sideSpin,55);
    ball.lastHitter='ai'; ai.cool=.20;
  }
}

// Player move + paddle
function updatePlayer(dt){
  const targetC=keys.has('ControlLeft')?1:0; player.crouch+=(targetC-player.crouch)*Math.min(1,dt*12);
  const move=getMoveDir(); const spd=keys.has('ShiftLeft')?player.sprint:player.speed; player.pos.addScaledVector(move, spd*dt);
  player.pos.x=clamp(player.pos.x,-HALF_W+.35,HALF_W-.35); player.pos.z=clamp(player.pos.z,-HALF_L+.4,-.2);
  const eye=player.pos.clone(); eye.y=1.7-player.crouch*.5; camera.position.copy(eye); camera.rotation.set(player.pitch,player.yaw,0,'YXZ');
  if(keys.has('KeyQ')) player.paddleTilt+=dt*.7; if(keys.has('KeyE')) player.paddleTilt-=dt*.7; player.paddleTilt=clamp(player.paddleTilt,-.22,.22);
  const fw=vec3(-Math.sin(player.yaw),0,-Math.cos(player.yaw)), rt=vec3(-fw.z,0,fw.x), up=vec3(0,1,0);
  const pOff=rt.clone().multiplyScalar(.35).add(fw.clone().multiplyScalar(.45)).add(up.clone().multiplyScalar(-.15-player.crouch*.15));
  paddle.position.copy(eye.clone().add(pOff));
  const baseQuat=new THREE.Quaternion().setFromUnitVectors(vec3(0,0,1), fw.clone().normalize());
  const tiltQuat=new THREE.Quaternion().setFromAxisAngle(rt, player.paddleTilt); paddle.quaternion.copy(baseQuat.multiply(tiltQuat));
}

// Serve
let servingHold=0;
addEventListener('keydown', e=>{
  if(e.code==='Space' && ball.awaitingServe && ball.serving==='player'){ servingHold=0.0001; lastMsg.textContent='Hold Space, release to serve (diagonal)';}
});
addEventListener('keyup', e=>{
  if(e.code==='Space' && ball.awaitingServe && ball.serving==='player' && servingHold>0){
    const t=clamp(servingHold,SERVE_MIN,SERVE_MAX);
    const pow=lerp(7,18,(t-SERVE_MIN)/(SERVE_MAX-SERVE_MAX+1e-9)); // safe
    const toLeft=(ball.serveSide==='left'); const targetX=(toLeft?1:-1)*1.1; const targetZ=HALF_L-NVZ- (COURT_L/4 - NVZ/2)*0.6;
    const dir=vec3(targetX-ball.pos.x,.6-ball.pos.y,targetZ-ball.pos.z).normalize();
    const serveDir=vec3(dir.x, Math.abs(dir.y), dir.z).normalize();
    ball.vel.copy(serveDir.multiplyScalar(pow)); ball.omega.set(0,(toLeft?-1:1)*15,70);
    ball.awaitingServe=false; ball.inPlay=true; ball.lastHitter='player'; lastMsg.textContent='';
  }
  servingHold=0;
});
function updateServeHold(dt){ if(ball.awaitingServe && ball.serving==='player' && servingHold>0){ servingHold+=dt; if(servingHold>SERVE_MAX) servingHold=SERVE_MAX; }}

// Aim dots
function updateDots(){
  const reach=.95; const fw=vec3(-Math.sin(player.yaw),0,-Math.cos(player.yaw)); const rt=vec3(-fw.z,0,fw.x);
  const eye=camera.position.clone(); const pOff=rt.clone().multiplyScalar(.35).add(fw.clone().multiplyScalar(.45)).add(vec3(0,-.15-player.crouch*.15,0));
  const paddlePos=eye.clone().add(pOff); const dist=paddlePos.distanceTo(ball.pos); const onPlayerSide=ball.pos.z<0;
  const inReach=(dist<reach)&&onPlayerSide; const show=(ball.inPlay&&inReach)||(ball.awaitingServe&&ball.serving==='player');
  dots.forEach(d=>d.visible=false); if(!show) return;
  const tilt=player.paddleTilt; const dir=fw.clone(); dir.y=Math.sin(tilt)*.6+((ball.pos.y<1.0)?.12:.02); dir.normalize();
  const speed=ball.awaitingServe? lerp(7,18,(servingHold||SERVE_MIN - SERVE_MIN)/(SERVE_MAX-SERVE_MIN)) : 9.5;
  const v0=dir.multiplyScalar(speed); const w0=vec3(0, tilt*120, 60);
  const p=ball.awaitingServe?ball.pos.clone():paddlePos.clone().lerp(ball.pos,.4);
  let v=v0.clone(), w=w0.clone(), pos=p.clone(); const step=.1;
  for(let i=0;i<dots.length;i++){
    for(let k=0;k<3;k++){
      const sp=v.length(); const drag=v.clone().multiplyScalar(-DRAG_K*sp*.04); const magnus=w.clone().cross(v).multiplyScalar(MAGNUS_K);
      const a=GRAVITY.clone().add(drag).add(magnus); v.addScaledVector(a, step/3); pos.addScaledVector(v, step/3);
      if(pos.y<BALL_RADIUS){ v.y=Math.abs(v.y)*.45; pos.y=BALL_RADIUS; v.multiplyScalar(.87); }
    }
    dots[i].position.copy(pos); dots[i].visible=true; dots[i].material.opacity=0.85 - i*0.12;
  }
}

// Hit
function tryHit(){
  if(!ball.inPlay) return; if(player.canHitCooldown>0) return;
  const fw=vec3(-Math.sin(player.yaw),0,-Math.cos(player.yaw)); const rt=vec3(-fw.z,0,fw.x);
  const eye=camera.position.clone(); const pOff=rt.clone().multiplyScalar(.35).add(fw.clone().multiplyScalar(.45)).add(vec3(0,-.15-player.crouch*.15,0));
  const paddlePos=eye.clone().add(pOff); if(paddlePos.distanceTo(ball.pos)>0.95) return;
  const isVolley=(ball.groundBouncesSinceSide==='player'?0:ball.groundBouncesSinceSide)===0 && ball.pos.z<0;
  const inNVZ=(ball.pos.z>-NVZ && ball.pos.z<0) || (paddlePos.z>-NVZ && paddlePos.z<0);
  if(isVolley && inNVZ){ fault('NVZ Volley Fault (You)','ai'); return; }
  const tilt=player.paddleTilt; const dir=fw.clone(); dir.y=Math.sin(tilt)*.6+((ball.pos.y<1.0)?.14:.04); dir.normalize();
  const base=9.5; const heightBonus=THREE.MathUtils.clamp((ball.pos.y-.6)*2.5,-1,2.5); const speed=clamp(base+heightBonus,6.5,12.5);
  ball.vel.copy(dir.multiplyScalar(speed)); ball.omega.set(0,-tilt*120,65); ball.lastHitter='player'; player.canHitCooldown=.18;
}

// Physics & rules
ball.lastZ = ball.pos.z; ball.sideNow='player';
function physicsStep(dt){
  if(ball.awaitingServe){
    if(ball.serving==='player'){
      ball.pos.x=THREE.MathUtils.lerp(ball.pos.x, player.pos.x+(ball.serveSide==='right'?1.0:-1.0), .1);
      ball.pos.z=THREE.MathUtils.lerp(ball.pos.z, player.pos.z+.4, .1);
      ball.pos.y=THREE.MathUtils.lerp(ball.pos.y, 1.0, .15); ballMesh.position.copy(ball.pos);
    }else{ aiServeTimer-=dt; if(aiServeTimer<=0) aiDoServe(); }
    return;
  }
  if(!ball.inPlay) return;
  const speed=ball.vel.length(); const drag=ball.vel.clone().multiplyScalar(-DRAG_K*speed*dt);
  const magnus=ball.omega.clone().cross(ball.vel).multiplyScalar(MAGNUS_K*dt);
  ball.vel.add(GRAVITY.clone().multiplyScalar(dt)).add(drag).add(magnus); ball.pos.addScaledVector(ball.vel, dt);
  if(ball.pos.y<BALL_RADIUS && ball.vel.y<0){
    ball.pos.y=BALL_RADIUS; ball.vel.y=-ball.vel.y*.45; ball.vel.x*=.85; ball.vel.z*=.85; ball.omega.multiplyScalar(.90); ball.bouncesSinceServe++;
    if(ball.pos.z<0){ ball.groundBouncesSinceSide=(ball.sideNow==='player')?(ball.groundBouncesSinceSide+1):1; ball.sideNow='player'; }
    else{ ball.groundBouncesSinceSide=(ball.sideNow==='ai')?(ball.groundBouncesSinceSide+1):1; ball.sideNow='ai'; }
    if(ball.bouncesSinceServe===1 && ball.lastHitter==='player'){ if(!isInReceiverServiceBox('ai',ball.pos)){ fault('Bad Serve (Service box)','ai'); return; } }
    if(ball.bouncesSinceServe===1 && ball.lastHitter==='ai'){ if(!isInReceiverServiceBox('player',ball.pos)){ fault('AI Bad Serve','player'); return; } }
  }
  if((ball.lastZ<0 && ball.pos.z>=0) || (ball.lastZ>0 && ball.pos.z<=0)){
    const h=netHeightAtX(ball.pos.x)+BALL_RADIUS*.75;
    if(ball.pos.y<=h){ fault(ball.lastHitter==='player'?'Net (You)':'Net (AI)', ball.lastHitter==='player'?'ai':'player'); return; }
    else{ ball.groundBouncesSinceSide=0; ball.sideNow=(ball.pos.z>=0)?'ai':'player'; }
  }
  ball.lastZ=ball.pos.z;
  if(ball.pos.y<=BALL_RADIUS+.001){
    const outX=(Math.abs(ball.pos.x)>HALF_W+.01), outZ=(Math.abs(ball.pos.z)>HALF_L+.01);
    if(outX||outZ){ const winner=ball.lastHitter==='player'?'ai':'player'; fault(outX?'OUT (sideline)':'OUT (baseline)', winner); return; }
  }
  ballMesh.position.copy(ball.pos);
}
function isInReceiverServiceBox(receiver,p){
  const onFar=(receiver==='ai'); if(onFar && p.z<0) return false; if(!onFar && p.z>0) return false;
  const inDepth=Math.abs(p.z)>=NVZ-0.02 && Math.abs(p.z)<=HALF_L+0.05;
  let mustLeft; if(ball.serving==='player'){ mustLeft=(ball.serveSide==='right'); } else { mustLeft=(ball.serveSide!=='right'); }
  const inHalf=mustLeft?(p.x<0):(p.x>0); return inDepth && inHalf && (Math.abs(p.x)<=HALF_W+0.03);
}
function fault(reason, pointTo){
  faultUI.textContent='FAULT — '+reason; faultUI.style.display='block'; setTimeout(()=>faultUI.style.display='none',900);
  if(ball.serving===pointTo){ score[pointTo]++; } else { ball.serving=pointTo; }
  updateHUD();
  if((score.player>=11||score.ai>=11) && Math.abs(score.player-score.ai)>=2){ lastMsg.textContent=(score.player>score.ai?'You win!':'AI wins!')+' Refresh to play again.'; ball.inPlay=false; ball.awaitingServe=false; return; }
  resetForServe(ball.serving);
}
let aiServeTimer=1.2;
function aiDoServe(){
  if(!(ball.awaitingServe && ball.serving==='ai')) return;
  const hold=.7; const pow=lerp(7,18,(hold-SERVE_MIN)/(SERVE_MAX-SERVE_MIN));
  const toLeft=(ball.serveSide==='right'); const targetX=(toLeft?-1:1)*1.1; const targetZ=-HALF_L+NVZ+1.6;
  const dir=vec3(targetX-ball.pos.x,.6-ball.pos.y,targetZ-ball.pos.z).normalize();
  const serveDir=vec3(dir.x,Math.abs(dir.y),dir.z).normalize();
  ball.vel.copy(serveDir.multiplyScalar(pow)); ball.omega.set(0,(toLeft?1:-1)*15,70);
  ball.awaitingServe=false; ball.inPlay=true; ball.lastHitter='ai'; aiServeTimer=1.2;
}
function updateNVZHint(){
  if(!ball.inPlay){ nvzHint.style.display='none'; return; }
  const onPlayerSide=ball.pos.z<0; const inNVZ=(player.pos.z>-NVZ && player.pos.z<0);
  const wasVolley=ball.groundBouncesSinceSide===0 && onPlayerSide; const close=player.pos.distanceTo(ball.pos)<1.2;
  nvzHint.style.display=(inNVZ && wasVolley && close)?'block':'none';
}

// Main loop
let acc=0,last=performance.now();
function loop(now){
  const dt=Math.min(.05,(now-last)/1000); last=now; acc+=dt;
  updatePlayer(dt); aiUpdate(dt); updateServeHold(dt); updateDots(); updateNVZHint();
  player.canHitCooldown=Math.max(0,player.canHitCooldown-dt);
  while(acc>=DT_FIXED){ physicsStep(DT_FIXED); acc-=DT_FIXED; }
  renderer.render(scene,camera); requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Hide overlay entirely if browser doesn’t support pointer-lock events
if(!('onpointerlockchange' in document)){ lockUI.style.display='none'; centerMsg.style.display='none'; }
</script>
</body>
</html>
