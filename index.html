<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>PicklePop — First-Person (Canvas 2D) v0.1.5</title>
<style>
  html,body{margin:0;height:100%;background:#0a0f17;overscroll-behavior:none}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(#20324f,#132237)}
  #hud{
    position:fixed;inset:12px auto auto 12px;color:#e8f0ff;font:600 14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
    background:rgba(10,15,23,.55);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);
    pointer-events:none;user-select:none
  }
  #hud .big{font-size:18px}
  #hud .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);margin-left:6px}
  #help{
    position:fixed;right:12px;bottom:12px;color:#b9c7e6;font:500 12px/1.4 ui-sans-serif,system-ui;
    background:rgba(10,15,23,.55);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;max-width:min(42ch,45vw)
  }
  #centerMsg{
    position:fixed;left:50%;top:10px;transform:translateX(-50%);font:700 20px/1 ui-sans-serif;
    color:#f5f9ff;background:rgba(14,22,32,.6);backdrop-filter:blur(8px);padding:10px 14px;border-radius:12px;opacity:.95
  }
  #fault{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    font:800 28px/1 ui-sans-serif;letter-spacing:.5px;color:#fff;padding:16px 18px;border-radius:14px;
    background:linear-gradient(180deg, rgba(255,60,60,.92), rgba(180,0,0,.9));box-shadow:0 20px 50px rgba(0,0,0,.5);
    display:none
  }
  #nvzHint{
    position:fixed;left:50%;bottom:70px;transform:translateX(-50%);
    color:#fff;font:700 14px ui-sans-serif;background:rgba(255,45,45,.85);padding:8px 10px;border-radius:10px;display:none
  }
  #lock{
    position:fixed;inset:0;background:radial-gradient(1200px 600px at 50% 30%, rgba(255,255,255,.07), transparent 70%) #0a0f17;
    display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;color:#e8f0ff;text-align:center
  }
  #lock button{
    font:700 14px ui-sans-serif,system-ui;padding:10px 14px;border-radius:12px;border:0;cursor:pointer;
    background:#59a4ff;color:#071525;box-shadow:0 6px 18px rgba(0,0,0,.45)
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div class="big">Score: <span id="pScore">0</span> – <span id="aiScore">0</span> <span class="pill" id="serverPill">Serve: You</span></div>
  <div>Side: <span id="sidePill">Right</span> • To 11 (win by 2) • Aim-assist ON</div>
  <div id="lastMsg" style="opacity:.9;margin-top:6px"></div>
</div>
<div id="fault">FAULT</div>
<div id="nvzHint">NVZ VOLLEY = FAULT</div>
<div id="help">
  <b>Controls</b>: WASD move, Shift sprint, Ctrl crouch, mouse to look, <b>Space (hold)</b> serve, <b>Left-click</b> hit, Q/E paddle tilt.<br/>
  <b>Rules</b>: Singles, 11 to win (by 2). Kitchen (NVZ) volley faults. Diagonal serve must land in service box. No wind.
</div>
<div id="centerMsg">Click Play → move mouse to look • WASD to move • Space to serve</div>

<div id="lock">
  <div style="font:800 28px/1 ui-sans-serif;">PicklePop — FP (2D)</div>
  <div style="opacity:.9;max-width:60ch">Press <b>Play</b>. If the cursor doesn’t lock, just click anywhere on the game to lock it.</div>
  <button id="playBtn">Play</button>
</div>

<script>
/* -------------------------
   Core constants / helpers
------------------------- */
const COURT_W=6.10, COURT_L=13.41, HALF_W=COURT_W/2, HALF_L=COURT_L/2;
const NVZ=2.13, NET_H_CENTER=0.86, NET_H_SIDE=0.914;
const BALL_R=0.037, GRAV=-9.81, DRAG_K=0.9, MAGNUS_K=0.0006;
const DT_FIXED=1/120, SERVE_MIN=0.4, SERVE_MAX=1.0;
const NET_CLEAR_BONUS = BALL_R*0.25;   // was 0.75 — slightly relaxed so clean serves clear as expected

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function netHeightAtX(x){ const t=clamp(Math.abs(x)/HALF_W,0,1); const s=t*t*(3-2*t); return lerp(NET_H_CENTER,NET_H_SIDE,s); }
function normHold(t){ return (clamp(t,SERVE_MIN,SERVE_MAX)-SERVE_MIN)/(SERVE_MAX-SERVE_MIN); }
/* Serve model: more charge = more speed AND more upward bias */
function serveParams(tHoldNorm){
  return {
    pow: lerp(8.5, 18.0, tHoldNorm),       // overall speed
    upk: lerp(0.40, 0.52, tHoldNorm)       // upward factor (multiplies pow → vy)
  };
}

/* -------------------------
   Canvas setup
------------------------- */
const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
let W=innerWidth, H=innerHeight;
function resize(){ W=canvas.width=innerWidth; H=canvas.height=innerHeight; }
addEventListener('resize', resize); resize();

/* -------------------------
   Camera (first-person)
------------------------- */
const cam={ x:0,y:1.7,z:-HALF_L+0.8, yaw:0, pitch:0, near:0.05, fov:75 };
function focal(){ return 0.5*H/Math.tan((cam.fov*Math.PI/180)/2); } // px focal length
function toCamSpace(x,y,z){
  let dx=x-cam.x, dy=y-cam.y, dz=z-cam.z;
  const cy=Math.cos(-cam.yaw), sy=Math.sin(-cam.yaw);
  let x1=cy*dx - sy*dz, z1=sy*dx + cy*dz;
  const cp=Math.cos(-cam.pitch), sp=Math.sin(-cam.pitch);
  let y2=cp*dy - sp*z1, z2=sp*dy + cp*z1;
  return {x:x1,y:y2,z:z2};
}
function project(x,y,z){
  const p=toCamSpace(x,y,z);
  if(p.z<=cam.near) return null;
  const f=focal();
  return { x:W/2 + (p.x/p.z)*f, y:H*0.58 - (p.y/p.z)*f, z:p.z };
}

/* -------------------------
   Input + pointer lock
------------------------- */
let pointerLocked=false;
const lockUI=document.getElementById('lock'), playBtn=document.getElementById('playBtn'), centerMsg=document.getElementById('centerMsg');
playBtn.onclick=()=>{ lockUI.style.display='none'; centerMsg.style.display=''; try{ canvas.requestPointerLock(); }catch(e){} };
document.addEventListener('pointerlockchange', ()=>{ pointerLocked=(document.pointerLockElement===canvas); centerMsg.style.display=pointerLocked?'none':''; });
document.addEventListener('pointerlockerror', ()=>{ pointerLocked=false; centerMsg.textContent='Click the game to lock cursor'; lockUI.style.display='none'; });
canvas.addEventListener('click', ()=>{ if(!pointerLocked) try{ canvas.requestPointerLock(); }catch(e){} });

const keys=new Set();
addEventListener('keydown', e=>{ keys.add(e.code); if(e.code==='Space') beginServeCharge(); if(e.code==='Tab') e.preventDefault(); });
addEventListener('keyup', e=>{ keys.delete(e.code); if(e.code==='Space') releaseServe(); });
addEventListener('mousemove', e=>{
  if(!pointerLocked) return;
  cam.yaw -= e.movementX*0.0025;
  cam.pitch = clamp(cam.pitch - e.movementY*0.0020, -0.9, 0.9);
});

/* -------------------------
   HUD refs
------------------------- */
const hud={ pScore:document.getElementById('pScore'), aiScore:document.getElementById('aiScore'), serverPill:document.getElementById('serverPill'),
            sidePill:document.getElementById('sidePill'), lastMsg:document.getElementById('lastMsg'), fault:document.getElementById('fault'),
            nvz:document.getElementById('nvzHint') };

/* -------------------------
   Entities
------------------------- */
const player={ x:0,z:-HALF_L+0.8, speed:5.5, sprint:8.0, crouch:0, tilt:0 };
const ai={ x:0,z:HALF_L-1.6, speed:5.0, cool:0 };

const ball={ x:0,y:1.0,z:-HALF_L+0.5, vx:0,vy:0,vz:0, ox:0,oy:0,oz:0,
  lastZ:-HALF_L+0.5, bouncesSinceServe:0, lastHitter:'none', inPlay:false, serving:'player',
  serveSide:'right', awaitingServe:true, sideNow:'player', groundBouncesSinceSide:0 };

let serveHold=0;

/* -------------------------
   Scoring / serve state
------------------------- */
const score={ player:0, ai:0 };
function updateHUD(){ hud.pScore.textContent=score.player; hud.aiScore.textContent=score.ai;
  hud.serverPill.textContent=`Serve: ${ball.serving==='player'?'You':'AI'}`;
  hud.sidePill.textContent=ball.serveSide==='right'?'Right':'Left'; }
function resetForServe(serving){
  ball.serving=serving; ball.awaitingServe=true; ball.inPlay=false; ball.bouncesSinceServe=0;
  ball.vx=ball.vy=ball.vz=0; ball.ox=ball.oy=ball.oz=0; ball.groundBouncesSinceSide=0; ball.sideNow=(serving==='player'?'player':'ai');
  const s=((serving==='player'?score.player:score.ai)%2===0)?'right':'left'; ball.serveSide=s; updateHUD();

  if(serving==='player'){
    player.x=(s==='right'?1.0:-1.0); player.z=-HALF_L+1.2;
    ai.x=0; ai.z=HALF_L-1.6;
  }else{
    player.x=0; player.z=-HALF_L+1.6;
    ai.x=(s==='right'?-1.0:1.0); ai.z=HALF_L-1.2;
  }
  const bx=(serving==='player')?(s==='right'?1.0:-1.0):(s==='right'?-1.0:1.0);
  const bz=(serving==='player')?(player.z+.4):(ai.z-.4);
  ball.x=bx; ball.y=1.0; ball.z=bz; ball.lastZ=bz;
  cam.x=player.x; cam.z=player.z; cam.y=1.7;
  hud.lastMsg.textContent=`${serving==='player'?'Your':'AI'} serve — ${s} side`;
}
resetForServe('player');

/* -------------------------
   Controls: move / tilt
------------------------- */
function updatePlayer(dt){
  const targetC=keys.has('ControlLeft')?1:0; player.crouch+=(targetC-player.crouch)*Math.min(1,dt*12);
  cam.y=1.7 - player.crouch*0.5;

  let mx=0,mz=0;
  if(keys.has('KeyW')) mz+=1;
  if(keys.has('KeyS')) mz-=1;
  if(keys.has('KeyA')) mx-=1;
  if(keys.has('KeyD')) mx+=1;
  if(mx||mz){ const inv=1/Math.hypot(mx,mz); mx*=inv;mz*=inv; }
  const spd=keys.has('ShiftLeft')?player.sprint:player.speed;
  const cy=Math.cos(cam.yaw), sy=Math.sin(cam.yaw);
  const vx = mx*cy + mz*sy;
  const vz = -mx*sy + mz*cy;
  player.x += vx*spd*dt; player.z += vz*spd*dt;
  player.x=clamp(player.x,-HALF_W+0.35,HALF_W-0.35);
  player.z=clamp(player.z,-HALF_L+0.4,-0.2);
  cam.x=player.x; cam.z=player.z;

  if(keys.has('KeyQ')) player.tilt+=dt*0.7;
  if(keys.has('KeyE')) player.tilt-=dt*0.7;
  player.tilt=clamp(player.tilt,-.22,.22);
}

/* -------------------------
   Serve handling (FIXED)
------------------------- */
function beginServeCharge(){
  if(ball.awaitingServe && ball.serving==='player' && serveHold===0){
    serveHold=0.0001; hud.lastMsg.textContent='Hold Space, release to serve (diagonal)';
  }
}
function releaseServe(){
  if(!(ball.awaitingServe && ball.serving==='player' && serveHold>0)){ serveHold=0; return; }
  const n = normHold(serveHold);
  const {pow, upk} = serveParams(n);
  const toLeft=(ball.serveSide==='left');
  const targetX=(toLeft?1:-1)*1.1;
  const targetZ=HALF_L - NVZ - (COURT_L/4 - NVZ/2)*0.6;

  const dx=targetX-ball.x, dz=targetZ-ball.z; const L=Math.hypot(dx,dz)||1;
  const nx=dx/L, nz=dz/L;

  ball.vx=nx*pow;
  ball.vz=nz*pow;
  ball.vy=pow*upk;               // ↑ bigger upward push so serves clear the net
  ball.ox=0; ball.oy=(toLeft?-1:1)*18; ball.oz=90;  // a bit more topspin = drops after clearing
  ball.awaitingServe=false; ball.inPlay=true; ball.lastHitter='player';
  hud.lastMsg.textContent='';
  serveHold=0;
}
function updateServeHold(dt){ if(ball.awaitingServe && ball.serving==='player' && serveHold>0){ serveHold+=dt; if(serveHold>SERVE_MAX) serveHold=SERVE_MAX; } }

/* -------------------------
   AI
------------------------- */
function aiUpdate(dt){
  const targetX=clamp(ball.x,-HALF_W+.4,HALF_W-.4);
  const baseZ=HALF_L-(ball.z>HALF_L*.5?1.8:2.4);
  const targetZ=baseZ;
  const dx=targetX-ai.x, dz=targetZ-ai.z, d=Math.hypot(dx,dz);
  if(d>1e-3){ const s=ai.speed*dt; const k=Math.min(1,s/d); ai.x+=dx*k; ai.z+=dz*k; }
  ai.x=clamp(ai.x,-HALF_W+.35,HALF_W-.35); ai.z=clamp(ai.z,.2,HALF_L-.4);
  ai.cool-=dt;

  const reach=0.95, onAISide=ball.z>0;
  const inReach=(Math.hypot(ball.x-ai.x, (ball.z-(ai.z-0.25)))<reach && Math.abs(ball.y-0.8)<1.2);
  if(ball.inPlay && onAISide && ai.cool<=0 && inReach){
    const tgtX=ball.x>0?-1.2:1.2, tgtZ=-HALF_L+1.8;
    const vx=tgtX-ball.x, vy=.9-ball.y, vz=tgtZ-ball.z; const L=Math.hypot(vx,vy,vz)||1;
    const spd=clamp(8+(ball.y-.5)*4,6,11);
    ball.vx=(vx/L)*spd; ball.vy=(vy/L)*spd; ball.vz=(vz/L)*spd;
    ball.ox=0; ball.oy=(tgtX>0?-1:1)*25; ball.oz=55;
    ball.lastHitter='ai'; ai.cool=.22;
  }
}

/* -------------------------
   Hit detection (first-person)
------------------------- */
function paddleWorld(){
  const cy=Math.cos(cam.yaw), sy=Math.sin(cam.yaw);
  const cp=Math.cos(cam.pitch), sp=Math.sin(cam.pitch);
  const fwd={ x: sy*cp, y: -sp, z: cy*cp*-1 };
  const right={ x: cy, y:0, z: sy };
  const up={ x: sy*sp, y: cp, z: -cy*sp };

  const px=cam.x + right.x*0.35 + fwd.x*0.55 + (-up.x)*0.15;
  const py=cam.y + right.y*0.35 + fwd.y*0.55 + (-up.y)*0.15;
  const pz=cam.z + right.z*0.35 + fwd.z*0.55 + (-up.z)*0.15;

  const ct=Math.cos(player.tilt), st=Math.sin(player.tilt);
  const upTilt={ x: up.x*ct + fwd.x*st, y: up.y*ct + fwd.y*st, z: up.z*ct + fwd.z*st };
  return { pos:{x:px,y:py,z:pz}, basis:{fwd,right,up:upTilt} };
}

function tryHit(){
  if(!ball.inPlay) return;
  const pw=paddleWorld();
  const dx=ball.x-pw.pos.x, dy=ball.y-pw.pos.y, dz=ball.z-pw.pos.z;
  if(Math.hypot(dx,dy,dz)>0.95) return;

  const isVolley=(ball.z<0) && (ball.groundBouncesSinceSide===0);
  const inNVZ=(player.z>-NVZ && player.z<0);
  if(isVolley && inNVZ){ fault('NVZ Volley Fault (You)','ai'); return; }

  const f=pw.basis.fwd;
  let dir={ x:f.x, y:f.y + (ball.y<1.0?0.14:0.04), z:f.z };
  const L=Math.hypot(dir.x,dir.y,dir.z)||1; dir.x/=L; dir.y/=L; dir.z/=L;
  const base=9.5, heightBonus=clamp((ball.y-.6)*2.5,-1,2.5);
  const spd=clamp(base+heightBonus,6.5,12.5);
  ball.vx=dir.x*spd; ball.vy=dir.y*spd; ball.vz=dir.z*spd;
  ball.ox=0; ball.oy=-player.tilt*120; ball.oz=65;
  ball.lastHitter='player';
}
canvas.addEventListener('mousedown', e=>{ if(e.button===0) tryHit(); });

/* -------------------------
   Physics & rules
------------------------- */
function physicsStep(dt){
  if(ball.awaitingServe){
    if(ball.serving==='player'){
      ball.x=lerp(ball.x, player.x+(ball.serveSide==='right'?1.0:-1.0), .1);
      ball.z=lerp(ball.z, player.z+.4, .1);
      ball.y=lerp(ball.y, 1.0, .15);
    }else{
      aiServeTimer-=dt; if(aiServeTimer<=0) aiDoServe();
    }
    return;
  }
  if(!ball.inPlay) return;

  const vlen=Math.hypot(ball.vx,ball.vy,ball.vz);
  const drag=DRAG_K*vlen;
  const ax = -drag*ball.vx + MAGNUS_K*(ball.oy*ball.vz - ball.oz*ball.vy);
  const ay = GRAV - drag*ball.vy + MAGNUS_K*(ball.oz*ball.vx - ball.ox*ball.vz);
  const az = -drag*ball.vz + MAGNUS_K*(ball.ox*ball.vy - ball.oy*ball.vx);
  ball.vx+=ax*dt; ball.vy+=ay*dt; ball.vz+=az*dt;
  ball.x+=ball.vx*dt; ball.y+=ball.vy*dt; ball.z+=ball.vz*dt;

  if(ball.y<BALL_R && ball.vy<0){
    ball.y=BALL_R; ball.vy=-ball.vy*.45; ball.vx*=.85; ball.vz*=.85;
    ball.ox*=.90; ball.oy*=.90; ball.oz*=.90; ball.bouncesSinceServe++;
    if(ball.z<0){ ball.groundBouncesSinceSide=(ball.sideNow==='player')?(ball.groundBouncesSinceSide+1):1; ball.sideNow='player'; }
    else{ ball.groundBouncesSinceSide=(ball.sideNow==='ai')?(ball.groundBouncesSinceSide+1):1; ball.sideNow='ai'; }
    if(ball.bouncesSinceServe===1 && ball.lastHitter==='player'){ if(!isInReceiverServiceBox('ai',ball.x,ball.z)){ fault('Bad Serve (Service box)','ai'); return; } }
    if(ball.bouncesSinceServe===1 && ball.lastHitter==='ai'){ if(!isInReceiverServiceBox('player',ball.x,ball.z)){ fault('AI Bad Serve','player'); return; } }
  }

  if((ball.lastZ<0 && ball.z>=0) || (ball.lastZ>0 && ball.z<=0)){
    const h=netHeightAtX(ball.x)+NET_CLEAR_BONUS;
    if(ball.y<=h){ fault(ball.lastHitter==='player'?'Net (You)':'Net (AI)', ball.lastHitter==='player'?'ai':'player'); return; }
    else{ ball.groundBouncesSinceSide=0; ball.sideNow=(ball.z>=0)?'ai':'player'; }
  }
  ball.lastZ=ball.z;

  if(ball.y<=BALL_R+.001){
    const outX=(Math.abs(ball.x)>HALF_W+.01), outZ=(Math.abs(ball.z)>HALF_L+.01);
    if(outX||outZ){ const winner=ball.lastHitter==='player'?'ai':'player'; fault(outX?'OUT (sideline)':'OUT (baseline)',winner); return; }
  }
}
function isInReceiverServiceBox(receiver,x,z){
  const onFar=(receiver==='ai'); if(onFar && z<0) return false; if(!onFar && z>0) return false;
  const inDepth=Math.abs(z)>=NVZ-0.02 && Math.abs(z)<=HALF_L+0.05;
  let mustLeft; if(ball.serving==='player'){ mustLeft=(ball.serveSide==='right'); } else { mustLeft=(ball.serveSide!=='right'); }
  const inHalf=mustLeft?(x<0):(x>0);
  return inDepth && inHalf && (Math.abs(x)<=HALF_W+0.03);
}
function fault(reason, pointTo){
  hud.fault.textContent='FAULT — '+reason; hud.fault.style.display='block'; setTimeout(()=>hud.fault.style.display='none',900);
  if(ball.serving===pointTo){ score[pointTo]++; } else { ball.serving=pointTo; }
  updateHUD();
  if((score.player>=11||score.ai>=11) && Math.abs(score.player-score.ai)>=2){
    hud.lastMsg.textContent=(score.player>score.ai?'You win!':'AI wins!')+' Refresh to play again.'; ball.inPlay=false; ball.awaitingServe=false; return;
  }
  resetForServe(ball.serving);
}

/* AI serve (FIXED: higher up-bias) */
let aiServeTimer=1.2;
function aiDoServe(){
  if(!(ball.awaitingServe && ball.serving==='ai')) return;
  const n=0.6; // pretend ~60% charge
  const {pow, upk} = serveParams(n);
  const toLeft=(ball.serveSide==='right');
  const targetX=(toLeft?-1:1)*1.1;
  const targetZ=-HALF_L + NVZ + 1.6;
  const dx=targetX-ball.x, dz=targetZ-ball.z, L=Math.hypot(dx,dz)||1;
  const nx=dx/L, nz=dz/L;
  ball.vx=nx*pow; ball.vz=nz*pow; ball.vy=pow*upk; // ↑ more lift
  ball.ox=0; ball.oy=(toLeft?1:-1)*18; ball.oz=90;
  ball.awaitingServe=false; ball.inPlay=true; ball.lastHitter='ai'; aiServeTimer=1.2;
}

/* -------------------------
   Aim-assist (matches serve model)
------------------------- */
const dots=new Array(7).fill(null).map(()=>({x:0,y:0,z:0,show:false,a:1}));
function updateDots(){
  dots.forEach(d=>d.show=false);
  const pw=paddleWorld(); const reach=0.95;
  const inReach=Math.hypot(ball.x-pw.pos.x,ball.y-pw.pos.y,ball.z-pw.pos.z)<reach && ball.z<0;
  const show=(ball.inPlay && inReach) || (ball.awaitingServe && ball.serving==='player');
  if(!show) return;

  let vx,vy,vz;
  if(ball.awaitingServe){
    const n = normHold(serveHold>0?serveHold:SERVE_MIN);
    const {pow, upk} = serveParams(n);
    const toLeft=(ball.serveSide==='left'); const tx=(toLeft?1:-1)*1.1, tz=HALF_L - NVZ - (COURT_L/4 - NVZ/2)*0.6;
    const dx=tx-ball.x, dz=tz-ball.z, L=Math.hypot(dx,dz)||1;
    vx=(dx/L)*pow; vz=(dz/L)*pow; vy=pow*upk;
  }else{
    const f=pw.basis.fwd; const dir={ x:f.x, y:f.y + (ball.y<1.0?0.12:0.02), z:f.z };
    const L=Math.hypot(dir.x,dir.y,dir.z)||1; vx=dir.x/L*9.5; vy=dir.y/L*9.5; vz=dir.z/L*9.5;
  }
  let px=ball.x, py=ball.y, pz=ball.z, vvx=vx, vvy=vy, vvz=vz;
  for(let i=0;i<dots.length;i++){
    for(let s=0;s<3;s++){
      const vlen=Math.hypot(vvx,vvy,vvz), drag=DRAG_K*vlen*0.04;
      const ax=-drag*vvx + MAGNUS_K*(ball.oy*vvz - ball.oz*vvy);
      const ay=GRAV - drag*vvy + MAGNUS_K*(ball.oz*vvx - ball.ox*vvz);
      const az=-drag*vvz + MAGNUS_K*(ball.ox*vvy - ball.oy*vvx);
      vvx+=ax*(0.1/3); vvy+=ay*(0.1/3); vvz+=az*(0.1/3);
      px+=vvx*(0.1/3); py+=vvy*(0.1/3); pz+=vvz*(0.1/3);
      if(py<BALL_R){ vvy=Math.abs(vvy)*.45; px+=0; py=BALL_R; vvz*=.87; vvx*=.87; }
    }
    dots[i].x=px; dots[i].y=py; dots[i].z=pz; dots[i].show=true; dots[i].a=0.9 - i*0.12;
  }
}

/* -------------------------
   NVZ hint
------------------------- */
function updateNVZHint(){
  if(!ball.inPlay){ hud.nvz.style.display='none'; return; }
  const inNVZ=(player.z>-NVZ && player.z<0);
  const onPlayerSide=ball.z<0;
  const wasVolley=ball.groundBouncesSinceSide===0 && onPlayerSide;
  const close=Math.hypot(player.x-ball.x, player.z-ball.z)<1.2;
  hud.nvz.style.display=(inNVZ && wasVolley && close)?'block':'none';
}

/* -------------------------
   Rendering (Canvas 2D)
------------------------- */
function drawSky(){
  ctx.save(); ctx.globalAlpha=0.06; ctx.fillStyle='#ffffff';
  ctx.beginPath(); ctx.arc(W*0.15, H*0.18, 140, 0, Math.PI*2); ctx.fill(); ctx.restore();
}
function quad(p0,p1,p2,p3, fill){
  const a=project(...p0), b=project(...p1), c=project(...p2), d=project(...p3);
  if(!a||!b||!c||!d) return;
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.lineTo(c.x,c.y); ctx.lineTo(d.x,d.y); ctx.closePath();
  ctx.fillStyle=fill; ctx.fill();
}
function drawCourt(){
  quad([-HALF_W,0,-HALF_L],[HALF_W,0,-HALF_L],[HALF_W,0,HALF_L],[-HALF_W,0,HALF_L],'#1d7fb5');
  const lw=0.05;
  quad([-HALF_W,0,-HALF_L],[-HALF_W+lw,0,-HALF_L],[-HALF_W+lw,0,HALF_L],[-HALF_W,0,HALF_L],'#ffffff');
  quad([HALF_W-lw,0,-HALF_L],[HALF_W,0,-HALF_L],[HALF_W,0,HALF_L],[HALF_W-lw,0,HALF_L],'#ffffff');
  quad([-HALF_W,0,-HALF_L], [HALF_W,0,-HALF_L], [HALF_W,0,-HALF_L+lw], [-HALF_W,0,-HALF_L+lw], '#ffffff');
  quad([-HALF_W,0, HALF_L-lw], [HALF_W,0, HALF_L-lw], [HALF_W,0, HALF_L], [-HALF_W,0, HALF_L], '#ffffff');
  const clw=0.04;
  quad([-clw/2,0,-HALF_L], [clw/2,0,-HALF_L], [clw/2,0,-NVZ], [-clw/2,0,-NVZ], '#ffffff');
  quad([-clw/2,0, NVZ], [clw/2,0, NVZ], [clw/2,0, HALF_L], [-clw/2,0, HALF_L], '#ffffff');
  quad([-HALF_W,0,-NVZ-lw/2], [HALF_W,0,-NVZ-lw/2], [HALF_W,0,-NVZ+lw/2], [-HALF_W,0,-NVZ+lw/2], '#ffffff');
  quad([-HALF_W,0, NVZ-lw/2], [HALF_W,0, NVZ-lw/2], [HALF_W,0, NVZ+lw/2], [-HALF_W,0, NVZ+lw/2], '#ffffff');

  ctx.save(); ctx.strokeStyle='rgba(111,160,200,.35)'; ctx.lineWidth=1;
  for(let i=-3;i<=3;i++){
    const z=i*4.5;
    const a=project(-HALF_W-2,1.2,z), b=project(HALF_W+2,1.2,z);
    if(a&&b){ ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
  }
  ctx.restore();
}
function drawNet(){
  const bands=14, alpha=0.5;
  for(let i=0;i<bands;i++){
    const t0=i/bands, t1=(i+1)/bands;
    const x0=lerp(-HALF_W,HALF_W,t0), x1=lerp(-HALF_W,HALF_W,t1);
    const h0=netHeightAtX(x0), h1=netHeightAtX(x1);
    const a0=project(x0,0,0), a1=project(x1,0,0), b0=project(x0,h0*0.95,0), b1=project(x1,h1*0.95,0);
    if(a0&&a1&&b0&&b1){
      ctx.beginPath(); ctx.moveTo(a0.x,a0.y); ctx.lineTo(a1.x,a1.y); ctx.lineTo(b1.x,b1.y); ctx.lineTo(b0.x,b0.y); ctx.closePath();
      ctx.fillStyle=`rgba(42,47,54,${alpha})`; ctx.fill();
    }
  }
}
function drawOpponent(){
  const w=0.5,h=1.7;
  const p0=project(ai.x-w/2,0,ai.z), p1=project(ai.x+w/2,0,ai.z), p2=project(ai.x+w/2,h,ai.z), p3=project(ai.x-w/2,h,ai.z);
  if(p0&&p1&&p2&&p3){
    ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath();
    ctx.fillStyle='#ff8b59'; ctx.fill();
  }
}
function drawBall(){
  const p=project(ball.x,ball.y,ball.z); if(!p) return;
  const r=clamp(BALL_R/p.z * focal()*2.2, 2, 22);
  const sg=project(ball.x,0,ball.z);
  if(sg){ ctx.fillStyle='rgba(0,0,0,.25)'; ctx.beginPath(); ctx.ellipse(sg.x,sg.y, r*1.4, r*0.7, 0, 0, Math.PI*2); ctx.fill(); }
  ctx.fillStyle='#ffef88'; ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
}
function drawPaddle(){
  const pw=paddleWorld();
  const hw=0.11, hh=0.16;
  const r=pw.basis.right, u=pw.basis.up, c=pw.pos;
  const verts=[
    [c.x - hw*r.x - hh*u.x, c.y - hw*r.y - hh*u.y, c.z - hw*r.z - hh*u.z],
    [c.x + hw*r.x - hh*u.x, c.y + hw*r.y - hh*u.y, c.z + hw*r.z - hh*u.z],
    [c.x + hw*r.x + hh*u.x, c.y + hw*r.y + hh*u.y, c.z + hw*r.z + hh*u.z],
    [c.x - hw*r.x + hh*u.x, c.y - hw*r.y + hh*u.y, c.z - hw*r.z + hh*u.z],
  ];
  const p=verts.map(v=>project(v[0],v[1],v[2]));
  if(p.every(Boolean)){
    ctx.beginPath(); ctx.moveTo(p[0].x,p[0].y); for(let i=1;i<4;i++) ctx.lineTo(p[i].x,p[i].y); ctx.closePath();
    ctx.fillStyle='#2b5fff'; ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=1.5; ctx.fill(); ctx.stroke();
  }
}
function drawDots(){
  for(const d of dots){
    if(!d.show) continue;
    const p=project(d.x,d.y,d.z); if(!p) continue;
    const r=clamp(5/p.z * focal()*0.03, 2, 6);
    ctx.fillStyle=`rgba(255,255,255,${d.a})`;
    ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
  }
}

/* -------------------------
   Main loop
------------------------- */
let acc=0, last=performance.now();
function loop(now){
  const dt=Math.min(.05,(now-last)/1000); last=now; acc+=dt;

  updatePlayer(dt);
  aiUpdate(dt);
  updateServeHold(dt);
  updateDots();
  updateNVZHint();

  while(acc>=DT_FIXED){ physicsStep(DT_FIXED); acc-=DT_FIXED; }

  ctx.clearRect(0,0,W,H);
  drawSky();
  drawCourt();
  drawNet();
  drawOpponent();
  drawDots();
  drawBall();
  drawPaddle();

  if(!ball.awaitingServe || (ball.awaitingServe && ball.serving==='player' && serveHold>0)) centerMsg.style.display='none';
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* -------------------------
   Misc UI init
------------------------- */
updateHUD();
</script>
</body>
</html>
