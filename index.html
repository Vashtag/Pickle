<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pixel Pickle — Isometric Singles (V1.3.1)</title>
<style>
  :root{
    --bg:#0b1020; --hud:#0b1229; --ink:#e6edf3; --muted:#9aa4b2; --accent:#86efac; --warn:#f59e0b; --err:#ef4444;
    --kitchen:#2c3357; --court:#1a2456; --lines:#f8fafc; --net:#cbd5e1;
    --pixel-scale:3; /* SNES-ish chunky pixels */
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 60% 30%,#0e1630 0,#0b1020 60%,#070a14 100%);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
  #wrap{display:grid;place-items:center;height:100%}
  canvas{image-rendering: pixelated;image-rendering: crisp-edges;background:transparent;outline:1px solid #111827;border-radius:8px;box-shadow:0 8px 60px rgba(0,0,0,.45)}
  #hud{position:fixed;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center;padding-top:8px;gap:8px;font-weight:600}
  .pill{pointer-events:auto;background:rgba(11,18,41,.7);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;display:flex;gap:10px;align-items:center}
  .score{font-family:monospace;font-size:18px;letter-spacing:1px}
  .serve{padding:2px 6px;border-radius:6px;background:#0c1a3a;border:1px solid rgba(255,255,255,.06);font-size:12px}
  .msg{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(11,18,41,.75);border:1px solid rgba(255,255,255,.08);padding:8px 12px;border-radius:10px;font-size:13px}
  .legend{position:fixed;right:10px;bottom:10px;background:rgba(11,18,41,.8);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;font-size:12px;line-height:1.5}
  .paused{position:fixed;inset:0;display:none;place-items:center;background:rgba(3,6,15,.6)}
  .paused.show{display:grid}
  .panel{background:rgba(11,18,41,.9);border:1px solid rgba(255,255,255,.1);padding:18px 22px;border-radius:12px;max-width:520px}
  .panel h2{margin:0 0 6px 0}
  .small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div id="wrap"><canvas id="game" width="1000" height="650" tabindex="0"></canvas></div>

<div id="hud">
  <div class="pill score">
    <span id="pScore">0</span>&nbsp;—&nbsp;<span id="aScore">0</span>
    <span id="call" style="margin-left:10px;color:var(--muted)"></span>
    <span id="serve" class="serve" title="Serving side"></span>
  </div>
</div>

<div class="legend">
  <b>Controls</b><br/>
  Move: W/S/A/D (acceleration) &nbsp;•&nbsp; Dash: Shift<br/>
  Shots (hold to charge): J=Drive, K=Dink, L=Lob, I=Drop<br/>
  Spin: hold Q=Backspin, E=Topspin<br/>
  <b>Serve:</b> hold Space to charge (even=Right, odd=Left), release to hit<br/>
  Pause: P
</div>

<div class="msg" id="msg">Singles • Side-out to 11 (win by 2) • Indoor • NVZ enforced • Two-bounce rule</div>

<div class="paused" id="paused">
  <div class="panel">
    <h2>Paused</h2>
    <div class="small">Light aim assist • Realistic serve rules & movement inertia</div>
    <ul>
      <li>Diagonal serve to correct box; NVZ line fault on serve</li>
      <li>Two-bounce rule enforced (serve bounce, return bounce → then volleys)</li>
      <li>AI serves on time and returns after legal bounces</li>
    </ul>
    <div class="small">V1.3.1 • © You</div>
  </div>
</div>

<script>
(() => {
  // --- Config ---
  const cfg = {
    courtW: 6.10, courtL: 13.41, kitchen: 2.13, netH: 0.872,
    serveToWin: 11,
    // Physics (indoor realism)
    g: 12.0, drag: 1.05, spinZ: 5.5, sideSpinK: 1.3,
    wobbleAmpDeg: 1.2, wobbleFreq: 3.2,
    // Movement
    speed: 5.7, accel: 18.0, decel: 22.0, dashBoost: 1.2, dashDur: 0.35,
    staminaMax: 100, staminaCost: 30, staminaRegen: 18,
    // Inputs/UX
    aimAssist: 0.26, pixelScale: parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pixel-scale')) || 3,
    // Charge hold
    chargeMax: 1.25, chargeMinMul: 0.65, chargeMaxMul: 1.55
  };
  const eps = 0.02;

  // Canvas/projection
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const iso = { tileW: 52, tileH: 26, zScale: 28,
    toScreen(x,y,z=0){ return [ (x-y)*this.tileW/2 + W/2, (x+y)*this.tileH/2 + H*0.48 - z*this.zScale ]; }
  };
  const halfL = cfg.courtL/2, halfW = cfg.courtW/2;

  // Audio (uses /audio/hit*.mp3 if present, else synth)
  const audio = (()=>{const C=new (window.AudioContext||window.webkitAudioContext)();let S={};
    const load=async(n,u)=>{try{const r=await fetch(u);if(!r.ok)throw 0;const a=await r.arrayBuffer();S[n]=await C.decodeAudioData(a);}catch{}};
    load('hit1','/audio/hit1.mp3'); load('hit2','/audio/hit2.mp3'); load('bounce1','/audio/bounce1.mp3');
    const play=(b,g=0.7,r=1)=>{const s=C.createBufferSource();s.buffer=b;s.playbackRate.value=r;const G=C.createGain();G.gain.value=g;s.connect(G).connect(C.destination);s.start();};
    const synth=(t='hit',v=1)=>{const now=C.currentTime;const nb=C.createBuffer(1,C.sampleRate*0.06,C.sampleRate);const d=nb.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=(Math.random()*2-1)*0.35;const n=C.createBufferSource();n.buffer=nb;const bp=C.createBiquadFilter();bp.type='bandpass';bp.frequency.value=(t==='bounce')?900:1300;bp.Q.value=2.5;const o=C.createOscillator();o.type='sine';o.frequency.value=(t==='bounce')?200:260;const og=C.createGain();og.gain.setValueAtTime(0.6*v,now);og.gain.exponentialRampToValueAtTime(0.001,now+0.06);const ng=C.createGain();ng.gain.setValueAtTime(0.5*v,now);ng.gain.exponentialRampToValueAtTime(0.001,now+0.05);n.connect(bp).connect(ng);const mix=C.createGain();ng.connect(mix);o.connect(og);og.connect(mix);mix.connect(C.destination);n.start();n.stop(now+0.06);o.start();o.stop(now+0.06);};
    return {hit:(v=1)=>S.hit1?play(S.hit1,0.6*v,1+Math.random()*0.05):synth('hit',v),
            hit2:(v=1)=>S.hit2?play(S.hit2,0.6*v,1+Math.random()*0.05):synth('hit',0.9*v),
            bounce:(v=1)=>S.bounce1?play(S.bounce1,0.5*v,1+Math.random()*0.08):synth('bounce',0.9*v),
            resume:()=>C.resume?.()};
  })();

  // --- Input (layout-proof via e.code) ---
  const keys = new Set();
  canvas.addEventListener('pointerdown', () => { canvas.focus(); audio.resume?.(); }, {passive:true});
  window.addEventListener('keydown', (e) => {
    const code = e.code;
    if (code === 'Space' || code.startsWith('Arrow')) e.preventDefault();
    if (code === 'KeyP') { togglePause(); return; }
    keys.add(code);
    if (['KeyJ','KeyK','KeyL','KeyI'].includes(code)) beginShotCharge(code);
    if (code === 'Space') beginServeCharge();
  }, {passive:false});
  window.addEventListener('keyup', (e) => {
    const code = e.code;
    keys.delete(code);
    if (['KeyJ','KeyK','KeyL','KeyI'].includes(code)) releaseShotCharge(code);
    if (code === 'Space') releaseServeCharge();
  }, {passive:false});
  window.addEventListener('blur', () => keys.clear());

  // Entities
  function makePlayer(side=1){return{ x:0,y:side*(halfL-0.8),z:0,vx:0,vy:0,speed:cfg.speed,
    dashT:0,stamina:cfg.staminaMax,serving:true,width:0.55,depth:0.35,reach:0.85,lastHitTime:0 }; }
  const player=makePlayer(+1), ai=makePlayer(-1); ai.serving=false;
  const ball={ x:0,y:0,z:1,vx:0,vy:0,vz:0,spinTB:0,sideSpin:0,alive:false,wobblePhase:Math.random()*Math.PI*2,
               bouncedSinceHit:true }; // true = last thing was a bounce

  const state={ pScore:0,aScore:0,serving:+1,rally:false,paused:false,msgT:3,
                waitingServe:true,rallyPhase:'serve',serverBoxSign:+1 };

  const ui = { pScore:el('pScore'), aScore:el('aScore'), call:el('call'), serve:el('serve'), msg:el('msg'), paused:el('paused') };
  function el(id){return document.getElementById(id);}

  // Serve helpers (even=Right, odd=Left)
  function currentServerScore(){ return (state.serving>0)? state.pScore : state.aScore; }
  function computeServerBoxSign(){ return (currentServerScore()%2===0)? +1 : -1; }

  function setupServe(serverSide=state.serving){
    state.waitingServe=true; state.rally=false; state.rallyPhase='serve';
    state.serverBoxSign=computeServerBoxSign();
    Object.assign(ball,{alive:false,vx:0,vy:0,vz:0,spinTB:0,sideSpin:0,z:1,bouncedSinceHit:true});
    const s=(serverSide>0)? player: ai;
    ball.x=s.x; ball.y=s.y + (serverSide>0? -0.5 : +0.5);
    updateScoreUI();
    const sideLabel=(state.serverBoxSign>0?'Right':'Left');
    if(serverSide>0){ flashMsg(`Your serve — ${sideLabel} box. Hold SPACE to charge, release to hit.`); }
    else { flashMsg(`AI serve — ${sideLabel} box.`); aiServeT = 0.8 + Math.random()*0.7; }
  }

  function launchServe(withSide, powerMul){
    state.waitingServe=false; state.rally=true; state.rallyPhase='serve';
    ball.alive=true; ball.bouncedSinceHit=false;
    const sign=state.serverBoxSign;
    const targetX=(Math.random()*0.4 + 0.3)*sign;
    const targetY=-withSide*(halfL - (cfg.kitchen + 1.0));
    const baseSpeed=7.2, baseZ=1.5;
    const v=aimTo(ball.x,ball.y,targetX,targetY, baseZ*Math.sqrt(powerMul), baseSpeed*powerMul);
    ball.vx=v.vx; ball.vy=v.vy; ball.vz=v.vz; audio.hit(1.0);
  }

  // AI brain
  const aiBrain={ react:0.09, errCone:0.08, tSince:0 };
  let aiServeT=0;

  aiBrain.decide=function(dt){
    this.tSince+=dt;

    // AI serve flow
    if(state.waitingServe && state.serving<0){
      const margin=0.25, sign=state.serverBoxSign;
      ai.x=clamp(ai.x, (sign>0? 0.0: -halfW+margin), (sign>0? halfW-margin: 0.0));
      ai.y=clamp(ai.y, -halfL+0.6, -halfL+0.1);
      aiServeT -= dt;
      if(aiServeT<=0){ const power=0.9 + Math.random()*0.5; launchServe(-1, power); }
      return;
    }

    // Move toward predicted bounce/intercept
    const pred = predictLanding(1.4);
    let tx=0, ty=-2.6;
    if(pred){
      if(pred.y<0){ // AI half
        tx = clamp(pred.x, -halfW+0.55, halfW-0.55);
        ty = clamp(pred.y + 0.65, -halfL+0.9, -0.9);
      } else { // ball on player half: recover center-ish
        tx = clamp(pred.x*0.6, -halfW+0.6, halfW-0.6);
        ty = -2.6;
      }
    }
    steerTo(ai, tx, ty, dt);

    if(!ball.alive) return;

    // Avoid illegal volleys in serve/return phases
    const ballOnAISide = (ball.y < 0);
    let mayAttempt = (state.rallyPhase==='open') || ball.bouncedSinceHit;
    if(state.rallyPhase==='serve') mayAttempt = mayAttempt && ballOnAISide; // must bounce on AI side when receiving

    if(!mayAttempt) return;

    // Hit window
    const d2 = sq(ai.x - ball.x) + sq(ai.y - ball.y);
    const canReach = d2 < sq(ai.reach*1.05) && ball.z <= 1.8;
    const since = nowTime() - ai.lastHitTime;
    if(canReach && since > (this.react + 0.03*Math.random())){
      // Choose shot by context
      let shot='drive';
      const youFar = player.y > 3.0, nearNVZ = Math.abs(ai.y) < (cfg.kitchen + 0.6);
      if(youFar && Math.random()<0.55) shot='drop';
      else if(nearNVZ && Math.random()<0.5) shot='dink';
      else if(Math.random()<0.12) shot='lob';

      const spin = (shot==='drive')? +0.5 : (shot==='dink'? -0.35 : (shot==='drop'? +0.25 : -0.25));
      const power = 0.9 + Math.random()*0.4;
      performShot(ai, -1, shot, spin, 0, power);
      ai.lastHitTime=nowTime();
    }
  };

  // Player control (accel/decel)
  function handlePlayer(dt){
    const p=player;
    let mx=0,my=0;
    if (keys.has('KeyA')) mx -= 1;
    if (keys.has('KeyD')) mx += 1;
    if (keys.has('KeyW')) my -= 1;
    if (keys.has('KeyS')) my += 1;

    const dash = (keys.has('ShiftLeft') || keys.has('ShiftRight')) && p.stamina>=cfg.staminaCost && p.dashT<=0;
    if(dash){ p.dashT=cfg.dashDur; p.stamina-=cfg.staminaCost; }
    const dashMul = (p.dashT>0)? cfg.dashBoost:1.0;

    const want = vecNorm(mx,my);
    const wantVx = want.x * p.speed * dashMul, wantVy = want.y * p.speed * dashMul;

    p.vx = approach(p.vx, wantVx, (Math.sign(wantVx-p.vx)>=0? cfg.accel: cfg.decel)*dt);
    p.vy = approach(p.vy, wantVy, (Math.sign(wantVy-p.vy)>=0? cfg.accel: cfg.decel)*dt);

    p.x += p.vx*dt; p.y += p.vy*dt;

    // bounds (player half)
    p.x = clamp(p.x, -halfW+0.4, halfW-0.4);
    p.y = clamp(p.y, 0.7, halfL-0.6);

    // During your serve, restrict to correct box behind baseline
    if(state.waitingServe && state.serving>0){
      const margin=0.25, sign=state.serverBoxSign;
      p.x = clamp(p.x, (sign>0? 0.0: -halfW+margin), (sign>0? halfW-margin: 0.0));
      p.y = clamp(p.y, halfL-0.35, halfL-0.1);
    }

    if(p.dashT>0) p.dashT -= dt; else p.stamina = Math.min(cfg.staminaMax, p.stamina + cfg.staminaRegen*dt);
  }

  // Charge helpers (by key code)
  const charge={active:false,type:null,key:null,t0:0,val:0};
  function beginShotCharge(code){
    if(state.paused || state.waitingServe || charge.active) return;
    charge.active=true; charge.type='shot'; charge.key=code; charge.t0=nowTime(); audio.resume?.();
  }
  function releaseShotCharge(code){
    if(!charge.active || charge.type!=='shot' || charge.key!==code) return;
    const mul=endChargeGetMul(); endCharge();
    const spinTB=(keys.has('KeyE')? +1:0) + (keys.has('KeyQ')? -1:0);
    const map={ KeyJ:'drive', KeyK:'dink', KeyL:'lob', KeyI:'drop' }, type=map[code]||'drive';
    if(!ball.alive) return;
    const canReach = (sq(player.x - ball.x) + sq(player.y - ball.y)) < sq(player.reach) && ball.z <= 1.8;
    if(!canReach) return;
    performShot(player, +1, type, spinTB*0.8, 0, mul);
  }
  function beginServeCharge(){
    if(state.paused || !state.waitingServe || state.serving<0 || charge.active) return;
    charge.active=true; charge.type='serve'; charge.key='Space'; charge.t0=nowTime(); audio.resume?.();
  }
  function releaseServeCharge(){
    if(!charge.active || charge.type!=='serve') return;
    const mul=endChargeGetMul(); endCharge();
    // Foot faults: must be behind baseline & in correct lateral box
    const margin=0.25, sign=state.serverBoxSign;
    const behindOK = (player.y >= halfL-0.35-eps);
    const inBox = (player.x >= (sign>0? 0.0-eps: -halfW+margin)) && (player.x <= (sign>0? halfW-margin: 0.0+eps));
    if(!(behindOK && inBox)){ flashMsg("Foot fault on serve", true); pointTo(-1); return; }
    if(state.waitingServe && state.serving>0) launchServe(+1, mul);
  }
  function endChargeGetMul(){ const held=Math.min(cfg.chargeMax, nowTime()-charge.t0); return cfg.chargeMinMul + (cfg.chargeMaxMul - cfg.chargeMinMul)*(held/cfg.chargeMax); }
  function endCharge(){ Object.assign(charge,{active:false,type:null,key:null,t0:0,val:0}); }

  // Perform shot (real volley logic + per-shot caps)
  function performShot(p, side, type, spinTB, sideSpin, powerMul=1.0){
    const isVolley = !ball.bouncedSinceHit; // volley = no bounce since last hit
    const inKitchen = (Math.abs(p.y) < cfg.kitchen + 0.001); // line counts
    if(isVolley && inKitchen){ pointTo(-side); flashMsg("Kitchen volley fault", true); return; }
    if(isVolley && state.rallyPhase!=='open'){ pointTo(-side); flashMsg("Volley before two bounces", true); return; }

    // target with assist
    const rawTX=(Math.random()*halfW*1.3 - halfW*0.65), rawTY=-side*(halfL - 1.2);
    const [tx,ty]=clampToOpponent(rawTX, rawTY, side);

    // per-shot caps (prevent turbo dinks)
    let speed=7.0, zVel=1.4, maxS=8.8;
    if(type==='drive'){ speed=8.4; zVel=1.05; maxS=9.2; }
    else if(type==='dink'){ speed=4.0; zVel=0.7; maxS=4.8; }
    else if(type==='lob'){ speed=6.6; zVel=2.05; maxS=7.4; spinTB = -Math.abs(spinTB)||-0.4; }
    else if(type==='drop'){ speed=6.2; zVel=1.45; maxS=7.0; spinTB = Math.max(spinTB, +0.35); }

    const sp = Math.min(speed*powerMul, maxS);
    const v = aimTo(ball.x, ball.y, tx, ty, zVel*Math.sqrt(powerMul), sp);

    // small error cone (AI wider)
    const err=(side>0)? 0.04 : 0.07, ang=(Math.random()*2-1)*err, cs=Math.cos(ang), sn=Math.sin(ang);
    const vx=v.vx*cs - v.vy*sn, vy=v.vx*sn + v.vy*cs;

    ball.vx=vx; ball.vy=vy; ball.vz=v.vz;
    ball.spinTB=clamp(spinTB,-1,1); ball.sideSpin=clamp(sideSpin,-1,1);
    ball.bouncedSinceHit=false; // will be volley until next bounce
    audio.hit(0.95);
    if(side>0) player.lastHitTime=nowTime(); else ai.lastHitTime=nowTime();
  }

  // Ball update + rules
  function updateBall(dt){
    // Serve preview
    if(state.waitingServe){
      const s=(state.serving>0)? player: ai;
      ball.x=s.x; ball.y=s.y + (state.serving>0? -0.5: +0.5); ball.z=1.0;
      return;
    }
    if(!ball.alive) return;

    // drag & gravity
    const df=Math.exp(-cfg.drag*dt);
    ball.vx*=df; ball.vy*=df; ball.vz=(ball.vz - cfg.g*dt)*df;
    // spin
    ball.vz += (-cfg.spinZ*ball.spinTB)*dt;
    ball.vx += (cfg.sideSpinK*ball.sideSpin)*dt;
    // wobble
    ball.wobblePhase += cfg.wobbleFreq*dt;
    const speedXY=Math.hypot(ball.vx,ball.vy);
    const wobA=(cfg.wobbleAmpDeg*Math.PI/180)*Math.min(1, speedXY/9.0);
    const c1=Math.cos(ball.wobblePhase)*wobA, s1=Math.sin(ball.wobblePhase)*wobA*0.7;
    let vx=ball.vx, vy=ball.vy;
    const cA=Math.cos(c1), sA=Math.sin(c1); let nvx=vx*cA - vy*sA, nvy=vx*sA + vy*cA;
    const cB=Math.cos(s1), sB=Math.sin(s1); nvx=nvx*cB - nvy*sB; nvy=nvx*sB + nvy*cB;
    ball.vx=nvx; ball.vy=nvy;

    // integrate
    ball.x += ball.vx*dt; ball.y += ball.vy*dt; ball.z += ball.vz*dt;

    // net clip
    if( (ball.y - ball.vy*dt) * ball.y <= 0 ){
      const denom = Math.abs(ball.vy)||1e-6;
      const zAt = ball.z - ball.vz*dt * (Math.abs(ball.y)/denom);
      if(zAt <= cfg.netH + 0.03 && Math.abs(ball.x) < halfW*0.55){
        ball.y = (ball.vy>0? 0.02 : -0.02);
        ball.vy *= -0.35; ball.vx *= 0.85; ball.vz *= 0.7; audio.bounce(0.8);
      }
    }

    // ground bounce
    if(ball.z <= 0){
      ball.z=0; audio.bounce(0.9);
      ball.vz = Math.abs(ball.vz)*0.52;
      const skid=clamp(1 - 0.22*ball.spinTB, 0.75, 1.2);
      ball.vx *= 0.9*skid; ball.vy *= 0.9*skid;
      ball.vx += (Math.random()*2-1)*0.09; ball.vy += (Math.random()*2-1)*0.09;

      ball.bouncedSinceHit = true;

      // Two-bounce state machine
      const side = (ball.y>0)? +1 : -1; // +1 player half
      if(state.rallyPhase==='serve'){
        // Must land: receiver side, correct diagonal (x sign), and beyond NVZ (line = fault)
        const correctX = (Math.sign(ball.x||0.0001) === state.serverBoxSign);
        const beyondNVZ = (Math.abs(ball.y) > cfg.kitchen + eps);
        const landedReceiver = (side === -state.serving);
        if(!(landedReceiver && correctX && beyondNVZ)){ flashMsg("Fault on serve", true); pointTo(-state.serving); return; }
        state.rallyPhase='return';
      } else if(state.rallyPhase==='return'){
        if(side === state.serving) state.rallyPhase='open';
      }

      // Out after bounce (lines are IN; NVZ line on serve handled above)
      const outX = Math.abs(ball.x) > halfW+0.001;
      const outY = Math.abs(ball.y) > halfL+0.001;
      if(outX || outY){ pointTo( (side>0)? -1 : +1 ); return; }
    }

    // way long/wide in air
    if(Math.abs(ball.x) > halfW+0.9 || Math.abs(ball.y) > halfL+0.9 || ball.z>6){
      pointTo( (ball.y>0)? -1 : +1 ); return;
    }
  }

  // Prediction
  function predictLanding(h=1.4){
    if(!ball.alive) return null;
    let x=ball.x,y=ball.y,z=ball.z,vx=ball.vx,vy=ball.vy,vz=ball.vz,t=0,dt=0.02;
    while(t<h){
      const df=Math.exp(-cfg.drag*dt);
      vx*=df; vy*=df; vz=(vz - cfg.g*dt)*df;
      vz += (-cfg.spinZ*ball.spinTB)*dt;
      vx += (cfg.sideSpinK*ball.sideSpin)*dt;
      x+=vx*dt; y+=vy*dt; z+=vz*dt; t+=dt;
      if(z<=0) return {x,y,t};
    }
    return null;
  }

  // Scoring
  function pointTo(side){
    ball.alive=false; state.rally=false;
    const server=state.serving, hitter=side;
    if(hitter===server){ if(side>0) state.pScore++; else state.aScore++; audio.hit2(0.9); }
    else { state.serving *= -1; }
    updateScoreUI();
    if(checkWin()) return;
    setTimeout(()=> setupServe(state.serving), 500);
  }
  function checkWin(){
    const p=state.pScore,a=state.aScore,lead=Math.abs(p-a);
    if((p>=cfg.serveToWin||a>=cfg.serveToWin) && lead>=2){
      flashMsg((p>a?"You win!":"AI wins!")+" — P to restart", true);
      state.paused=true; ui.paused.classList.add('show'); return true;
    }
    return false;
  }
  function updateScoreUI(){
    ui.pScore.textContent=state.pScore; ui.aScore.textContent=state.aScore;
    ui.serve.textContent=(state.serving>0?"Your serve":"AI serve")+` (${currentServerScore()%2===0? "Right":"Left"})`;
    ui.call.textContent=`(${state.pScore}–${state.aScore})`;
  }

  // Render
  function draw(){
    ctx.clearRect(0,0,W,H);
    drawCourt(); drawNet(); drawServiceBoxes();
    drawShadow(ball);
    drawPlayer(ai,false); drawPlayer(player,true);
    if(state.waitingServe || ball.alive) drawBall(ball);
    drawChargeMeter();
  }
  function drawCourt(){
    const corners=[[-halfW,-halfL],[halfW,-halfL],[halfW,halfL],[-halfW,halfL]];
    ctx.beginPath(); corners.forEach(([x,y],i)=>{const [sx,sy]=iso.toScreen(x,y,0); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);});
    ctx.closePath(); ctx.fillStyle='rgba(26,36,86,0.95)'; ctx.fill();
    // kitchen bands
    drawBand(-cfg.kitchen,0,'rgba(44,51,87,0.95)'); drawBand(0,cfg.kitchen,'rgba(44,51,87,0.95)');
    // outer lines
    ctx.strokeStyle='rgba(248,250,252,0.9)'; ctx.lineWidth=2; ctx.beginPath();
    corners.forEach(([x,y],i)=>{const [sx,sy]=iso.toScreen(x,y,0); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);});
    ctx.closePath(); ctx.stroke();
    // net plane line
    const [sx1,sy1]=iso.toScreen(-halfW,0,0), [sx2,sy2]=iso.toScreen(halfW,0,0);
    ctx.strokeStyle='rgba(203,213,225,0.4)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(sx1,sy1); ctx.lineTo(sx2,sy2); ctx.stroke();
    // centerline (x=0) to hint boxes
    const [cx1,cy1]=iso.toScreen(0,-halfL,0), [cx2,cy2]=iso.toScreen(0,halfL,0);
    ctx.strokeStyle='rgba(203,213,225,0.2)'; ctx.beginPath(); ctx.moveTo(cx1,cy1); ctx.lineTo(cx2,cy2); ctx.stroke();
  }
  function drawBand(y1,y2,color){
    const pts=[[-halfW,y1],[halfW,y1],[halfW,y2],[-halfW,y2]];
    ctx.beginPath(); pts.forEach(([x,y],i)=>{const [sx,sy]=iso.toScreen(x,y,0); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);}); ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  }
  function drawNet(){
    const [lx,ly]=iso.toScreen(-halfW,0,cfg.netH), [rx,ry]=iso.toScreen(halfW,0,cfg.netH);
    ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(lx,ly); ctx.lineTo(rx,ry); ctx.stroke();
    const postZ=cfg.netH+0.4; [[-halfW,0],[halfW,0]].forEach(([x,y])=>{const [sx,sy]=iso.toScreen(x,y,0), [sx2,sy2]=iso.toScreen(x,y,postZ); ctx.strokeStyle='rgba(148,163,184,0.8)'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx2,sy2); ctx.stroke();});
  }
  function drawServiceBoxes(){
    if(!state.waitingServe) return;
    const sign=state.serverBoxSign;
    const bx=(sign>0)? [0,halfW]: [-halfW,0];
    const byTop=-halfL, byBot=-(cfg.kitchen);
    ctx.save(); ctx.globalAlpha=0.12; ctx.fillStyle='#22c55e';
    const poly=[[bx[0],byTop],[bx[1],byTop],[bx[1],byBot],[bx[0],byBot]];
    ctx.beginPath(); poly.forEach(([x,y],i)=>{const [sx,sy]=iso.toScreen(x,y,0); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);}); ctx.closePath(); ctx.fill(); ctx.restore();
  }
  function drawPlayer(p,isHuman){
    const [sx,sy]=iso.toScreen(p.x,p.y,0);
    ctx.save(); ctx.translate(sx,sy); ctx.fillStyle=isHuman? '#86efac' : '#60a5fa';
    const s=cfg.pixelScale; ctx.fillRect(-4*s,-14*s,8*s,8*s); ctx.fillRect(-5*s,-6*s,10*s,12*s);
    ctx.fillStyle='#fef08a'; ctx.fillRect(5*s,-8*s,6*s,3*s); ctx.restore();
    if(isHuman){
      ctx.save(); ctx.globalAlpha=0.8; const [bx,by]=iso.toScreen(p.x,p.y,0);
      ctx.fillStyle='rgba(11,18,41,.7)'; ctx.fillRect(bx-30,by-60,60,6);
      ctx.fillStyle='#86efac'; ctx.fillRect(bx-30,by-60,60*(p.stamina/cfg.staminaMax),6); ctx.restore();
    }
  }
  function drawShadow(b){
    const show=state.waitingServe || b.alive; if(!show) return;
    const [sx,sy]=iso.toScreen(b.x,b.y,0); const size=clamp(6 - b.z*1.8,1.5,6);
    ctx.save(); ctx.globalAlpha=0.35; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(sx,sy,size*1.2,size*0.8,0,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
  function drawBall(b){
    const [sx,sy]=iso.toScreen(b.x,b.y,b.z);
    ctx.save();
    if(b.alive){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx - b.vx*5, sy - b.vy*3 - b.vz*2); ctx.stroke(); }
    ctx.fillStyle='#f8fafc'; ctx.beginPath(); ctx.arc(sx,sy,5,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(253,224,71,0.6)'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  function drawChargeMeter(){
    if(!charge.active) return;
    const held=Math.min(cfg.chargeMax, nowTime()-charge.t0);
    const t=held/cfg.chargeMax;
    const mul=cfg.chargeMinMul + (cfg.chargeMaxMul - cfg.chargeMinMul)*t;
    if(charge.type==='serve'){
      const w=220,h=10,x=W/2 - w/2,y=H-36;
      ctx.save(); ctx.fillStyle='rgba(11,18,41,.8)'; ctx.fillRect(x,y,w,h);
      ctx.fillStyle='#86efac'; ctx.fillRect(x,y,w*t,h);
      ctx.fillStyle='rgba(230,237,243,.8)'; ctx.fillText(`Serve Power ×${mul.toFixed(2)}`, x, y-6); ctx.restore();
    } else if(charge.type==='shot'){
      const [sx,sy]=iso.toScreen(player.x,player.y,0); const w=120,h=8,x=sx-w/2,y=sy-72;
      ctx.save(); ctx.fillStyle='rgba(11,18,41,.8)'; ctx.fillRect(x,y,w,h);
      ctx.fillStyle='#86efac'; ctx.fillRect(x,y,w*t,h); ctx.restore();
    }
  }

  // Helpers
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function sq(v){ return v*v; }
  function nowTime(){ return performance.now()/1000; }
  function approach(v,target,delta){ return (v<target)? Math.min(target, v+delta) : Math.max(target, v-delta); }
  function vecNorm(x,y){ const m=Math.hypot(x,y)||1; return {x:x/m, y:y/m}; }
  function clampToOpponent(x,y,side){
    const mx=halfW*(1-cfg.aimAssist), my=(halfL-0.8)*(1-cfg.aimAssist);
    const tx=clamp(x,-mx,mx);
    const ty=(side>0)? -Math.max(1.2, Math.min(my, Math.abs(y))) : Math.max(-my, Math.min(-1.2, y));
    return [tx,ty];
  }
  function aimTo(sx,sy,tx,ty,zVel,speed){
    const dx=tx-sx, dy=ty-sy, d=Math.hypot(dx,dy)||1; return {vx:(dx/d)*speed, vy:(dy/d)*speed, vz:zVel};
  }
  function steerTo(p,tx,ty,dt){
    const dashMul=(p.dashT>0)? cfg.dashBoost:1.0;
    const wantV = vecNorm(tx-p.x, ty-p.y);
    const max = p.speed*dashMul;
    const vx = wantV.x*max, vy=wantV.y*max;
    p.vx = approach(p.vx, vx, (Math.sign(vx-p.vx)>=0? cfg.accel: cfg.decel)*dt);
    p.vy = approach(p.vy, vy, (Math.sign(vy-p.vy)>=0? cfg.accel: cfg.decel)*dt);
    p.x += p.vx*dt; p.y += p.vy*dt;
    if(p===ai){ p.x=clamp(p.x,-halfW+0.4,halfW-0.4); p.y=clamp(p.y,-halfL+0.6,-0.7); }
  }

  // Loop
  let last=nowTime(), acc=0, dt=1/60;
  function frame(){ const now=nowTime(); let d=now-last; last=now; d=Math.min(0.05,Math.max(0,d));
    if(!state.paused){ acc+=d; while(acc>=dt){ tick(dt); acc-=dt; } draw(); } requestAnimationFrame(frame); }
  function tick(dtl){
    handlePlayer(dtl);
    aiBrain.decide(dtl);
    updateBall(dtl);

    // message timer
    if(state.msgT>0 && state.msgT<999){ state.msgT -= dtl; if(state.msgT<=0) ui.msg.textContent=''; }

    // clamp halves
    player.x=clamp(player.x,-halfW+0.4,halfW-0.4); player.y=clamp(player.y,0.7,halfL-0.6);
    ai.x=clamp(ai.x,-halfW+0.4,halfW-0.4); ai.y=clamp(ai.y,-halfL+0.6,-0.7);
  }

  // UI
  function flashMsg(t,sticky=false){ ui.msg.textContent=t; state.msgT=sticky?999:3; }
  function togglePause(){ state.paused=!state.paused; ui.paused.classList.toggle('show', state.paused); if(!state.paused) audio.resume?.(); }
  window.togglePause=togglePause;

  // Boot
  updateScoreUI(); flashMsg("Hold SPACE to charge your first serve. WASD to move, J/K/L/I to shoot.");
  setupServe(+1);
  frame();
})();
</script>
</body>
</html>
