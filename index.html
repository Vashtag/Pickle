<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>PicklePop — FP Arcade Pickleball (v0.1)</title>
<style>
  html,body{margin:0;height:100%;background:#0a0f17;overscroll-behavior:none}
  canvas{display:block}
  #hud{
    position:fixed;inset:12px auto auto 12px;color:#e8f0ff;font:600 14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
    background:rgba(10,15,23,.5);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;
    box-shadow:0 6px 20px rgba(0,0,0,.35);pointer-events:none;user-select:none
  }
  #hud .big{font-size:18px}
  #hud .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.08);margin-left:6px}
  #centerMsg{
    position:fixed;left:50%;top:10px;transform:translateX(-50%);font:700 20px/1 ui-sans-serif,system-ui;
    color:#f5f9ff;background:rgba(14,22,32,.6);backdrop-filter:blur(8px);padding:10px 14px;border-radius:12px;opacity:.95
  }
  #help{
    position:fixed;right:12px;bottom:12px;color:#b9c7e6;font:500 12px/1.4 ui-sans-serif,system-ui;
    background:rgba(10,15,23,.55);backdrop-filter:blur(6px);padding:10px 12px;border-radius:12px;max-width:min(42ch,45vw)
  }
  #fault{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    font:800 28px/1 ui-sans-serif;letter-spacing:.5px;color:#fff;padding:16px 18px;border-radius:14px;
    background:linear-gradient(180deg, rgba(255,60,60,.92), rgba(180,0,0,.9));box-shadow:0 20px 50px rgba(0,0,0,.5);
    display:none
  }
  #lock{
    position:fixed;inset:0;background:radial-gradient(1200px 600px at 50% 30%, rgba(255,255,255,.07), transparent 70%) #0a0f17;
    display:flex;align-items:center;justify-content:center;flex-direction:column;gap:16px;color:#e8f0ff;text-align:center
  }
  #lock button{
    font:700 14px ui-sans-serif,system-ui;padding:10px 14px;border-radius:12px;border:0;cursor:pointer;
    background:#59a4ff;color:#071525;box-shadow:0 6px 18px rgba(0,0,0,.45)
  }
  #nvzHint{
    position:fixed;left:50%;bottom:70px;transform:translateX(-50%);
    color:#fff;font:700 14px ui-sans-serif;background:rgba(255,45,45,.85);padding:8px 10px;border-radius:10px;display:none
  }
</style>
</head>
<body>
<div id="hud">
  <div class="big">Score: <span id="pScore">0</span> – <span id="aiScore">0</span> <span class="pill" id="serverPill">Serve: You</span></div>
  <div>Side: <span id="sidePill">Right</span> • To 11 (win by 2) • Aim-assist ON</div>
  <div id="lastMsg" style="opacity:.9;margin-top:6px"></div>
</div>
<div id="centerMsg">Click to Lock Cursor</div>
<div id="help">
  <b>Controls</b>: WASD move, Shift sprint, Ctrl crouch/reach, <b>Space (hold)</b> serve, <b>Left-click</b> hit, Q/E paddle tilt, Esc unlock.<br/>
  <b>Rules</b>: Singles, 11 to win (by 2). Kitchen (NVZ) volley faults enforced. Diagonal serve must land in service box. No wind.
</div>
<div id="fault">FAULT</div>
<div id="nvzHint">NVZ VOLLEY = FAULT</div>
<div id="lock">
  <div style="font:800 28px/1 ui-sans-serif;">PicklePop</div>
  <div style="opacity:.9;max-width:60ch">Click "Play" to lock the cursor. Then press <b>Space</b> to serve. Beat the AI to 11.</div>
  <button id="playBtn">Play</button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

//
// --------- Basic constants and helpers ----------
const COURT_W = 6.10;           // meters (X)
const COURT_L = 13.41;          // meters (Z)
const HALF_W = COURT_W * 0.5;   // 3.05 m
const HALF_L = COURT_L * 0.5;   // 6.705 m
const NVZ = 2.13;               // Non-volley zone distance from net
const NET_H_CENTER = 0.86;
const NET_H_SIDELINE = 0.914;
const BALL_RADIUS = 0.037;      // ~74mm diameter
const GRAVITY = new THREE.Vector3(0,-9.81,0);
const DRAG_K = 0.9;             // tuned for "wiffle" feel (Cd scaled-ish)
const MAGNUS_K = 0.0006;        // lift/curve coefficient (arcade)
const SERVE_MIN = 0.4, SERVE_MAX = 1.0; // hold time bounds
const DT_FIXED = 1/120;

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function netHeightAtX(x){
  const t = clamp(Math.abs(x)/HALF_W, 0, 1);
  // smoothstep from center to sideline height
  const s = t*t*(3-2*t);
  return lerp(NET_H_CENTER, NET_H_SIDELINE, s);
}
function vec3(x=0,y=0,z=0){ return new THREE.Vector3(x,y,z); }

//
// --------- Scene setup ----------
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0f17, 0.04);

// Sky gradient
{
  const skyGeo = new THREE.SphereGeometry(100, 32, 16);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      top: {value: new THREE.Color(0x20324f)},
      mid: {value: new THREE.Color(0x2a466f)},
      bot: {value: new THREE.Color(0x132237)}
    },
    vertexShader: `
      varying vec3 vPos;
      void main(){
        vPos = position;
        gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 top; uniform vec3 mid; uniform vec3 bot;
      varying vec3 vPos;
      void main(){
        float h = normalize(vPos).y*0.5+0.5;
        vec3 c = mix(bot, mid, smoothstep(0.2,0.7,h));
        c = mix(c, top, smoothstep(0.7,1.0,h));
        gl_FragColor = vec4(c,1.0);
      }
    `
  });
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);
}

// Lights
{
  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(-2, 6, -3);
  sun.castShadow = false;
  scene.add(sun);
  scene.add(new THREE.AmbientLight(0xbfd7ff, 0.35));
}

// Camera & first-person rig
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.05, 200);
const player = {
  pos: vec3(0, 1.7, -HALF_L+0.8),
  vel: vec3(),
  yaw: 0, pitch: 0,
  speed: 5.5, sprint: 8.0,
  crouch: 0, // 0..1
  paddleTilt: 0, // radians, +/- ~12°
  canHitCooldown: 0,
};
camera.position.copy(player.pos);

// Simple pointer lock
let pointerLocked = false;
const lockUI = document.getElementById('lock');
const playBtn = document.getElementById('playBtn');
playBtn.onclick = () => {
  renderer.domElement.requestPointerLock();
};
document.addEventListener('pointerlockchange', ()=>{
  pointerLocked = (document.pointerLockElement === renderer.domElement);
  lockUI.style.display = pointerLocked ? 'none' : 'flex';
  document.getElementById('centerMsg').style.display = pointerLocked ? 'none' : '';
});
renderer.domElement.addEventListener('click', ()=>{
  if(!pointerLocked) renderer.domElement.requestPointerLock();
});
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Input
const keys = new Set();
addEventListener('keydown', e => { keys.add(e.code); if(e.code==='Tab'){ e.preventDefault(); }});
addEventListener('keyup', e => keys.delete(e.code));
addEventListener('mousemove', e=>{
  if(!pointerLocked) return;
  player.yaw   -= e.movementX*0.0025;
  player.pitch -= e.movementY*0.0020;
  player.pitch = clamp(player.pitch, -1.1, 1.1);
});
addEventListener('mousedown', e=>{
  if(e.button===0){ tryHit(); }
});
addEventListener('wheel', e=>{
  // optional: nothing; (keeping for future sensitivity)
});
function getMoveDir(){
  const dir = vec3();
  const forward = vec3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const right   = vec3(-forward.z, 0, forward.x);
  if(keys.has('KeyW')) dir.add(forward);
  if(keys.has('KeyS')) dir.sub(forward);
  if(keys.has('KeyA')) dir.sub(right);
  if(keys.has('KeyD')) dir.add(right);
  if(dir.lengthSq()>0) dir.normalize();
  return dir;
}

// Paddle (simple box attached to camera)
const paddle = new THREE.Mesh(
  new THREE.BoxGeometry(0.22, 0.32, 0.02),
  new THREE.MeshStandardMaterial({color:0x2b5fff, roughness:0.6, metalness:0.05})
);
paddle.castShadow = false; paddle.receiveShadow = false;
scene.add(paddle);

// Court visuals (low-poly outdoor)
function makeCourt(){
  const g = new THREE.Group();
  // Ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(60, 60, 1, 1),
    new THREE.MeshStandardMaterial({color:0x264b3f, roughness:1})
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = 0;
  g.add(ground);

  // Court surface
  const courtMat = new THREE.MeshStandardMaterial({color:0x1d7fb5, roughness:0.8});
  const court = new THREE.Mesh(new THREE.PlaneGeometry(COURT_W, COURT_L), courtMat);
  court.rotation.x = -Math.PI/2;
  court.position.y = 0.001;
  g.add(court);

  // Lines
  const lineMat = new THREE.MeshBasicMaterial({color:0xffffff});
  const lineH = 0.003;
  function addLine(x, z, w, l){
    const m = new THREE.Mesh(new THREE.PlaneGeometry(w, l), lineMat);
    m.rotation.x = -Math.PI/2; m.position.set(x, lineH, z);
    g.add(m);
  }
  // Baselines
  addLine(0, -HALF_L, COURT_W, 0.05);
  addLine(0,  HALF_L, COURT_W, 0.05);
  // Sidelines
  addLine(-HALF_W, 0, 0.05, COURT_L);
  addLine( HALF_W, 0, 0.05, COURT_L);
  // Centerline (service)
  addLine(0, 0, 0.04, COURT_L/2 - NVZ);
  addLine(0, 0, 0.04, -(COURT_L/2 - NVZ));
  // Kitchen lines
  addLine(0,  NVZ, COURT_W, 0.04);
  addLine(0, -NVZ, COURT_W, 0.04);

  // Net posts + top tape
  const postGeo = new THREE.CylinderGeometry(0.05,0.05,1.2,8);
  const postMat = new THREE.MeshStandardMaterial({color:0x222a33, metalness:.2, roughness:.6});
  const postL = new THREE.Mesh(postGeo, postMat);
  const postR = postL.clone();
  postL.position.set(-HALF_W-0.05, NET_H_SIDELINE/2, 0);
  postR.position.set( HALF_W+0.05, NET_H_SIDELINE/2, 0);
  g.add(postL, postR);

  // Net (visual; physical handled in code)
  const net = new THREE.Mesh(
    new THREE.PlaneGeometry(COURT_W, NET_H_SIDELINE*1.3, 16, 4),
    new THREE.MeshBasicMaterial({color:0x2a2f36, wireframe:true, transparent:true, opacity:0.5})
  );
  net.rotation.y = Math.PI/2;
  net.position.set(0, NET_H_CENTER*0.8, 0);
  g.add(net);

  // Fence + trees (simple low-poly props)
  const fenceMat = new THREE.LineBasicMaterial({color:0x6fa0c8, transparent:true, opacity:0.35});
  for(let i=-3;i<=3;i++){
    const z = i*4.5;
    const pts = [new THREE.Vector3(-HALF_W-2,1.2,z), new THREE.Vector3(HALF_W+2,1.2,z)];
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const line = new THREE.Line(geo, fenceMat); g.add(line);
  }
  const treeMat = new THREE.MeshStandardMaterial({color:0x2f6b3a, roughness:1});
  const trunkMat= new THREE.MeshStandardMaterial({color:0x915c2a, roughness:1});
  function addTree(x,z){
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.07,0.8,6), trunkMat);
    trunk.position.set(x,0.4,z);
    const crown = new THREE.Mesh(new THREE.ConeGeometry(0.6,1.2,6), treeMat);
    crown.position.set(x,1.4,z);
    g.add(trunk,crown);
  }
  for(let i=0;i<10;i++){
    addTree( (Math.random()<.5?-1:1)*(HALF_W+2+Math.random()*4), (Math.random()*2-1)*(HALF_L+2+Math.random()*6) );
  }

  scene.add(g);
}
makeCourt();

// HUD refs
const pScoreEl = document.getElementById('pScore');
const aiScoreEl = document.getElementById('aiScore');
const serverPill = document.getElementById('serverPill');
const sidePill = document.getElementById('sidePill');
const lastMsg = document.getElementById('lastMsg');
const faultUI = document.getElementById('fault');
const nvzHint = document.getElementById('nvzHint');

// Ball state
const ballMesh = new THREE.Mesh(
  new THREE.SphereGeometry(BALL_RADIUS, 16, 12),
  new THREE.MeshStandardMaterial({color:0xffee88, roughness:0.5, metalness:0.0})
);
ballMesh.castShadow=false; ballMesh.receiveShadow=false;
scene.add(ballMesh);
const ball = {
  pos: vec3(0,1.2,-HALF_L+0.5),
  vel: vec3(),
  omega: vec3(),      // spin (rad/s)
  lastZ: -HALF_L+0.5,
  bouncesSinceServe: 0,
  lastHitter: 'none', // 'player' or 'ai'
  inPlay: false,
  serving: 'player', // 'player' or 'ai'
  serveSide: 'right', // 'left' or 'right' (from server's perspective)
  awaitingServe: true,
  rallyOver: false,
};

// Aim-assist dots
const dots = [];
function setupDots(n=7){
  for(let i=0;i<n;i++){
    const m = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.8}));
    m.visible = false; scene.add(m); dots.push(m);
  }
}
setupDots();

// Scores
const score = { player:0, ai:0 };
function updateHUD(){
  pScoreEl.textContent = score.player.toString();
  aiScoreEl.textContent = score.ai.toString();
  serverPill.textContent = `Serve: ${ball.serving==='player'?'You':'AI'}`;
  sidePill.textContent   = ball.serveSide==='right'?'Right':'Left';
}
updateHUD();

function resetForServe(serving){
  ball.serving = serving;
  ball.awaitingServe = true;
  ball.inPlay = false;
  ball.rallyOver = false;
  ball.bouncesSinceServe = 0;
  ball.vel.set(0,0,0); ball.omega.set(0,0,0);
  // Server side based on server's points parity (singles convention)
  const s = (serving==='player'?score.player:score.ai) % 2 === 0 ? 'right' : 'left';
  ball.serveSide = s;
  updateHUD();
  // Place player/AI
  if(serving==='player'){
    player.pos.set( (s==='right'? 1.0:-1.0), 1.7, -HALF_L+1.2 );
    camera.position.copy(player.pos);
    ai.pos.set(0,1.7, HALF_L-1.6);
  }else{
    player.pos.set(0,1.7, -HALF_L+1.6);
    camera.position.copy(player.pos);
    ai.pos.set( (s==='right'?-1.0:1.0),1.7, HALF_L-1.2 );
  }
  // Ball near server
  const bx = (serving==='player') ? (s==='right'? 1.0:-1.0) : (s==='right'?-1.0:1.0);
  const bz = (serving==='player') ? (player.pos.z+0.4) : (ai.pos.z-0.4);
  ball.pos.set(bx, 1.0, bz);
  ballMesh.position.copy(ball.pos);
  lastMsg.textContent = `${serving==='player'?'Your':'AI'} serve — ${s} side`;
}
resetForServe('player');

// AI (very simple but reliable)
const ai = {
  pos: vec3(0,1.7, HALF_L-1.6),
  speed: 5.0,
  paddleTilt: 0,
  cool: 0,
};
function aiUpdate(dt){
  // target positioning
  let targetX = clamp(ball.pos.x, -HALF_W+0.4, HALF_W-0.4);
  // stay near NVZ when ball is short, back off when deep
  const baseZ = HALF_L - (ball.pos.z>HALF_L*0.5 ? 1.8 : 2.4);
  let targetZ = baseZ;
  // Move
  const to = vec3(targetX-ai.pos.x, 0, targetZ-ai.pos.z);
  const d = to.length(); if(d>0.001){ to.normalize(); const v = ai.speed*dt; const k = Math.min(1, v/d); ai.pos.addScaledVector(to,k*d); }
  // Clamp to AI half
  ai.pos.x = clamp(ai.pos.x, -HALF_W+0.35, HALF_W-0.35);
  ai.pos.z = clamp(ai.pos.z, 0.2, HALF_L-0.4);

  // decide to hit
  ai.cool-=dt;
  const reach = 0.9;
  const dist = ai.pos.clone().add(vec3(0,-0.4, -0.3)).distanceTo(ball.pos);
  const onAISide = ball.pos.z>0;
  if(ball.inPlay && onAISide && ai.cool<=0 && dist<reach){
    // choose target cross-court-ish
    const targetX = ball.pos.x>0 ? -1.2 : 1.2;
    const targetZ = -HALF_L+1.8; // toward player side
    const dir = vec3(targetX - ball.pos.x, 0.9 - ball.pos.y, targetZ - ball.pos.z).normalize();
    // power based on ball height
    const speed = THREE.MathUtils.clamp(8 + (ball.pos.y-0.5)*4, 6, 11);
    ball.vel.copy(dir.multiplyScalar(speed));
    // spin bias
    const sideSpin = (targetX>0? -1:1) * 25;
    ball.omega.set(0, sideSpin, 55); // top + some sidespin
    ball.lastHitter='ai';
    ai.cool = 0.20;
  }
}

// Movement + paddle transform
function updatePlayer(dt){
  // crouch/reach
  const targetC = keys.has('ControlLeft') ? 1 : 0;
  player.crouch += (targetC - player.crouch)*Math.min(1, dt*12);

  const move = getMoveDir();
  const spd = keys.has('ShiftLeft') ? player.sprint : player.speed;
  player.pos.addScaledVector(move, spd*dt);

  // stay on near half
  player.pos.x = clamp(player.pos.x, -HALF_W+0.35, HALF_W-0.35);
  player.pos.z = clamp(player.pos.z, -HALF_L+0.4, -0.2);

  // camera
  const eye = player.pos.clone();
  eye.y = 1.7 - player.crouch*0.5;
  camera.position.copy(eye);
  camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

  // paddle tilt Q/E
  if(keys.has('KeyQ')) player.paddleTilt += dt*0.7;
  if(keys.has('KeyE')) player.paddleTilt -= dt*0.7;
  player.paddleTilt = clamp(player.paddleTilt, -0.22, 0.22);

  // paddle position (right-hand, slightly forward)
  const fw = vec3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const rt = vec3(-fw.z, 0, fw.x);
  const up = vec3(0,1,0);
  const pOff = rt.clone().multiplyScalar(0.35).add(fw.clone().multiplyScalar(0.45)).add(up.clone().multiplyScalar(-0.15 - player.crouch*0.15));
  paddle.position.copy(eye.clone().add(pOff));
  // orient paddle to face forward with tilt
  const baseQuat = new THREE.Quaternion().setFromUnitVectors(vec3(0,0,1), fw.clone().normalize());
  const tiltQuat = new THREE.Quaternion().setFromAxisAngle(rt, player.paddleTilt);
  paddle.quaternion.copy(baseQuat.multiply(tiltQuat));
}

// Serve handling
let servingHold = 0;
addEventListener('keydown', e=>{
  if(e.code==='Space'){
    if(ball.awaitingServe && ball.serving==='player'){
      servingHold = 0.0001; // start
      lastMsg.textContent = 'Hold Space to set power; release to serve (diagonal)';
    }
  }
});
addEventListener('keyup', e=>{
  if(e.code==='Space'){
    if(ball.awaitingServe && ball.serving==='player' && servingHold>0){
      // Launch serve
      const t = clamp(servingHold, SERVE_MIN, SERVE_MAX);
      const pow = lerp(7, 18, (t-SERVE_MIN)/(SERVE_MAX-SERVE_MIN));
      // Aim toward diagonal box center from current side & side selection
      const toLeft  = (ball.serveSide==='left');
      const targetX = (toLeft?  1 : -1) * 1.1; // diagonal box center x
      const targetZ = HALF_L - NVZ - (COURT_L/4 - NVZ/2)*0.6; // mid of service box depth
      const dir = vec3(targetX - ball.pos.x, 0.6 - ball.pos.y, targetZ - ball.pos.z).normalize();
      // ensure underhand-ish: y component positive
      const serveDir = vec3(dir.x, Math.abs(dir.y), dir.z).normalize();
      ball.vel.copy(serveDir.multiplyScalar(pow));
      ball.omega.set(0, (toLeft?-1:1)*15, 70); // topspin + slight sidespin
      ball.awaitingServe = false;
      ball.inPlay = true;
      ball.lastHitter = 'player';
      lastMsg.textContent = '';
    }
    servingHold = 0;
  }
});

function updateServeHold(dt){
  if(ball.awaitingServe && ball.serving==='player' && servingHold>0){
    servingHold += dt;
    // Clamp
    if(servingHold > SERVE_MAX) servingHold = SERVE_MAX;
  }
}

// Predictive dots (aim-assist) — show when ball is within reach on your side
function updateDots(){
  const reach = 0.95;
  const fw = vec3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const rt = vec3(-fw.z, 0, fw.x);
  const eye = camera.position.clone();
  const pOff = rt.clone().multiplyScalar(0.35).add(fw.clone().multiplyScalar(0.45)).add(vec3(0,-0.15 - player.crouch*0.15,0));
  const paddlePos = eye.clone().add(pOff);

  const dist = paddlePos.distanceTo(ball.pos);
  const onPlayerSide = ball.pos.z < 0;
  const inReach = (dist < reach) && onPlayerSide;

  // If in reach and ball is descending or near, show dots
  const show = (ball.inPlay && inReach) || (ball.awaitingServe && ball.serving==='player');
  dots.forEach(d=>d.visible=false);
  if(!show) return;

  // hypothetical outgoing velocity from current orientation
  const tilt = player.paddleTilt;
  const dir = fw.clone();
  dir.y = Math.sin(tilt)*0.6 + ((ball.pos.y<1.0)?0.12:0.02);
  dir.normalize();
  const speed = ball.awaitingServe ? lerp(7,18,(servingHold||SERVE_MIN - SERVE_MIN)/(SERVE_MAX-SERVE_MIN)) : 9.5;
  const v0 = dir.multiplyScalar(speed);
  const w0 = vec3(0, tilt*120, 60); // topspin bias from tilt

  // Simulate ~0.6s ahead
  const p = ball.awaitingServe ? ball.pos.clone() : paddlePos.clone().lerp(ball.pos, 0.4);
  let v = v0.clone(), w = w0.clone();
  let pos = p.clone();
  let t = 0; const step = 0.1; // coarse
  for(let i=0;i<dots.length;i++){
    // integrate a few mini steps for smoother curve
    for(let k=0;k<3;k++){
      const speed = v.length();
      const drag = v.clone().multiplyScalar(-DRAG_K * speed * 0.04); // reduced for preview
      const magnus = w.clone().cross(v).multiplyScalar(MAGNUS_K);
      const a = GRAVITY.clone().add(drag).add(magnus);
      v.addScaledVector(a, step/3);
      pos.addScaledVector(v, step/3);
      if(pos.y < BALL_RADIUS) { v.y = Math.abs(v.y)*0.45; pos.y = BALL_RADIUS; v.multiplyScalar(0.87); }
    }
    dots[i].position.copy(pos);
    dots[i].visible = true;
    dots[i].material.opacity = 0.85 - i*0.12;
  }
}

// Hit attempt (player)
function tryHit(){
  if(!ball.inPlay) return;
  if(player.canHitCooldown>0) return;

  // Check reach
  const fw = vec3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw));
  const rt = vec3(-fw.z, 0, fw.x);
  const eye = camera.position.clone();
  const pOff = rt.clone().multiplyScalar(0.35).add(fw.clone().multiplyScalar(0.45)).add(vec3(0,-0.15 - player.crouch*0.15,0));
  const paddlePos = eye.clone().add(pOff);
  const dist = paddlePos.distanceTo(ball.pos);
  if(dist > 0.95) return;

  // Kitchen volley fault check (on player side, zero bounces since cross)
  const isVolley = (ball.groundBouncesSinceSide==='player'?0:ball.groundBouncesSinceSide)===0 && ball.pos.z<0;
  const inNVZ = (ball.pos.z > -NVZ && ball.pos.z < 0) || (paddlePos.z > -NVZ && paddlePos.z < 0);
  if(isVolley && inNVZ){
    fault('NVZ Volley Fault (You)', 'ai');
    return;
  }

  // Compute outgoing shot
  const tilt = player.paddleTilt;
  const dir = fw.clone();
  dir.y = Math.sin(tilt)*0.6 + ((ball.pos.y<1.0)?0.14:0.04);
  dir.normalize();
  const base = 9.5;
  const heightBonus = THREE.MathUtils.clamp((ball.pos.y-0.6)*2.5, -1.0, 2.5);
  const speed = clamp(base + heightBonus, 6.5, 12.5);

  ball.vel.copy(dir.multiplyScalar(speed));
  // spin: topspin + optional sidespin from Q/E tilt sign
  ball.omega.set(0, -tilt*120, 65);

  ball.lastHitter='player';
  player.canHitCooldown = 0.18;
}

// Physics integration & rules
ball.groundBouncesSinceSide = 0; // since the ball crossed to the current side (for NVZ logic)

function physicsStep(dt){
  if(ball.awaitingServe){
    // follow server (player or AI) gently
    if(ball.serving==='player'){
      // stick near player position
      ball.pos.x = THREE.MathUtils.lerp(ball.pos.x, player.pos.x + (ball.serveSide==='right'? 1.0:-1.0), 0.1);
      ball.pos.z = THREE.MathUtils.lerp(ball.pos.z, player.pos.z+0.4, 0.1);
      ball.pos.y = THREE.MathUtils.lerp(ball.pos.y, 1.0, 0.15);
      ballMesh.position.copy(ball.pos);
    }else{
      // AI serve (auto after a short "charge")
      aiServeTimer -= dt;
      if(aiServeTimer<=0){
        aiDoServe();
      }
    }
    return;
  }
  if(!ball.inPlay) return;

  // integrate
  const speed = ball.vel.length();
  const drag = ball.vel.clone().multiplyScalar(-DRAG_K * speed * dt);
  const magnus = ball.omega.clone().cross(ball.vel).multiplyScalar(MAGNUS_K*dt);
  ball.vel.add(GRAVITY.clone().multiplyScalar(dt)).add(drag).add(magnus);
  ball.pos.addScaledVector(ball.vel, dt);

  // ground bounce
  if(ball.pos.y < BALL_RADIUS && ball.vel.y < 0){
    ball.pos.y = BALL_RADIUS;
    ball.vel.y = -ball.vel.y * 0.45;           // COR
    ball.vel.x *= 0.85; ball.vel.z *= 0.85;    // frictional loss
    ball.omega.multiplyScalar(0.90);
    ball.bouncesSinceServe++;
    // Track bounces by side for NVZ logic
    if(ball.pos.z<0){
      ball.groundBouncesSinceSide = (ball.sideNow==='player')? (ball.groundBouncesSinceSide+1) : 1;
      ball.sideNow='player';
    }else{
      ball.groundBouncesSinceSide = (ball.sideNow==='ai')? (ball.groundBouncesSinceSide+1) : 1;
      ball.sideNow='ai';
    }

    // Serve validation: first bounce must be in diagonal service box on receiver side
    if(ball.bouncesSinceServe===1 && ball.lastHitter==='player'){
      if(!isInReceiverServiceBox('ai', ball.pos)){
        fault('Bad Serve (Out of service box)', 'ai'); return;
      }
    }
    if(ball.bouncesSinceServe===1 && ball.lastHitter==='ai'){
      if(!isInReceiverServiceBox('player', ball.pos)){
        fault('AI Bad Serve', 'player'); return;
      }
    }
  }

  // net check (crossing z=0)
  if((ball.lastZ<0 && ball.pos.z>=0) || (ball.lastZ>0 && ball.pos.z<=0)){
    const h = netHeightAtX(ball.pos.x) + BALL_RADIUS*0.75;
    if(ball.pos.y <= h){
      // net touch — rally over, fault to last hitter
      if(ball.lastHitter==='player') fault('Net (You)', 'ai');
      else fault('Net (AI)', 'player');
      return;
    }else{
      // crossed cleanly — reset side bounce counter
      ball.groundBouncesSinceSide = 0;
      ball.sideNow = (ball.pos.z>=0)?'ai':'player';
    }
  }
  ball.lastZ = ball.pos.z;

  // out of bounds when ball hits ground outside court
  if(ball.pos.y<=BALL_RADIUS+0.001){
    const outX = (Math.abs(ball.pos.x) > HALF_W + 0.01);
    const outZ = (Math.abs(ball.pos.z) > HALF_L + 0.01);
    if(outX || outZ){
      // assign point to opposite of last hitter
      const winner = ball.lastHitter==='player' ? 'ai' : 'player';
      fault(outX?'OUT (sideline)':'OUT (baseline)', winner);
      return;
    }
  }

  ballMesh.position.copy(ball.pos);
}

function isInReceiverServiceBox(receiver, p){
  // Receiver side: if server is player, receiver is ai (z>0). Service boxes are diagonal:
  // Box depth: from NVZ to baseline; width: half-court by centerline.
  const onFar = (receiver==='ai'); // z>0
  if(onFar && p.z < 0) return false;
  if(!onFar && p.z > 0) return false;

  const inDepth = Math.abs(p.z) >= NVZ-0.02 && Math.abs(p.z) <= HALF_L+0.05;
  // Which lateral half is correct depends on serveSide: if player served from right, must land in far left (x<0), etc.
  let mustLeft;
  if(ball.serving==='player'){
    mustLeft = (ball.serveSide==='right'); // right -> far left (x<0)
  }else{
    mustLeft = (ball.serveSide==='right') ? false : true; // AI perspective mirrored
  }
  const inHalf = mustLeft ? (p.x < 0) : (p.x > 0);
  return inDepth && inHalf && (Math.abs(p.x) <= HALF_W+0.03);
}

function fault(reason, pointTo){
  // End rally, award point or side-out per serve rule
  faultUI.textContent = 'FAULT — ' + reason;
  faultUI.style.display='block';
  setTimeout(()=>faultUI.style.display='none', 900);

  if(ball.serving === pointTo){
    // server wins rally -> point
    score[pointTo]++;
  }else{
    // receiver wins rally -> side-out (no point)
    ball.serving = pointTo;
  }
  updateHUD();

  // Win by 2 to 11
  if(score.player>=11 || score.ai>=11){
    if(Math.abs(score.player - score.ai)>=2){
      lastMsg.textContent = (score.player>score.ai?'You win!':'AI wins!')+' Refresh to play again.';
      ball.inPlay=false; ball.awaitingServe=false; return;
    }
  }

  resetForServe(ball.serving);
}

// AI serve
let aiServeTimer = 1.2;
function aiDoServe(){
  if(!(ball.awaitingServe && ball.serving==='ai')) return;
  // simple: choose diagonal, charge ~0.7s
  const hold = 0.7;
  const pow = lerp(7,18,(hold-SERVE_MIN)/(SERVE_MAX-SERVE_MIN));
  const toLeft = (ball.serveSide==='right'); // from AI POV
  const targetX = (toLeft? -1 : 1) * 1.1;
  const targetZ = -HALF_L + NVZ + 1.6;
  const dir = vec3(targetX - ball.pos.x, 0.6 - ball.pos.y, targetZ - ball.pos.z).normalize();
  const serveDir = vec3(dir.x, Math.abs(dir.y), dir.z).normalize();
  ball.vel.copy(serveDir.multiplyScalar(pow));
  ball.omega.set(0, (toLeft?1:-1)*15, 70);
  ball.awaitingServe=false; ball.inPlay=true; ball.lastHitter='ai';
  aiServeTimer = 1.2;
}

// NVZ hint
function updateNVZHint(){
  if(!ball.inPlay) { nvzHint.style.display='none'; return; }
  const onPlayerSide = ball.pos.z<0;
  const inNVZ = (player.pos.z>-NVZ && player.pos.z<0);
  // has ball bounced since crossing to player side?
  const wasVolley = ball.groundBouncesSinceSide===0 && onPlayerSide;
  const close = player.pos.distanceTo(ball.pos) < 1.2;
  const show = inNVZ && wasVolley && close;
  nvzHint.style.display = show ? 'block' : 'none';
}

// Main loop
let acc = 0;
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000); last = now;
  acc += dt;
  // update player and AI
  updatePlayer(dt);
  aiUpdate(dt);
  updateServeHold(dt);
  updateDots();
  updateNVZHint();

  // cooldown
  player.canHitCooldown = Math.max(0, player.canHitCooldown - dt);

  // fixed physics
  while(acc >= DT_FIXED){
    physicsStep(DT_FIXED);
    acc -= DT_FIXED;
  }

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Simple audio stubs (can wire real assets later)
// (kept minimal to avoid CORS/issues; feel free to add /audio/* and hook on contacts)

// Debug: keep paddle visible even if pointer not locked
if(!('onpointerlockchange' in document)){
  lockUI.style.display='none';
  document.getElementById('centerMsg').style.display='none';
}

</script>
</body>
</html>
