<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Dink City â€” Retro Pickleball Roguelike</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;background:#0a0a14;overflow:hidden;user-select:none;-webkit-user-select:none;font-family:'Courier New',monospace;color:#e6edf3}
  canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges}
  #wrap{position:fixed;inset:0;display:grid;place-items:center;background:#000}
  #scanlines{position:fixed;inset:0;pointer-events:none;z-index:10;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px)}
  #crt{position:fixed;inset:0;pointer-events:none;z-index:9;box-shadow:inset 0 0 80px rgba(0,0,0,0.5),inset 0 0 160px rgba(0,0,0,0.3);border-radius:8px}
</style>
</head>
<body>
<div id="wrap"><canvas id="c"></canvas></div>
<div id="scanlines"></div>
<div id="crt"></div>
<script>
// ============================================================
//  DINK CITY â€” Retro Side-View Pickleball Roguelike
// ============================================================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// --- Responsive sizing ---
let W, H, SCALE;
function resize() {
  const dpr = window.devicePixelRatio || 1;
  W = 800; H = 500;
  const aspect = W / H;
  let cw = window.innerWidth, ch = window.innerHeight;
  if (cw / ch > aspect) { cw = ch * aspect; } else { ch = cw / aspect; }
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.width = W;
  canvas.height = H;
  SCALE = cw / W;
}
window.addEventListener('resize', resize);
resize();

// --- Colors (retro palette) ---
const COL = {
  bg: '#0f1020',
  sky: '#1a1040',
  skyGrad1: '#0d0825',
  skyGrad2: '#1a1050',
  stars: '#ffffff',
  court: '#2a7a3a',
  courtDark: '#1e5c2a',
  courtLine: '#d8d8c0',
  net: '#ccccaa',
  netPole: '#888870',
  kitchen: '#1e5c2a',
  kitchenLine: '#ffaa33',
  p1: '#49d0ff',
  p1Dark: '#2090bb',
  p2: '#ff6b4a',
  p2Dark: '#bb3a2a',
  ball: '#ffe033',
  ballTrail: '#ff8800',
  text: '#e6edf3',
  muted: '#7a8a9a',
  accent: '#ff8a3d',
  accent2: '#49d0ff',
  accent3: '#86efac',
  panel: 'rgba(10,10,20,0.92)',
  shadow: 'rgba(0,0,0,0.4)',
};

// --- Court dimensions (in game units, side view) ---
const COURT = {
  groundY: 360,         // y position of ground
  leftX: 80,            // left edge of court
  rightX: 720,          // right edge of court
  netX: 400,            // center net x
  netHeight: 60,        // net visual height
  kitchenDepth: 90,     // kitchen zone width from net (each side)
};

// --- Game states ---
const STATE = {
  TITLE: 0,
  MATCH_INTRO: 1,
  PLAYING: 2,
  POINT_SCORED: 3,
  UPGRADE: 4,
  GAME_OVER: 5,
  VICTORY: 6,
};

// --- Opponents ---
const OPPONENTS = [
  { name: 'Rusty', title: 'The Weekend Warrior', color: '#cc8844', speed: 1.5, reaction: 0.6, power: 0.5, accuracy: 0.4 },
  { name: 'Brenda', title: 'Spin Queen', color: '#cc44aa', speed: 1.8, reaction: 0.55, power: 0.55, accuracy: 0.5 },
  { name: 'Chad', title: 'Banger Bro', color: '#44cc44', speed: 2.0, reaction: 0.5, power: 0.8, accuracy: 0.45 },
  { name: 'Miko', title: 'Kitchen Assassin', color: '#aa44cc', speed: 2.3, reaction: 0.4, power: 0.6, accuracy: 0.65 },
  { name: 'Big Tony', title: 'The Wall', color: '#cc6644', speed: 1.6, reaction: 0.35, power: 0.7, accuracy: 0.7 },
  { name: 'Svetlana', title: 'Ice Cold Dinks', color: '#44aacc', speed: 2.8, reaction: 0.3, power: 0.65, accuracy: 0.8 },
  { name: 'The Pickle', title: 'Final Boss', color: '#44ff44', speed: 3.2, reaction: 0.2, power: 0.85, accuracy: 0.9 },
];

// --- Upgrades pool ---
const UPGRADE_POOL = [
  { id: 'speed', icon: 'âš¡', name: 'Quick Feet', desc: '+20% move speed', apply: (p) => { p.speed *= 1.2; } },
  { id: 'power', icon: 'ðŸ’ª', name: 'Power Shot', desc: '+25% hit power', apply: (p) => { p.power *= 1.25; } },
  { id: 'reach', icon: 'ðŸ¦¾', name: 'Long Arm', desc: '+20% paddle reach', apply: (p) => { p.reachX *= 1.2; p.reachY *= 1.2; } },
  { id: 'stamina', icon: 'ðŸƒ', name: 'Endurance', desc: 'Faster recovery', apply: (p) => { p.recoveryRate *= 1.3; } },
  { id: 'spin', icon: 'ðŸŒ€', name: 'Wicked Spin', desc: 'Shots curve more', apply: (p) => { p.spinPower *= 1.4; } },
  { id: 'dink', icon: 'ðŸŽ¯', name: 'Soft Hands', desc: 'Better dink control', apply: (p) => { p.dinkSkill *= 1.3; } },
  { id: 'smash', icon: 'ðŸ”¨', name: 'Overhead Slam', desc: 'Stronger smashes', apply: (p) => { p.smashPower *= 1.3; } },
  { id: 'lucky', icon: 'ðŸ€', name: 'Lucky Paddle', desc: '+15% crit chance', apply: (p) => { p.critChance = Math.min(0.5, p.critChance + 0.15); } },
  { id: 'wall', icon: 'ðŸ§±', name: 'The Wall', desc: '+30% block range', apply: (p) => { p.reachY *= 1.3; } },
  { id: 'wind', icon: 'ðŸ’¨', name: 'Tailwind', desc: 'Ball goes faster', apply: (p) => { p.power *= 1.15; p.speed *= 1.1; } },
];

// --- Input ---
const keys = {};
let touchLeft = false, touchRight = false, touchSwing = false, touchLob = false;
window.addEventListener('keydown', e => { keys[e.key] = true; keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.key] = false; keys[e.code] = false; });

// Touch controls
canvas.addEventListener('touchstart', handleTouch, { passive: false });
canvas.addEventListener('touchmove', handleTouch, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

function handleTouch(e) {
  e.preventDefault();
  touchLeft = false; touchRight = false; touchSwing = false; touchLob = false;
  for (let t of e.touches) {
    const x = t.clientX / window.innerWidth;
    const y = t.clientY / window.innerHeight;
    if (y > 0.5) {
      if (x < 0.35) touchLeft = true;
      else if (x < 0.65) touchSwing = true;
      else touchRight = true;
    } else {
      if (x > 0.5) touchLob = true;
    }
  }
}
function handleTouchEnd(e) {
  e.preventDefault();
  if (e.touches.length === 0) {
    touchLeft = false; touchRight = false; touchSwing = false; touchLob = false;
  } else { handleTouch(e); }
}

// --- Player class ---
function createPlayer(isAI, side) {
  return {
    x: side === 'left' ? 200 : 600,
    y: COURT.groundY,
    vx: 0,
    vy: 0,
    side: side,
    isAI: isAI,
    // Stats
    speed: 3.5,
    power: 1.0,
    reachX: 35,
    reachY: 45,
    recoveryRate: 1.0,
    spinPower: 1.0,
    dinkSkill: 1.0,
    smashPower: 1.0,
    critChance: 0.05,
    // State
    swinging: false,
    swingTimer: 0,
    swingCooldown: 0,
    facingRight: side === 'left',
    // Animation
    walkFrame: 0,
    walkTimer: 0,
    hitFlash: 0,
    // Upgrades collected
    upgrades: [],
  };
}

// --- Ball ---
let ball = { x: 0, y: 0, vx: 0, vy: 0, active: false, gravity: 0.25, lastHitBy: null, bounced: false, trail: [], inPlay: false, spin: 0 };

// --- Game state ---
let state = STATE.TITLE;
let player, opponent;
let currentOpponentIdx = 0;
let playerScore = 0, opponentScore = 0;
let scoreToWin = 5;
let servingSide = 'left'; // player serves first
let serveReady = false;
let pointPause = 0;
let selectedUpgrades = [];
let upgradeSelection = -1;
let stars = [];
let particles = [];
let shakeTimer = 0, shakeIntensity = 0;
let flashTimer = 0;
let kitchenFault = '';
let kitchenFaultTimer = 0;

// Serve state
let serveState = 'none'; // 'none', 'toss', 'ready'
let serveBall = null;

// Generate stars
for (let i = 0; i < 80; i++) {
  stars.push({ x: Math.random() * W, y: Math.random() * (COURT.groundY - 80), size: Math.random() * 2 + 0.5, twinkle: Math.random() * Math.PI * 2 });
}

// --- AI state ---
let aiTargetX = 0;
let aiSwingIntent = false;
let aiReactionTimer = 0;
let aiDecisionTimer = 0;

// --- Init round ---
function initMatch() {
  const opp = OPPONENTS[currentOpponentIdx];
  player = createPlayer(false, 'left');
  // Apply saved upgrades
  for (const upg of (player.upgrades || [])) {
    upg.apply(player);
  }
  opponent = createPlayer(true, 'right');
  opponent.speed = opp.speed;
  opponent.power = 0.5 + opp.power * 0.8;
  opponent.reachX = 30 + opp.accuracy * 15;
  opponent.reachY = 40 + opp.accuracy * 15;
  playerScore = 0;
  opponentScore = 0;
  servingSide = 'left';
  resetBall();
}

function resetBall() {
  ball.active = false;
  ball.inPlay = false;
  ball.trail = [];
  ball.bounced = false;
  ball.lastHitBy = null;
  ball.spin = 0;
  serveReady = true;
  serveState = 'none';
  kitchenFault = '';
  kitchenFaultTimer = 0;

  if (servingSide === 'left') {
    ball.x = player.x + 20;
    ball.y = player.y - 50;
  } else {
    ball.x = opponent.x - 20;
    ball.y = opponent.y - 50;
  }
  ball.vx = 0;
  ball.vy = 0;
}

// ---- Serve logic ----
function doServe(who) {
  serveReady = false;
  ball.active = true;
  ball.inPlay = true;
  ball.bounced = false;
  if (who === 'left') {
    ball.x = player.x + 20;
    ball.y = player.y - 60;
    ball.vx = 5 + player.power * 2;
    ball.vy = -5 - player.power;
    ball.lastHitBy = 'left';
  } else {
    ball.x = opponent.x - 20;
    ball.y = opponent.y - 60;
    ball.vx = -(5 + opponent.power * 2);
    ball.vy = -5 - opponent.power;
    ball.lastHitBy = 'right';
  }
}

// ---- Check kitchen rules ----
// Kitchen (Non-Volley Zone): You can't volley (hit ball before bounce) while standing in the kitchen
function isInKitchen(px, side) {
  if (side === 'left') {
    // Left kitchen: from net going left by kitchenDepth
    return px >= (COURT.netX - COURT.kitchenDepth) && px <= COURT.netX;
  } else {
    // Right kitchen: from net going right by kitchenDepth
    return px >= COURT.netX && px <= (COURT.netX + COURT.kitchenDepth);
  }
}

function checkKitchenVolley(px, side, ballBounced) {
  // If player is in kitchen and ball hasn't bounced, it's a fault
  if (isInKitchen(px, side) && !ballBounced) {
    return true; // KITCHEN FAULT!
  }
  return false;
}

// ---- Hit ball ----
function tryHit(p, isLob) {
  if (p.swingCooldown > 0) return false;

  const dx = ball.x - p.x;
  const dy = ball.y - (p.y - 40);
  const dist = Math.sqrt(dx * dx + dy * dy);
  const reach = Math.sqrt(p.reachX * p.reachX + p.reachY * p.reachY);

  if (dist < reach && ball.active) {
    // Check kitchen fault
    if (checkKitchenVolley(p.x, p.side, ball.bounced)) {
      // Kitchen fault! Point to other side
      kitchenFault = p.side;
      kitchenFaultTimer = 90;
      scorePoint(p.side === 'left' ? 'right' : 'left');
      shakeTimer = 15;
      shakeIntensity = 4;
      addParticles(p.x, p.y - 40, COL.kitchenLine, 15);
      return true;
    }

    p.swinging = true;
    p.swingTimer = 10;
    p.swingCooldown = 15;
    p.hitFlash = 8;

    const dir = p.side === 'left' ? 1 : -1;
    const isCrit = Math.random() < p.critChance;
    const powerMult = isCrit ? 1.8 : 1.0;

    if (isLob) {
      // Lob shot - high arc
      ball.vx = dir * (3 + p.power * 1.5) * powerMult;
      ball.vy = -8 - p.power * 2;
    } else if (ball.y < p.y - 60) {
      // Overhead smash
      ball.vx = dir * (6 + p.smashPower * 3) * powerMult;
      ball.vy = 3 + p.smashPower;
    } else if (isInKitchen(p.x, p.side)) {
      // Dink shot (in kitchen after bounce)
      ball.vx = dir * (2 + p.dinkSkill * 0.5) * powerMult;
      ball.vy = -3 - p.dinkSkill * 0.5;
    } else {
      // Normal drive
      ball.vx = dir * (4 + p.power * 2.5) * powerMult;
      ball.vy = -4 - p.power * 1.5;
    }

    // Add spin
    ball.spin = p.spinPower * dir * 0.3;
    ball.lastHitBy = p.side;
    ball.bounced = false;

    // Effects
    shakeTimer = isCrit ? 10 : 4;
    shakeIntensity = isCrit ? 6 : 2;
    addParticles(ball.x, ball.y, isCrit ? '#ff4444' : COL.ball, isCrit ? 12 : 6);

    return true;
  }
  return false;
}

// ---- Score ----
function scorePoint(winner) {
  if (winner === 'left') {
    playerScore++;
  } else {
    opponentScore++;
  }
  ball.active = false;
  ball.inPlay = false;
  pointPause = 90;

  // Alternate serve
  servingSide = winner;

  // Check match end
  if (playerScore >= scoreToWin) {
    state = STATE.POINT_SCORED;
    pointPause = 120;
  } else if (opponentScore >= scoreToWin) {
    state = STATE.POINT_SCORED;
    pointPause = 120;
  } else {
    state = STATE.POINT_SCORED;
  }
}

// ---- Particles ----
function addParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6 - 2,
      life: 20 + Math.random() * 20,
      maxLife: 40,
      color,
      size: 2 + Math.random() * 3,
    });
  }
}

// ---- AI ----
function updateAI(dt) {
  const opp = OPPONENTS[currentOpponentIdx];

  aiDecisionTimer -= dt;
  if (aiDecisionTimer <= 0) {
    aiDecisionTimer = 5 + opp.reaction * 15;

    if (ball.active && ball.inPlay) {
      // Predict where ball will be
      let predX = ball.x + ball.vx * 15;
      let predY = ball.y + ball.vy * 10;

      // If ball coming toward AI
      if (ball.vx > 0 || ball.x > COURT.netX) {
        aiTargetX = predX - 15;
        // Should we swing?
        const dx = Math.abs(ball.x - opponent.x);
        const dy = Math.abs(ball.y - (opponent.y - 40));
        if (dx < opponent.reachX + 10 && dy < opponent.reachY + 10) {
          aiSwingIntent = true;
        }
      } else {
        // Return to home position
        aiTargetX = 600 + Math.random() * 60;
        aiSwingIntent = false;
      }
    } else {
      aiTargetX = 600;
      aiSwingIntent = false;
    }
  }

  // Move toward target
  const moveDir = aiTargetX - opponent.x;
  if (Math.abs(moveDir) > 5) {
    opponent.vx = Math.sign(moveDir) * opponent.speed;
    opponent.facingRight = moveDir > 0;
  } else {
    opponent.vx = 0;
  }

  // Swing
  if (aiSwingIntent && opponent.swingCooldown <= 0) {
    const dx = Math.abs(ball.x - opponent.x);
    const dy = Math.abs(ball.y - (opponent.y - 40));
    if (dx < opponent.reachX && dy < opponent.reachY) {
      // AI respects kitchen sometimes (higher skill = more respect)
      const inKit = isInKitchen(opponent.x, 'right');
      if (inKit && !ball.bounced && Math.random() < opp.accuracy) {
        // Smart AI won't volley in kitchen
        aiSwingIntent = false;
      } else {
        tryHit(opponent, Math.random() < 0.2);
        aiSwingIntent = false;
      }
    }
  }

  // AI serve
  if (serveReady && servingSide === 'right') {
    aiReactionTimer += dt;
    if (aiReactionTimer > 40) {
      doServe('right');
      aiReactionTimer = 0;
    }
  }
}

// ---- Player saved upgrades ----
let savedUpgrades = [];

// ---- Main update ----
function update() {
  const dt = 1;

  if (state === STATE.PLAYING) {
    // --- Player input ---
    let moveX = 0;
    if (keys['ArrowLeft'] || keys['a'] || keys['A'] || touchLeft) moveX = -1;
    if (keys['ArrowRight'] || keys['d'] || keys['D'] || touchRight) moveX = 1;

    player.vx = moveX * player.speed;
    player.facingRight = moveX > 0 ? true : moveX < 0 ? false : player.facingRight;

    // Swing (space or Z or touch)
    if ((keys[' '] || keys['z'] || keys['Z'] || touchSwing) && !player.swinging) {
      if (ball.active && ball.inPlay) {
        tryHit(player, false);
      }
    }

    // Lob (X or up arrow or touch)
    if ((keys['x'] || keys['X'] || keys['ArrowUp'] || touchLob) && !player.swinging) {
      if (ball.active && ball.inPlay) {
        tryHit(player, true);
      }
    }

    // Serve
    if (serveReady && servingSide === 'left') {
      if (keys[' '] || keys['z'] || keys['Z'] || touchSwing) {
        doServe('left');
      }
    }

    // --- Update player position ---
    player.x += player.vx;
    // Clamp player to left side of court
    player.x = Math.max(COURT.leftX, Math.min(COURT.netX - 20, player.x));

    // --- AI ---
    updateAI(dt);

    // Update opponent position
    opponent.x += opponent.vx;
    // Clamp opponent to right side
    opponent.x = Math.max(COURT.netX + 20, Math.min(COURT.rightX, opponent.x));

    // --- Ball physics ---
    if (ball.active) {
      // Trail
      ball.trail.push({ x: ball.x, y: ball.y });
      if (ball.trail.length > 8) ball.trail.shift();

      ball.vy += ball.gravity;
      ball.vx += ball.spin * 0.05;
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Net collision
      if (ball.y > COURT.groundY - COURT.netHeight && ball.y < COURT.groundY) {
        if ((ball.vx > 0 && ball.x >= COURT.netX - 3 && ball.x <= COURT.netX + 3) ||
            (ball.vx < 0 && ball.x >= COURT.netX - 3 && ball.x <= COURT.netX + 3)) {
          // Hit the net
          ball.vx *= -0.3;
          ball.vy *= 0.5;
          addParticles(COURT.netX, ball.y, COL.net, 5);
          shakeTimer = 5;
          shakeIntensity = 2;
        }
      }

      // Ground bounce
      if (ball.y >= COURT.groundY) {
        ball.y = COURT.groundY;

        if (!ball.bounced && ball.inPlay) {
          // First bounce
          ball.bounced = true;
          ball.vy = -ball.vy * 0.5;
          ball.vx *= 0.8;
          addParticles(ball.x, COURT.groundY, '#8B7355', 4);

          // Check if ball is in bounds
          if (ball.x < COURT.leftX || ball.x > COURT.rightX) {
            // Out of bounds - point to other side
            scorePoint(ball.lastHitBy === 'left' ? 'right' : 'left');
            addParticles(ball.x, COURT.groundY, '#ff4444', 8);
          }
        } else if (ball.bounced) {
          // Second bounce - point scored
          if (ball.x < COURT.netX) {
            // Bounced on left (player) side twice
            scorePoint('right');
          } else {
            // Bounced on right (opponent) side twice
            scorePoint('left');
          }
          addParticles(ball.x, COURT.groundY, COL.accent3, 8);
        }
      }

      // Ceiling
      if (ball.y < 20) { ball.y = 20; ball.vy = Math.abs(ball.vy) * 0.5; }

      // Side walls (out of bounds if goes too far)
      if (ball.x < COURT.leftX - 50 || ball.x > COURT.rightX + 50) {
        if (ball.inPlay) {
          scorePoint(ball.lastHitBy === 'left' ? 'right' : 'left');
        }
      }
    }

    // --- Timers ---
    if (player.swingTimer > 0) player.swingTimer--;
    if (player.swingCooldown > 0) player.swingCooldown--;
    if (player.hitFlash > 0) player.hitFlash--;
    if (opponent.swingTimer > 0) opponent.swingTimer--;
    if (opponent.swingCooldown > 0) opponent.swingCooldown--;
    if (opponent.hitFlash > 0) opponent.hitFlash--;

    // Walk animation
    if (Math.abs(player.vx) > 0.5) { player.walkTimer++; if (player.walkTimer > 8) { player.walkTimer = 0; player.walkFrame = (player.walkFrame + 1) % 4; } }
    else { player.walkFrame = 0; player.walkTimer = 0; }
    if (Math.abs(opponent.vx) > 0.5) { opponent.walkTimer++; if (opponent.walkTimer > 8) { opponent.walkTimer = 0; opponent.walkFrame = (opponent.walkFrame + 1) % 4; } }
    else { opponent.walkFrame = 0; opponent.walkTimer = 0; }

  } else if (state === STATE.POINT_SCORED) {
    pointPause--;
    if (pointPause <= 0) {
      if (playerScore >= scoreToWin) {
        // Player wins match
        currentOpponentIdx++;
        if (currentOpponentIdx >= OPPONENTS.length) {
          state = STATE.VICTORY;
        } else {
          // Show upgrade screen
          generateUpgrades();
          state = STATE.UPGRADE;
        }
      } else if (opponentScore >= scoreToWin) {
        state = STATE.GAME_OVER;
      } else {
        // Continue match
        resetBall();
        state = STATE.PLAYING;
      }
    }
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Shake
  if (shakeTimer > 0) shakeTimer--;
  if (kitchenFaultTimer > 0) kitchenFaultTimer--;
  if (flashTimer > 0) flashTimer--;
}

// ---- Upgrade screen ----
function generateUpgrades() {
  const shuffled = [...UPGRADE_POOL].sort(() => Math.random() - 0.5);
  selectedUpgrades = shuffled.slice(0, 3);
  upgradeSelection = -1;
}

function selectUpgrade(idx) {
  if (idx < 0 || idx >= selectedUpgrades.length) return;
  const upg = selectedUpgrades[idx];
  savedUpgrades.push(upg);
  // Start next match
  state = STATE.MATCH_INTRO;
}

// ---- Draw functions ----
function drawSky() {
  const grad = ctx.createLinearGradient(0, 0, 0, COURT.groundY);
  grad.addColorStop(0, COL.skyGrad1);
  grad.addColorStop(1, COL.skyGrad2);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, COURT.groundY);

  // Stars
  const time = Date.now() * 0.001;
  for (const s of stars) {
    const alpha = 0.3 + 0.7 * Math.abs(Math.sin(time + s.twinkle));
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.fillRect(Math.floor(s.x), Math.floor(s.y), Math.ceil(s.size), Math.ceil(s.size));
  }
}

function drawCourt() {
  // Ground
  ctx.fillStyle = COL.court;
  ctx.fillRect(COURT.leftX, COURT.groundY, COURT.rightX - COURT.leftX, H - COURT.groundY);

  // Darker below
  ctx.fillStyle = '#0a3a15';
  ctx.fillRect(0, COURT.groundY + 40, W, H - COURT.groundY - 40);
  ctx.fillStyle = '#051a0a';
  ctx.fillRect(0, COURT.groundY + 80, W, H);

  // Court floor stripe pattern
  for (let x = COURT.leftX; x < COURT.rightX; x += 40) {
    ctx.fillStyle = (Math.floor(x / 40) % 2 === 0) ? COL.court : COL.courtDark;
    ctx.fillRect(x, COURT.groundY, 40, 35);
  }

  // Kitchen zones (highlighted)
  const kitAlpha = 0.15 + 0.05 * Math.sin(Date.now() * 0.003);
  ctx.fillStyle = `rgba(255,170,51,${kitAlpha})`;
  // Left kitchen
  ctx.fillRect(COURT.netX - COURT.kitchenDepth, COURT.groundY, COURT.kitchenDepth, 35);
  // Right kitchen
  ctx.fillRect(COURT.netX, COURT.groundY, COURT.kitchenDepth, 35);

  // Kitchen lines
  ctx.strokeStyle = COL.kitchenLine;
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 4]);
  // Left kitchen line
  ctx.beginPath();
  ctx.moveTo(COURT.netX - COURT.kitchenDepth, COURT.groundY);
  ctx.lineTo(COURT.netX - COURT.kitchenDepth, COURT.groundY + 35);
  ctx.stroke();
  // Right kitchen line
  ctx.beginPath();
  ctx.moveTo(COURT.netX + COURT.kitchenDepth, COURT.groundY);
  ctx.lineTo(COURT.netX + COURT.kitchenDepth, COURT.groundY + 35);
  ctx.stroke();
  ctx.setLineDash([]);

  // Kitchen labels
  ctx.fillStyle = `rgba(255,170,51,0.6)`;
  ctx.font = '10px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('KITCHEN', COURT.netX - COURT.kitchenDepth / 2, COURT.groundY + 25);
  ctx.fillText('KITCHEN', COURT.netX + COURT.kitchenDepth / 2, COURT.groundY + 25);

  // Court boundary lines
  ctx.strokeStyle = COL.courtLine;
  ctx.lineWidth = 2;
  ctx.setLineDash([]);
  ctx.strokeRect(COURT.leftX, COURT.groundY, COURT.rightX - COURT.leftX, 35);

  // Center line (baseline)
  ctx.beginPath();
  ctx.moveTo(COURT.netX, COURT.groundY);
  ctx.lineTo(COURT.netX, COURT.groundY + 35);
  ctx.stroke();

  // Net
  ctx.fillStyle = COL.netPole;
  ctx.fillRect(COURT.netX - 2, COURT.groundY - COURT.netHeight, 4, COURT.netHeight);

  // Net mesh
  ctx.strokeStyle = COL.net;
  ctx.lineWidth = 1;
  for (let ny = COURT.groundY - COURT.netHeight; ny < COURT.groundY; ny += 6) {
    ctx.beginPath();
    ctx.moveTo(COURT.netX - 6, ny);
    ctx.lineTo(COURT.netX + 6, ny);
    ctx.stroke();
  }
  for (let nx = COURT.netX - 6; nx <= COURT.netX + 6; nx += 3) {
    ctx.beginPath();
    ctx.moveTo(nx, COURT.groundY - COURT.netHeight);
    ctx.lineTo(nx, COURT.groundY);
    ctx.stroke();
  }

  // Net top
  ctx.fillStyle = COL.courtLine;
  ctx.fillRect(COURT.netX - 7, COURT.groundY - COURT.netHeight - 2, 14, 3);
}

function drawPlayer(p, color, darkColor, label) {
  const x = Math.floor(p.x);
  const y = Math.floor(p.y);
  const facing = p.facingRight ? 1 : -1;

  // Shadow
  ctx.fillStyle = COL.shadow;
  ctx.beginPath();
  ctx.ellipse(x, y + 2, 14, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Legs with walk animation
  const legOffset = [0, -3, 0, 3][p.walkFrame];
  ctx.fillStyle = darkColor;
  ctx.fillRect(x - 6, y - 14, 5, 14); // left leg
  ctx.fillRect(x + 1, y - 14 + legOffset, 5, 14 - legOffset); // right leg (animated)

  // Body
  ctx.fillStyle = color;
  ctx.fillRect(x - 8, y - 36, 16, 22);

  // Head
  const headColor = p.hitFlash > 0 ? '#ffffff' : color;
  ctx.fillStyle = headColor;
  ctx.fillRect(x - 6, y - 48, 12, 12);

  // Eyes
  ctx.fillStyle = '#000';
  if (facing > 0) {
    ctx.fillRect(x, y - 44, 3, 3);
    ctx.fillRect(x + 4, y - 44, 3, 3);
  } else {
    ctx.fillRect(x - 7, y - 44, 3, 3);
    ctx.fillRect(x - 3, y - 44, 3, 3);
  }

  // Paddle arm
  const paddleExtend = p.swingTimer > 0 ? 18 : 8;
  const paddleY = p.swingTimer > 0 ? -38 : -30;
  ctx.fillStyle = '#ddd';
  ctx.fillRect(x + facing * 8, y + paddleY, facing * paddleExtend, 3);
  // Paddle head
  ctx.fillStyle = color;
  ctx.fillRect(x + facing * (8 + paddleExtend), y + paddleY - 6, facing * 6, 14);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + facing * (8 + paddleExtend), y + paddleY - 6, facing * 6, 14);

  // Name label
  ctx.fillStyle = color;
  ctx.font = 'bold 10px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText(label, x, y - 54);

  // Kitchen indicator
  if (isInKitchen(p.x, p.side)) {
    ctx.fillStyle = `rgba(255,170,51,${0.5 + 0.3 * Math.sin(Date.now() * 0.008)})`;
    ctx.font = 'bold 9px "Courier New"';
    ctx.fillText('âš  NVZ', x, y - 62);
  }
}

function drawBall() {
  if (!ball.active && !serveReady) return;

  // Trail
  for (let i = 0; i < ball.trail.length; i++) {
    const t = ball.trail[i];
    const alpha = (i / ball.trail.length) * 0.5;
    ctx.fillStyle = `rgba(255,136,0,${alpha})`;
    const size = 2 + (i / ball.trail.length) * 3;
    ctx.fillRect(Math.floor(t.x - size / 2), Math.floor(t.y - size / 2), size, size);
  }

  // Ball shadow
  if (ball.y < COURT.groundY) {
    ctx.fillStyle = COL.shadow;
    ctx.beginPath();
    ctx.ellipse(ball.x, COURT.groundY + 2, 5, 2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Ball
  ctx.fillStyle = COL.ball;
  ctx.fillRect(Math.floor(ball.x - 4), Math.floor(ball.y - 4), 8, 8);
  // Ball highlight
  ctx.fillStyle = '#fff';
  ctx.fillRect(Math.floor(ball.x - 2), Math.floor(ball.y - 4), 3, 2);

  // Serve indicator
  if (serveReady && !ball.inPlay) {
    ctx.fillStyle = `rgba(255,224,51,${0.5 + 0.3 * Math.sin(Date.now() * 0.005)})`;
    ctx.font = 'bold 12px "Courier New"';
    ctx.textAlign = 'center';
    if (servingSide === 'left') {
      ctx.fillText('SPACE to Serve', player.x, player.y - 75);
    }
  }
}

function drawHUD() {
  // Score bar at top
  ctx.fillStyle = COL.panel;
  ctx.fillRect(0, 0, W, 32);

  ctx.font = 'bold 14px "Courier New"';
  ctx.textAlign = 'left';
  ctx.fillStyle = COL.p1;
  ctx.fillText(`YOU: ${playerScore}`, 20, 22);

  ctx.textAlign = 'right';
  ctx.fillStyle = COL.p2;
  const oppName = OPPONENTS[currentOpponentIdx] ? OPPONENTS[currentOpponentIdx].name.toUpperCase() : 'CPU';
  ctx.fillText(`${oppName}: ${opponentScore}`, W - 20, 22);

  ctx.textAlign = 'center';
  ctx.fillStyle = COL.muted;
  ctx.font = '11px "Courier New"';
  ctx.fillText(`First to ${scoreToWin} | Round ${currentOpponentIdx + 1}/7`, W / 2, 14);

  // Serve indicator
  ctx.fillStyle = COL.accent;
  ctx.font = '10px "Courier New"';
  ctx.fillText(servingSide === 'left' ? 'â— YOUR SERVE' : 'â— THEIR SERVE', W / 2, 26);

  // Kitchen fault flash
  if (kitchenFaultTimer > 0) {
    const alpha = kitchenFaultTimer / 90;
    ctx.fillStyle = `rgba(255,100,30,${alpha * 0.3})`;
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = `rgba(255,170,51,${alpha})`;
    ctx.font = 'bold 28px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText('KITCHEN FAULT!', W / 2, H / 2 - 40);
    ctx.font = '14px "Courier New"';
    ctx.fillText('No volleys in the Non-Volley Zone!', W / 2, H / 2 - 10);
  }

  // Controls hint
  ctx.fillStyle = COL.muted;
  ctx.font = '9px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('â† â†’ Move | SPACE Hit | X Lob | â†‘ Lob', W / 2, H - 10);

  // Player upgrades display
  if (savedUpgrades.length > 0) {
    ctx.fillStyle = 'rgba(10,10,20,0.7)';
    ctx.fillRect(0, 33, W, 16);
    ctx.fillStyle = COL.accent2;
    ctx.font = '9px "Courier New"';
    ctx.textAlign = 'left';
    const buffText = savedUpgrades.map(u => u.icon + u.name).join('  ');
    ctx.fillText('Buffs: ' + buffText, 10, 44);
  }
}

function drawParticles() {
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(Math.floor(p.x), Math.floor(p.y), Math.ceil(p.size), Math.ceil(p.size));
  }
  ctx.globalAlpha = 1;
}

// ---- Screen draws ----
function drawTitle() {
  drawSky();
  drawCourt();

  // Overlay
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.fillStyle = COL.accent;
  ctx.font = 'bold 42px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('DINK CITY', W / 2, 140);

  // Subtitle glow
  ctx.fillStyle = COL.accent2;
  ctx.font = 'bold 14px "Courier New"';
  ctx.fillText('RETRO PICKLEBALL ROGUELIKE', W / 2, 170);

  // Instructions
  ctx.fillStyle = COL.text;
  ctx.font = '12px "Courier New"';
  const lines = [
    'Defeat 7 opponents in a bracket tournament.',
    'Earn upgrades between rounds.',
    'Lose once and it\'s all over!',
    '',
    'â† â†’ / A D  to move',
    'SPACE / Z   to hit',
    'X / â†‘       to lob',
    '',
    'âš  KITCHEN RULES ENFORCED âš ',
    'No volleys in the Non-Volley Zone!',
  ];
  lines.forEach((l, i) => {
    ctx.fillStyle = l.includes('KITCHEN') ? COL.kitchenLine : COL.text;
    ctx.fillText(l, W / 2, 210 + i * 20);
  });

  // Start prompt
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = COL.accent;
    ctx.font = 'bold 16px "Courier New"';
    ctx.fillText('[ PRESS SPACE TO START ]', W / 2, 440);
  }

  // Bracket preview
  ctx.fillStyle = COL.muted;
  ctx.font = '10px "Courier New"';
  ctx.fillText('BRACKET', W / 2, 455);
  for (let i = 0; i < 7; i++) {
    const bx = W / 2 - 100 + i * 30;
    ctx.strokeStyle = COL.muted;
    ctx.lineWidth = 1;
    ctx.strokeRect(bx, 462, 22, 18);
    ctx.fillStyle = COL.muted;
    ctx.font = '8px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(OPPONENTS[i].name[0], bx + 11, 475);
  }
}

function drawMatchIntro() {
  drawSky();
  drawCourt();

  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, W, H);

  const opp = OPPONENTS[currentOpponentIdx];

  // Round header
  ctx.fillStyle = COL.muted;
  ctx.font = 'bold 14px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText(`â€” ROUND ${currentOpponentIdx + 1} OF 7 â€”`, W / 2, 120);

  // Bracket
  for (let i = 0; i < 7; i++) {
    const bx = W / 2 - 100 + i * 30;
    let col = COL.muted;
    let bg = 'transparent';
    if (i < currentOpponentIdx) { col = COL.accent3; bg = 'rgba(134,239,172,0.1)'; }
    else if (i === currentOpponentIdx) { col = COL.accent; bg = 'rgba(255,138,61,0.15)'; }
    ctx.fillStyle = bg;
    ctx.fillRect(bx, 135, 22, 18);
    ctx.strokeStyle = col;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(bx, 135, 22, 18);
    ctx.fillStyle = col;
    ctx.font = '8px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText(OPPONENTS[i].name[0], bx + 11, 148);
  }

  // VS
  ctx.fillStyle = COL.text;
  ctx.font = 'bold 24px "Courier New"';
  ctx.fillText('VS', W / 2, 200);

  // Opponent
  ctx.fillStyle = opp.color;
  ctx.font = 'bold 28px "Courier New"';
  ctx.fillText(opp.name.toUpperCase(), W / 2, 250);
  ctx.fillStyle = COL.muted;
  ctx.font = 'italic 12px "Courier New"';
  ctx.fillText(`"${opp.title}"`, W / 2, 272);

  // Stats
  const stats = [
    { label: 'Speed', val: opp.speed / 3.5 },
    { label: 'Power', val: opp.power },
    { label: 'Accuracy', val: opp.accuracy },
  ];
  stats.forEach((s, i) => {
    const sx = W / 2 - 80;
    const sy = 300 + i * 22;
    ctx.fillStyle = COL.muted;
    ctx.font = '11px "Courier New"';
    ctx.textAlign = 'left';
    ctx.fillText(s.label, sx, sy);
    // Bar
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(sx + 80, sy - 8, 80, 8);
    ctx.fillStyle = opp.color;
    ctx.fillRect(sx + 80, sy - 8, 80 * Math.min(1, s.val), 8);
  });

  // Your buffs
  if (savedUpgrades.length > 0) {
    ctx.fillStyle = COL.accent2;
    ctx.font = '11px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText('Your buffs:', W / 2, 385);
    const buffText = savedUpgrades.map(u => u.icon + u.name).join('  ');
    ctx.fillStyle = COL.text;
    ctx.font = '10px "Courier New"';
    ctx.fillText(buffText, W / 2, 402);
  }

  // Start
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = COL.accent;
    ctx.font = 'bold 14px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillText('[ PRESS SPACE TO FIGHT ]', W / 2, 450);
  }
}

function drawUpgradeScreen() {
  drawSky();
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = COL.accent3;
  ctx.font = 'bold 28px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('VICTORY!', W / 2, 80);

  ctx.fillStyle = COL.text;
  ctx.font = '14px "Courier New"';
  ctx.fillText('Choose an upgrade:', W / 2, 120);

  // 3 upgrade cards
  for (let i = 0; i < selectedUpgrades.length; i++) {
    const u = selectedUpgrades[i];
    const cx = W / 2 - 240 + i * 200;
    const cy = 160;
    const cw = 180;
    const ch = 200;

    const hover = upgradeSelection === i;
    ctx.fillStyle = hover ? 'rgba(255,138,61,0.15)' : 'rgba(255,255,255,0.05)';
    ctx.fillRect(cx, cy, cw, ch);
    ctx.strokeStyle = hover ? COL.accent : 'rgba(255,255,255,0.15)';
    ctx.lineWidth = hover ? 2 : 1;
    ctx.strokeRect(cx, cy, cw, ch);

    // Icon
    ctx.font = '36px serif';
    ctx.textAlign = 'center';
    ctx.fillText(u.icon, cx + cw / 2, cy + 60);

    // Name
    ctx.fillStyle = COL.text;
    ctx.font = 'bold 13px "Courier New"';
    ctx.fillText(u.name, cx + cw / 2, cy + 100);

    // Desc
    ctx.fillStyle = COL.muted;
    ctx.font = '11px "Courier New"';
    ctx.fillText(u.desc, cx + cw / 2, cy + 125);

    // Key hint
    ctx.fillStyle = COL.accent;
    ctx.font = 'bold 14px "Courier New"';
    ctx.fillText(`[ ${i + 1} ]`, cx + cw / 2, cy + 170);
  }

  ctx.fillStyle = COL.muted;
  ctx.font = '11px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('Press 1, 2, or 3 to choose', W / 2, 400);
}

function drawGameOver() {
  drawSky();
  drawCourt();
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 36px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', W / 2, 180);

  ctx.fillStyle = COL.muted;
  ctx.font = '14px "Courier New"';
  ctx.fillText(`Defeated by ${OPPONENTS[currentOpponentIdx].name} in Round ${currentOpponentIdx + 1}`, W / 2, 220);

  ctx.fillStyle = COL.text;
  ctx.font = '12px "Courier New"';
  ctx.fillText(`Rounds won: ${currentOpponentIdx} / 7`, W / 2, 260);

  if (savedUpgrades.length > 0) {
    ctx.fillText('Upgrades collected:', W / 2, 290);
    const buffText = savedUpgrades.map(u => u.icon + u.name).join('  ');
    ctx.fillStyle = COL.accent2;
    ctx.font = '10px "Courier New"';
    ctx.fillText(buffText, W / 2, 310);
  }

  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = COL.accent;
    ctx.font = 'bold 14px "Courier New"';
    ctx.fillText('[ PRESS SPACE TO TRY AGAIN ]', W / 2, 380);
  }
}

function drawVictory() {
  drawSky();
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, 0, W, H);

  // Confetti particles
  if (Math.random() < 0.3) {
    addParticles(Math.random() * W, -10, ['#ff4444','#44ff44','#4444ff','#ffff44','#ff44ff'][Math.floor(Math.random()*5)], 1);
  }
  drawParticles();

  ctx.fillStyle = COL.accent3;
  ctx.font = 'bold 42px "Courier New"';
  ctx.textAlign = 'center';
  ctx.fillText('CHAMPION!', W / 2, 160);

  ctx.fillStyle = COL.accent;
  ctx.font = 'bold 16px "Courier New"';
  ctx.fillText('You conquered Dink City!', W / 2, 200);

  ctx.fillStyle = COL.text;
  ctx.font = '12px "Courier New"';
  ctx.fillText('All 7 opponents defeated!', W / 2, 240);

  if (savedUpgrades.length > 0) {
    ctx.fillText('Final build:', W / 2, 280);
    const buffText = savedUpgrades.map(u => u.icon + u.name).join('  ');
    ctx.fillStyle = COL.accent2;
    ctx.font = '10px "Courier New"';
    ctx.fillText(buffText, W / 2, 300);
  }

  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = COL.accent;
    ctx.font = 'bold 14px "Courier New"';
    ctx.fillText('[ PRESS SPACE TO PLAY AGAIN ]', W / 2, 380);
  }
}

function drawPointScored() {
  drawSky();
  drawCourt();
  drawPlayer(player, COL.p1, COL.p1Dark, 'YOU');
  drawPlayer(opponent, COL.p2, COL.p2Dark, OPPONENTS[currentOpponentIdx].name.toUpperCase());
  drawBall();
  drawParticles();
  drawHUD();

  // Big score flash
  const alpha = Math.min(1, pointPause / 60);
  ctx.fillStyle = `rgba(0,0,0,${alpha * 0.4})`;
  ctx.fillRect(0, 0, W, H);

  // Show who scored
  ctx.textAlign = 'center';
  if (playerScore >= scoreToWin) {
    ctx.fillStyle = COL.accent3;
    ctx.font = 'bold 32px "Courier New"';
    ctx.fillText('MATCH WON!', W / 2, H / 2);
  } else if (opponentScore >= scoreToWin) {
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 32px "Courier New"';
    ctx.fillText('MATCH LOST!', W / 2, H / 2);
  } else {
    ctx.font = 'bold 24px "Courier New"';
    ctx.fillStyle = COL.text;
    ctx.fillText(`${playerScore} - ${opponentScore}`, W / 2, H / 2);
  }
}

// ---- Main draw ----
function draw() {
  ctx.clearRect(0, 0, W, H);

  // Screen shake
  if (shakeTimer > 0) {
    const sx = (Math.random() - 0.5) * shakeIntensity;
    const sy = (Math.random() - 0.5) * shakeIntensity;
    ctx.save();
    ctx.translate(sx, sy);
  }

  switch (state) {
    case STATE.TITLE:
      drawTitle();
      break;
    case STATE.MATCH_INTRO:
      drawMatchIntro();
      break;
    case STATE.PLAYING:
      drawSky();
      drawCourt();
      drawPlayer(player, COL.p1, COL.p1Dark, 'YOU');
      drawPlayer(opponent, COL.p2, COL.p2Dark, OPPONENTS[currentOpponentIdx].name.toUpperCase());
      drawBall();
      drawParticles();
      drawHUD();
      break;
    case STATE.POINT_SCORED:
      drawPointScored();
      break;
    case STATE.UPGRADE:
      drawUpgradeScreen();
      break;
    case STATE.GAME_OVER:
      drawGameOver();
      break;
    case STATE.VICTORY:
      drawVictory();
      break;
  }

  if (shakeTimer > 0) {
    ctx.restore();
  }
}

// ---- Input handling for menus ----
window.addEventListener('keydown', function(e) {
  if (state === STATE.TITLE) {
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') {
      currentOpponentIdx = 0;
      savedUpgrades = [];
      state = STATE.MATCH_INTRO;
    }
  } else if (state === STATE.MATCH_INTRO) {
    if (e.code === 'Space' || e.key === 'z' || e.key === 'Z') {
      initMatch();
      // Apply saved upgrades
      for (const upg of savedUpgrades) {
        upg.apply(player);
      }
      state = STATE.PLAYING;
    }
  } else if (state === STATE.UPGRADE) {
    if (e.key === '1') selectUpgrade(0);
    else if (e.key === '2') selectUpgrade(1);
    else if (e.key === '3') selectUpgrade(2);
  } else if (state === STATE.GAME_OVER || state === STATE.VICTORY) {
    if (e.code === 'Space') {
      state = STATE.TITLE;
    }
  }
});

// Mouse/touch for upgrade selection
canvas.addEventListener('click', function(e) {
  if (state === STATE.UPGRADE) {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / SCALE;
    const my = (e.clientY - rect.top) / SCALE;

    for (let i = 0; i < 3; i++) {
      const cx = W / 2 - 240 + i * 200;
      const cy = 160;
      if (mx >= cx && mx <= cx + 180 && my >= cy && my <= cy + 200) {
        selectUpgrade(i);
        return;
      }
    }
  }

  // Also handle menu clicks
  if (state === STATE.TITLE || state === STATE.MATCH_INTRO || state === STATE.GAME_OVER || state === STATE.VICTORY) {
    // Simulate space press
    const evt = new KeyboardEvent('keydown', { code: 'Space', key: ' ' });
    window.dispatchEvent(evt);
  }
});

// Mouse hover for upgrade cards
canvas.addEventListener('mousemove', function(e) {
  if (state === STATE.UPGRADE) {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / SCALE;
    const my = (e.clientY - rect.top) / SCALE;

    upgradeSelection = -1;
    for (let i = 0; i < 3; i++) {
      const cx = W / 2 - 240 + i * 200;
      const cy = 160;
      if (mx >= cx && mx <= cx + 180 && my >= cy && my <= cy + 200) {
        upgradeSelection = i;
        break;
      }
    }
  }
});

// ---- Game loop ----
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}
gameLoop();

</script>
</body>
</html>
